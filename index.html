<!-- index.html -->
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="assets/vendor/fontawesome/css/all.min.css" />
    <link
      rel="preload"
      href="assets/vendor/fontawesome/webfonts/fa-solid-900.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <link
      rel="preload"
      href="assets/vendor/fontawesome/webfonts/fa-regular-400.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <link
      rel="preload"
      href="assets/vendor/fontawesome/webfonts/fa-brands-400.woff2"
      as="font"
      type="font/woff2"
      crossorigin
    />
    <script>
      (() => {
        let readyMarked = false;
        const markReady = () => {
          if (readyMarked) return;
          readyMarked = true;
          try {
            document.documentElement.classList.add("fa-ready");
          } catch {}
        };
        const isReady = () => {
          try {
            if (!document.fonts || typeof document.fonts.check !== "function") {
              return true;
            }
            return (
              document.fonts.check('16px "Font Awesome 6 Free"') ||
              document.fonts.check('16px "Font Awesome 6 Brands"') ||
              document.fonts.check("16px FontAwesome")
            );
          } catch {
            return true;
          }
        };

        const primeFonts = async () => {
          try {
            if (!document.fonts || typeof document.fonts.load !== "function") {
              return;
            }
            await Promise.allSettled([
              document.fonts.load('900 16px "Font Awesome 6 Free"'),
              document.fonts.load('400 16px "Font Awesome 6 Free"'),
              document.fonts.load('400 16px "Font Awesome 6 Brands"'),
            ]);
          } catch {}
        };

        const bootstrap = async () => {
          if (isReady()) {
            markReady();
            return;
          }

          await primeFonts();
          if (isReady()) {
            markReady();
            return;
          }

          try {
            if (document.fonts && document.fonts.ready) {
              await Promise.race([
                document.fonts.ready,
                new Promise((resolve) => setTimeout(resolve, 1200)),
              ]);
            }
          } catch {}

          // Prevent permanent fallback mode if font checks lag or fail to report.
          markReady();
        };

        bootstrap();
      })();
    </script>

    <title>Achievements</title>
    <style>
      html,
      body {
        user-select: none;
        overflow: hidden;
        height: 100vh;
      }

      button,
      input,
      textarea,
      select {
        -webkit-app-region: no-drag;
      }

      table {
        width: 90%;
        border-collapse: collapse;
      }

      table,
      th,
      td {
        margin-top: 20px;
        border: 1px solid black;
      }

      .displayName {
        padding-left: 15px;
      }

      .description {
        padding-left: 25px;
      }

      .image {
        padding-top: 5px;
        text-align: center;
      }

      img {
        width: 100px;
        height: auto;
        align-self: center;
      }

      #config-list {
        margin-top: 10px;
        margin-bottom: 20px;
      }

      button {
        margin-top: 10px;
        margin-bottom: 20px;
      }

      label {
        margin-top: 10px;
        margin-bottom: 20px;
      }

      .status {
        text-align: center;
        vertical-align: middle;
        font-size: 14px;
      }

      .locked {
        color: red;
        font-weight: bold;
      }

      .unlocked {
        color: green;
        font-weight: bold;
      }

      .progress-bar {
        height: 5px;
        background-color: #44475a;
        border-radius: 3px;
        overflow: hidden;
        margin-top: 4px;
        width: 50%;
      }

      .progress-fill {
        height: 100%;
        background-color: #50fa7b;
        border-radius: 3px;
        transition: width 0.3s ease;
      }

      .achievement-progress {
        font-size: 0.85em;
        color: #888;
      }

      .sort-btn {
        position: relative;
        top: 2px;
        right: 5px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        border: 1px solid var(--dracula-purple, #6272a4);
        background: transparent;
        color: var(--dracula-purple, #bd93f9);
        border-radius: 8px;
        cursor: pointer;
        transition:
          background 0.15s,
          color 0.15s,
          border-color 0.15s;
      }

      .sort-btn .dir {
        font-weight: 400;
        font-size: 12px;
        opacity: 0.9;
      }

      .sort-btn.active {
        background: rgba(189, 147, 249, 0.15);
        color: white;
        border-color: var(--dracula-cyan, #8be9fd);
      }

      .sort-btn:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(139, 233, 253, 0.35);
      }
    </style>
  </head>

  <body>
    <!-- Modern Titlebar -->
    <div id="titlebar" class="titlebar">
      <div class="titlebar-logo">
        <img id="appIcon" alt="App Icon" />
        <span id="appTitle" class="titlebar-title">Achievements</span>
      </div>
      <div class="titlebar-controls">
        <button id="settingsBtn" class="titlebar-button">
          <i class="fas fa-cog" aria-hidden="true"></i>
          <span class="titlebar-fallback" aria-hidden="true">‚öô</span>
        </button>
        <button id="minimizeBtn" class="titlebar-button">
          <i class="fas fa-minus" aria-hidden="true"></i>
          <span class="titlebar-fallback" aria-hidden="true">‚àí</span>
        </button>
        <button id="maximizeBtn" class="titlebar-button">
          <i class="far fa-square" aria-hidden="true"></i>
          <span class="titlebar-fallback" aria-hidden="true">‚ñ°</span>
        </button>
        <button id="closeBtn" class="titlebar-button close">
          <i class="fas fa-times" aria-hidden="true"></i>
          <span class="titlebar-fallback" aria-hidden="true">√ó</span>
        </button>
      </div>
    </div>

    <div id="bootLoading" role="status" aria-live="polite">
      <div class="boot-loading-card">
        <div class="boot-spinner" aria-hidden="true"></div>
        <div class="boot-loading-title">Booting‚Ä¶</div>
        <div class="boot-loading-sub">Preparing achievements cache</div>
      </div>
    </div>

    <!-- Settings Menu Panel -->
    <div id="settingsMenu" class="settings-menu hidden">
      <div
        class="settings-content"
        role="dialog"
        aria-modal="true"
        tabindex="-1"
      >
        <button class="settings-close-button" id="closeSettingsBtn">
          &times;
        </button>

        <div
          id="settingsTabs"
          class="settings-tabs"
          role="tablist"
          aria-label="Settings tabs"
        >
          <h3
            id="settingsTitle"
            style="margin: 0 0 15px 10px; color: var(--dracula-purple)"
          >
            Settings
          </h3>
          <button
            id="tab-general"
            class="settings-tab active"
            data-tab="general"
          >
            General
          </button>
          <button
            id="tab-notification"
            class="settings-tab"
            data-tab="notification"
          >
            Notification
          </button>
          <button id="tab-folders" class="settings-tab" data-tab="folders">
            Folders
          </button>
          <button id="tab-advanced" class="settings-tab" data-tab="advanced">
            Advanced
          </button>
          <button
            id="tab-shortcuts"
            class="settings-tab"
            data-tab="shortcuts"
            title="Keyboard & Controller Shortcuts"
          >
            Shortcuts
          </button>
          <button
            id="tab-platformGuide"
            class="settings-tab"
            data-tab="platformGuide"
            title="Platform & Emulator Guide"
          >
            Platform Guide
          </button>
        </div>

        <div class="settings-tabs-content" tabindex="0">
          <div
            id="generalTab"
            class="tab-content active"
            role="tabpanel"
            aria-labelledby="tab-general"
          >
            <div style="padding: 0 10px">
              <div class="settings-section">
                <h4 id="settings-appScaleTitle">App Scale</h4>
                <div class="settings-control">
                  <label for="app-zoom-dropdown">Zoom Level:</label>
                  <select id="app-zoom-dropdown">
                    <option value="0.75">75%</option>
                    <option value="1" selected>100%</option>
                    <option value="1.25">125%</option>
                    <option value="1.5">150%</option>
                    <option value="2">200%</option>
                  </select>
                </div>
              </div>
              <div class="settings-section">
                <h4 id="settings-appLanguageTitle">App Language</h4>
                <div class="settings-control">
                  <label for="appLanguageSelect">App Language:</label>
                  <select id="appLanguageSelect"></select>
                </div>
              </div>
              <div class="settings-section settings-section--pad-top">
                <h4 id="settings-overlayShortcutTitle">Overlay Shortcut</h4>
                <div class="settings-control">
                  <label for="overlay-shortcut-btn" style="margin-top: -10px"
                    >Shortcut Key:</label
                  >
                  <button id="overlay-shortcut-btn" type="button">
                    Set Shortcut
                  </button>
                </div>
                <div class="settings-section">
                  <div class="settings-control">
                    <label
                      for="overlay-interact-shortcut-btn"
                      style="margin-top: -10px"
                      >Interact Key:
                      <span
                        id="overlay-interact-shortcut-info"
                        class="info-dot"
                        title="Toggle interaction: press once to enable drag/scroll, press again to return to click-through."
                        aria-label="Toggle interaction: press once to enable drag/scroll, press again to return to click-through."
                        >i</span
                      ></label
                    >
                    <button id="overlay-interact-shortcut-btn" type="button">
                      \
                    </button>
                  </div>
                </div>
              </div>
              <div class="settings-section">
                <h4 id="settings-hiddenAchievementsTitle">
                  Hidden Achievements
                </h4>
                <div class="checkbox-control">
                  <input type="checkbox" id="settings-showHiddenDescription" />
                  <label for="settings-showHiddenDescription">
                    Show Hidden Description
                  </label>
                </div>
              </div>
              <div class="settings-section">
                <h4 id="settings-startupTitle">Startup</h4>
                <div class="checkbox-control">
                  <input type="checkbox" id="settings-startWindowsCheckbox" />
                  <label for="settings-startWindowsCheckbox"
                    >Start with Windows (Run as admin to enable)</label
                  >
                </div>
                <div class="checkbox-control">
                  <input type="checkbox" id="settings-startMaximizedCheckbox" />
                  <label for="settings-startMaximizedCheckbox"
                    >Start maximized</label
                  >
                </div>
                <div class="checkbox-control">
                  <input type="checkbox" id="settings-startInTrayCheckbox" />
                  <label for="settings-startInTrayCheckbox"
                    >Start in tray</label
                  >
                </div>
                <div class="checkbox-control">
                  <input type="checkbox" id="settings-closeToTrayCheckbox" />
                  <label for="settings-closeToTrayCheckbox"
                    >Close to tray</label
                  >
                </div>
                <div class="checkbox-control">
                  <input
                    type="checkbox"
                    id="settings-showDashboardOnStartCheckbox"
                  />
                  <label for="settings-showDashboardOnStartCheckbox"
                    >Show Dashboard</label
                  >
                </div>
              </div>
              <div class="settings-section" style="margin-bottom: 5px">
                <h4 id="settings-screenshotsTitle">Achievements Screenshots</h4>
                <div class="settings-control">
                  <div class="input-with-button">
                    <label for="settings-screenshotFolder"
                      >Save to folder:</label
                    >
                    <input
                      type="text"
                      id="settings-screenshotFolder"
                      placeholder="Default folder: Pictures\Achievements Screenshots"
                      readonly
                    />
                    <button
                      type="button"
                      id="settings-selectScreenshotFolder"
                      aria-label="Choose folder"
                    >
                      üìÇ
                    </button>
                  </div>
                </div>
                <div
                  class="checkbox-control"
                  style="margin-top: -10px; margin-bottom: 5px"
                >
                  <input
                    type="checkbox"
                    id="settings-disableScreenshotCheckbox"
                  />
                  <label for="settings-disableScreenshotCheckbox"
                    >Disable Screenshot</label
                  >
                </div>
              </div>
            </div>
          </div>

          <div
            id="notificationTab"
            class="tab-content"
            role="tabpanel"
            aria-labelledby="tab-notification"
            hidden
          >
            <div style="padding: 0 10px">
              <div class="settings-section">
                <h4 id="settings-testingTitle">Achievement Testing</h4>
                <button
                  id="settings-testAchievementBtn"
                  class="settings-test-button"
                  style="width: 100%; margin: 10px 0; padding: 10px"
                >
                  Test Achievement
                </button>

                <div class="checkbox-control">
                  <input
                    type="checkbox"
                    id="settings-disableProgressCheckbox"
                  />
                  <label for="settings-disableProgressCheckbox"
                    >Disable Global Progress Notification</label
                  >
                </div>

                <div class="checkbox-control">
                  <input
                    type="checkbox"
                    id="settings-disablePlaytimeCheckbox"
                  />
                  <label for="settings-disablePlaytimeCheckbox"
                    >Disable Playtime Notification</label
                  >
                </div>

                <div class="checkbox-control">
                  <input
                    type="checkbox"
                    id="settings-disablePlatinumCheckbox"
                  />
                  <label for="settings-disablePlatinumCheckbox"
                    >Disable Platinum Notification</label
                  >
                </div>

                <div class="settings-slider">
                  <label for="settings-scaleSlider"
                    >Achievement Scale:
                    <span id="settings-scaleValue">1.0</span></label
                  >
                  <div class="slider-control">
                    <input
                      type="range"
                      id="settings-scaleSlider"
                      min="0.01"
                      max="2.0"
                      step="0.01"
                      value="1.0"
                    />
                    <span class="value" id="settings-scaleValueDisplay"
                      >100%</span
                    >
                  </div>
                </div>

                <div class="settings-slider">
                  <label for="settings-durationSlider"
                    >Achievement Duration:
                    <span id="settings-durationValue">Auto</span></label
                  >
                  <div class="slider-control">
                    <input
                      type="range"
                      id="settings-durationSlider"
                      min="0"
                      max="10"
                      step="0.5"
                      value="0"
                    />
                    <span class="value" id="settings-durationValueDisplay"
                      >Auto</span
                    >
                  </div>
                </div>
                <div class="settings-slider">
                  <label for="settings-soundVolumeSlider"
                    >Achievement Sound Volume:
                    <span id="settings-soundVolumeValue">100%</span>
                    <span
                      id="settings-soundVolumeInfo"
                      class="info-dot"
                      title=">100% may distort"
                      aria-label=">100% may distort"
                      >i</span
                    ></label
                  >
                  <div class="slider-control">
                    <input
                      type="range"
                      id="settings-soundVolumeSlider"
                      min="0"
                      max="200"
                      step="1"
                      value="100"
                    />
                    <span class="value" id="settings-soundVolumeValueDisplay"
                      >100%</span
                    >
                  </div>
                </div>

                <div class="settings-control">
                  <label for="settings-positionDropdown"
                    >Achievement Position:</label
                  >
                  <select id="settings-positionDropdown">
                    <option value="center-bottom">Center Bottom</option>
                    <option value="center-top">Center Top</option>
                    <option value="top-right">Top Right</option>
                    <option value="bottom-right">Bottom Right</option>
                    <option value="top-left">Top Left</option>
                    <option value="bottom-left">Bottom Left</option>
                  </select>
                </div>

                <div class="settings-control">
                  <label for="settings-presetDropdown"
                    >Achievement Presets:</label
                  >
                  <select id="settings-presetDropdown"></select>
                </div>

                <div class="settings-control">
                  <label for="settings-soundSelect">Achievement Sound:</label>
                  <select id="settings-soundSelect"></select>
                </div>

                <hr />
                <h4 id="settings-platinumTitle" style="margin-top: 10px">
                  Platinum Notification
                </h4>
                <div class="settings-control">
                  <label for="settings-platinumPositionDropdown"
                    >Platinum Achievement Position:</label
                  >
                  <select id="settings-platinumPositionDropdown">
                    <option value="center-bottom">Center Bottom</option>
                    <option value="center-top">Center Top</option>
                    <option value="top-right">Top Right</option>
                    <option value="bottom-right">Bottom Right</option>
                    <option value="top-left">Top Left</option>
                    <option value="bottom-left">Bottom Left</option>
                  </select>
                </div>

                <div class="settings-control">
                  <label for="settings-platinumPresetDropdown"
                    >Platinum Achievement Presets:</label
                  >
                  <select id="settings-platinumPresetDropdown"></select>
                </div>

                <div class="settings-control">
                  <label for="settings-platinumSoundSelect"
                    >Platinum Achievement Sound:</label
                  >
                  <select id="settings-platinumSoundSelect"></select>
                </div>
              </div>
            </div>
          </div>
          <div
            id="foldersTab"
            class="tab-content"
            role="tabpanel"
            aria-labelledby="tab-folders"
            hidden
          >
            <div style="padding: 0 10px">
              <div class="settings-section">
                <h4 id="settings-foldersTitle">
                  Folders (auto-detect achievements)
                </h4>
                <div
                  class="settings-control"
                  style="display: flex; gap: 8px; flex-wrap: wrap"
                >
                  <button id="foldersAddBtn" type="button">Add Folder‚Ä¶</button>
                  <button id="foldersRescanBtn" type="button">Rescan</button>
                </div>
                <div class="checkbox-control" style="margin-top: -25px">
                  <input
                    type="checkbox"
                    id="settings-enableLumaPlayWatcherCheckbox"
                  />
                  <label for="settings-enableLumaPlayWatcherCheckbox">
                    Enable LumaPlay Watcher
                  </label>
                </div>
                <div id="foldersList" style="margin-top: 2px"></div>
              </div>
            </div>
          </div>
          <div
            id="advancedTab"
            class="tab-content"
            role="tabpanel"
            aria-labelledby="tab-advanced"
            hidden
          >
            <div style="padding: 0 10px">
              <div class="settings-section">
                <div class="settings-section" style="margin-bottom: 5px">
                  <h4 id="settings-steamApiTitle">Steam Web API</h4>
                  <div class="settings-control">
                    <input
                      type="password"
                      id="settings-steamApiKeyInput"
                      placeholder="No key saved. Enter your Steam Web API key"
                      autocomplete="off"
                    />
                  </div>
                  <div class="settings-control" style="gap: 8px">
                    <button type="button" id="settings-steamApiKeySave">
                      Save
                    </button>
                    <button type="button" id="settings-steamApiKeyClear">
                      Remove
                    </button>
                  </div>
                </div>
                <div class="settings-section">
                  <h4 id="settings-blacklistTitle">Blacklist</h4>
                  <div class="checkbox-control">
                    <input
                      type="checkbox"
                      id="settings-showBlacklistedCheckbox"
                    />
                    <label for="settings-showBlacklistedCheckbox">
                      Show blacklisted games
                    </label>
                  </div>
                  <div
                    id="blacklistList"
                    class="wf-list"
                    role="list"
                    aria-label="Blacklisted AppIDs"
                    style="margin-top: 8px"
                  ></div>
                  <div class="settings-control" style="gap: 8px">
                    <button type="button" id="settings-resetBlacklistBtn">
                      Reset Blacklist
                    </button>
                  </div>
                </div>
                <div class="settings-section">
                  <h4 id="settings-renderingTitle">Rendering</h4>
                  <div class="checkbox-control">
                    <input
                      type="checkbox"
                      id="settings-disableHardwareAccelerationCheckbox"
                    />
                    <label for="settings-disableHardwareAccelerationCheckbox">
                      Disable Hardware Acceleration
                      <span class="hint">(restart required)</span>
                    </label>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div
            id="shortcutsTab"
            class="tab-content"
            role="tabpanel"
            aria-labelledby="tab-shortcuts"
            hidden
            data-lazy="shortcuts"
            tabindex="0"
          >
            <template id="shortcutsTabTemplate">
              <div style="padding: 0 10px">
                <!-- Global -->
                <div class="settings-section">
                  <h4 id="settings-globalTitle">Global</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Settings</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>F1</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>O</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-view">View</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-share">Share</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Dashboard</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>F2</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>D</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox:
                            <span class="btn xb-Xboxbtn"
                              >Xbox Button</span
                            ></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps">
                            PlayStation:
                            <span class="btn ps-touchpad">Touchpad</span> |
                            <span class="btn ps-ps">PS</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">
                        Show/Hide Options panel (on Dashboard)
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          <kbd>‚â£ (Context Menu)</kbd>
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Shift</kbd>+<kbd>F10</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-y">Y</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-triangle">‚É§‚É§</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">
                        Show/Hide Options panel (on Main)
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>F3</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-x">X</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-square">‚òê</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Back / Close</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>Esc</kbd></div>
                        <div class="ctl-line sub"><kbd>Backspace</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-b">B</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-circle">‚óØ</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Play (launch)</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>P</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Enter</kbd>
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Shift</kbd>+<kbd>Enter</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-menu">Menu</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-options">Options</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Confirm / Activate</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>Enter</kbd></div>
                        <div class="ctl-line sub"><kbd>Space</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-a">A</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-cross">‚úï</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Page scroll</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>PageUp</kbd></div>
                        <div class="ctl-line sub"><kbd>PageDown</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            ><span class="btn stick">RS</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Move</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">Arrow Keys</div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">D-pad</div>
                        <div class="ctl-line sub">
                          <span class="btn stick">LS</span>
                        </div>
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Overlay -->
                <div class="settings-section">
                  <h4 id="settings-overlayControlsTitle">Overlay</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Show / Hide Overlay</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          Configurable in Settings: Overlay Shortcut
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Toggle Interaction Mode</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          Interact Key from Settings (default <kbd>\</kbd>)
                        </div>
                      </div>
                      <div class="ctl-line sub">
                        Switches click-through ‚Üî interactive (drag/scroll)
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Overlay Page Scroll</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>PageUp</kbd></div>
                        <div class="ctl-line sub"><kbd>PageDown</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>PageUp</kbd>
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>PageDown</kbd>
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Snap 5 Positions</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd
                            >1</kbd
                          >
                          (Top-Left)
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd
                            >2</kbd
                          >
                          (Top-Right)
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd
                            >3</kbd
                          >
                          (Center)
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd
                            >4</kbd
                          >
                          (Bottom-Left)
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd
                            >5</kbd
                          >
                          (Bottom-Right)
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Snap Grid / Cycle / Nudge</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+<kbd
                            >M</kbd
                          >
                          (cycle presets)
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Shift</kbd>+Arrow
                          (nudge 20px)
                        </div>
                      </div>
                      <div class="ctl-line sub">
                        Active only while the overlay is shown
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Dashboard -->
                <div class="settings-section">
                  <h4 id="settings-dashboardTitle">Dashboard</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Grid navigation</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">Arrows</div>
                        <div class="ctl-line sub"><kbd>Home</kbd></div>
                        <div class="ctl-line sub"><kbd>End</kbd></div>
                        <div class="ctl-line sub"><kbd>PageUp</kbd></div>
                        <div class="ctl-line sub"><kbd>PageDown</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">D-pad</div>
                        <div class="ctl-line sub">
                          <span class="btn stick">LS</span>
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Search</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>F</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-x">X</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-square">‚òê</span></span
                          >
                        </div>
                      </div>
                      <div class="ctl-line sub">
                        In search:
                        <div class="ctl-line sub">
                          <kbd>Enter</kbd> |
                          <span class="btn ps-cross">‚úï</span> |
                          <span class="btn xb-a">A</span> opens first visible
                          card
                        </div>
                        <div class="ctl-line sub">
                          <kbd>‚Üì</kbd> moves focus to first card
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Esc</kbd> | <span class="btn xb-b">B</span> |
                          <span class="btn ps-circle">‚óØ</span>
                          close Dashboard
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Open game (select card)</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>Enter</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-a">A</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-cross">‚úï</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Play from card</div>
                      <div class="ctl-line">
                        <span class="hint">Mouse:</span>
                        <div class="ctl-line sub">Click Play</div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>P</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Enter</kbd>
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Shift</kbd>+<kbd>Enter</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-menu">Menu</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-options">Options</span></span
                          >
                        </div>
                      </div>
                      <div class="ctl-line sub">
                        <span class="hint">(if executable)</span>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Sort cycles</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          By Name ‚Äî <kbd>Alt</kbd>+<kbd>1</kbd>
                        </div>
                        <div class="ctl-line sub">
                          By Progress ‚Äî <kbd>Alt</kbd>+<kbd>2</kbd>
                        </div>
                        <div class="ctl-line sub">
                          By Last Updated ‚Äî <kbd>Alt</kbd>+<kbd>3</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn stick">L3</span>,
                            <span class="btn shoulder">RB</span>,
                            <span class="btn shoulder">LB</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation: <span class="btn stick">L3</span>,
                            <span class="btn shoulder">R1</span>,
                            <span class="btn shoulder">L1</span></span
                          >
                        </div>
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Settings panel -->
                <div class="settings-section">
                  <h4 id="settings-panelTitle">Settings panel</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Open/Close</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>F1</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>O</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-view">View</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-share">Share</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Tabs mode</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">‚Üë/‚Üì move</div>
                        <div class="ctl-line sub"><kbd>Enter</kbd> select</div>
                        <div class="ctl-line sub"><kbd>Esc</kbd> close</div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          D-pad / <span class="btn stick">RS</span> move
                        </div>
                        <div class="ctl-line sub">
                          <span class="btn xb-a">A</span>/<span
                            class="btn ps-cross"
                            >‚úï</span
                          >
                          select
                        </div>
                        <div class="ctl-line sub">
                          <span class="btn xb-b">B</span>/<span
                            class="btn ps-circle"
                            >‚óØ</span
                          >
                          close
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Section mode</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">‚Üë/‚Üì focus</div>
                        <div class="ctl-line sub">‚Üê/‚Üí adjust</div>
                        <div class="ctl-line sub">
                          <kbd>Enter</kbd> activate
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Esc</kbd> back to Tabs
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          D-pad / <span class="btn stick">LS</span> focus
                        </div>
                        <div class="ctl-line sub">
                          <span class="btn xb-a">A</span>/<span
                            class="btn ps-cross"
                            >‚úï</span
                          >
                          activate
                        </div>
                        <div class="ctl-line sub">
                          <span class="btn xb-b">B</span>/<span
                            class="btn ps-circle"
                            >‚óØ</span
                          >
                          back
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Cycle tabs</div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            ><span class="btn shoulder">LB</span>/<span
                              class="btn shoulder"
                              >RB</span
                            ></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            ><span class="btn shoulder">L1</span>/<span
                              class="btn shoulder"
                              >R1</span
                            ></span
                          >
                        </div>
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Main screen -->
                <div class="settings-section">
                  <h4 id="settings-mainScreenTitle">Main screen</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Toggle Options</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>F3</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-x">X</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-square">‚òê</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Create New Config</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>N</kbd>
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Move</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">‚Üë/‚Üì</div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">D-pad</div>
                        <div class="ctl-line sub">
                          <span class="btn stick">LS</span>
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Play</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>P</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Enter</kbd>
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Shift</kbd>+<kbd>Enter</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-menu">Menu</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-options">Options</span></span
                          >
                        </div>
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Drop-downs -->
                <div class="settings-section">
                  <h4 id="settings-dropdownsTitle">Drop-downs</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Open</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>Enter</kbd></div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">While open</div>

                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">‚Üë/‚Üì/‚Üê/‚Üí navigate</div>
                        <div class="ctl-line sub"><kbd>Enter</kbd> confirm</div>
                        <div class="ctl-line sub">
                          <kbd>Esc</kbd>/<kbd>Backspace</kbd> cancel
                        </div>
                      </div>

                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">D-pad navigate</div>
                        <div class="ctl-line sub">
                          <span class="btn xb-a">A</span>/<span
                            class="btn ps-cross"
                            >‚úï</span
                          >
                          confirm
                        </div>
                        <div class="ctl-line sub">
                          <span class="btn xb-b">B</span>/<span
                            class="btn ps-circle"
                            >‚óØ</span
                          >
                          cancel
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">While closed</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">‚Üê/‚Üí cycles options</div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">D-pad Left/Right</div>
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Notes -->
                <div class="settings-section">
                  <h4 id="settings-notesTitle">Notes</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label" id="notesRightStickTitle">
                        Right Stick scrolling
                      </div>
                      <div class="ctl-line">
                        <div class="ctl-line sub">
                          <span id="notesRightStickDesc">
                            Smooth scrolling in the active scrollable area.
                          </span>
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label" id="notesBackContextTitle">
                        Back is contextual
                      </div>
                      <div class="ctl-line sub">
                        <div class="ctl-line sub" id="notesBackSettingsSection">
                          Settings Section ‚Üí Tabs
                        </div>
                        <div class="ctl-line sub" id="notesBackSettingsTabs">
                          Settings Tabs ‚Üí Close
                        </div>
                        <div class="ctl-line sub" id="notesBackDashboard">
                          Dashboard ‚Üí Close
                        </div>
                        <div class="ctl-line sub" id="notesBackConfigModal">
                          Config modal ‚Üí Close
                        </div>
                        <div class="ctl-line sub">
                          <span id="notesBackMainSelected">
                            Main with a selected config ‚Üí Clear selection/back
                          </span>
                        </div>
                      </div>
                    </li>
                  </ul>
                </div>
              </div>
            </template>
          </div>
          <div
            id="platformGuideTab"
            class="tab-content"
            role="tabpanel"
            aria-labelledby="tab-platformGuide"
            hidden
            tabindex="0"
          >
            <div style="padding: 0 10px">
              <div class="settings-section">
                <h4 id="platformGuideTitle">Platform & Emulator Guide</h4>
                <p id="platformGuideIntro" class="platform-guide-note">
                  This guide explains what to watch, how auto-config starts, and
                  when notifications are generated for each platform.
                </p>
                <ul class="platform-guide-list">
                  <li id="platformGuideQuickTip1">
                    Add root folders in <strong>Settings ‚Üí Folders</strong>.
                  </li>
                  <li id="platformGuideQuickTip2">
                    Auto-config runs only for watched folders that are not
                    muted/ignored.
                  </li>
                  <li id="platformGuideQuickTip3">
                    Notifications are sent only on new unlock/progress changes,
                    not for already imported old unlocks.
                  </li>
                </ul>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item" open>
                  <summary id="platformGuideSteamSummary">
                    Steam / Epic / GOG / Uplay
                  </summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideSteamItem1">
                      Core flow: watch save/achievement files (for example
                      <code>achievements.json</code>,
                      <code>achievements.ini</code>, <code>stats.bin</code>,
                      <code>user_stats.ini</code>) inside configured roots.
                    </li>
                    <li id="platformGuideSteamItem2">
                      Manual config: set a valid <code>AppID</code> and correct
                      <code>Save path</code>.
                    </li>
                    <li id="platformGuideSteamItem3">
                      Uplay note: if Steam mapping is needed, use the mapped
                      Steam AppID field when available.
                    </li>
                    <li id="platformGuideSteamItem4">
                      Epic emu method (Nemirtingas): if
                      <code>NemirtingasEpicEmu</code> is used, the scanner
                      discovers numeric AppIDs from user subfolders and treats
                      them as Epic candidates.
                    </li>
                    <li id="platformGuideSteamItem5">
                      GOG method 1 (preferred): detect
                      <code>goggame-*.info</code> files and read game IDs from
                      those files.
                    </li>
                    <li id="platformGuideSteamItem6">
                      GOG method 2 (fallback): detect
                      <code>UniverseLAN.ini</code> and read
                      <code>GameSettings.AppID</code>; runtime progress is
                      monitored from
                      <code>UniverseLANData\\Achievements.ini</code>.
                    </li>
                    <li id="platformGuideSteamItem7">
                      TENOKE method: detect <code>tenoke.ini</code> and read
                      <code>id=APPID</code>.
                    </li>
                    <li id="platformGuideSteamItem8">
                      TENOKE runtime: after config creation, watcher searches
                      deeper for <code>user_stats.ini</code> (including
                      <code>SteamData\\user_stats.ini</code>), updates
                      <code>save_path</code>, and relinks automatically.
                    </li>
                    <li id="platformGuideSteamItem9">
                      GOG can also run with manual config using a valid
                      <code>AppID</code> and <code>Platform = GOG</code>, even
                      without <code>.info</code> or
                      <code>UniverseLAN.ini</code>.
                    </li>
                    <li id="platformGuideSteamItem10">
                      If only numeric folders are present, auto mode may
                      classify by heuristics; for strict GOG behavior, keep
                      <code>goggame-*.info</code>/<code>UniverseLAN.ini</code>
                      or set platform manually.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideSteamOfficialSummary">
                    Steam (Official)
                  </summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideSteamOfficialItem1">
                      Watch folder:
                      <code>Steam\appcache\stats</code>.
                    </li>
                    <li id="platformGuideSteamOfficialItem2">
                      Detection is based on
                      <code>UserGameStatsSchema_*.bin</code> files.
                    </li>
                    <li id="platformGuideSteamOfficialItem3">
                      If schema/progress seems outdated, use folder rescan
                      instead of manual schema regeneration.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideXeniaSummary">Xenia</summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideXeniaItem1">
                      Watch the Xenia content/profile path where
                      <code>.gpd</code> files are updated.
                    </li>
                    <li id="platformGuideXeniaItem2">
                      Auto-config reads title data, generates schema/images, and
                      starts notification flow from those files.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideRpcs3Summary">RPCS3</summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideRpcs3Item1">
                      Watch trophy root:
                      <code>dev_hdd0\home\&lt;user&gt;\trophy</code>.
                    </li>
                    <li id="platformGuideRpcs3Item2">
                      Runtime updates are detected from
                      <code>TROPUSR.DAT</code> and <code>TROPCONF.SFM</code>.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideShadps4Summary">
                    PS4 (shadPS4)
                  </summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideShadps4Item1">
                      Watch folder:
                      <code>%APPDATA%\shadPS4\game_data</code>.
                    </li>
                    <li id="platformGuideShadps4Item2">
                      Trophy discovery and schema generation are based on PS4
                      trophy files (for example <code>TROP.XML</code>).
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideLumaSummary">LumaPlay</summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideLumaItem1">
                      Enable
                      <strong
                        >Settings ‚Üí Folders ‚Üí Enable LumaPlay Watcher</strong
                      >.
                    </li>
                    <li id="platformGuideLumaItem2">
                      Windows only: the app listens for realtime registry events
                      under <code>HKCU\SOFTWARE\LumaPlay</code>.
                    </li>
                    <li id="platformGuideLumaItem3">
                      The watcher starts only when enabled; if disabled, no
                      LumaPlay registry watcher process is started.
                    </li>
                    <li id="platformGuideLumaItem4">
                      LumaPlay configs are expected as
                      <code>platform=uplay</code> and <code>emu=lumaplay</code>.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideConfigRulesSummary">
                    AppID and config rules
                  </summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideConfigRulesItem1">
                      Steam/Uplay/GOG/Steam Official use regular app IDs; Epic
                      may use numeric or hex-like IDs.
                    </li>
                    <li id="platformGuideConfigRulesItem2">
                      Xenia title IDs are hex and can be provided with or
                      without the 0x prefix.
                    </li>
                    <li id="platformGuideConfigRulesItem3">
                      RPCS3 expects trophy-set IDs in NP* format (example:
                      NPWR12345_00).
                    </li>
                    <li id="platformGuideConfigRulesItem4">
                      shadPS4 expects CUSA IDs (example: CUSA12345).
                    </li>
                    <li id="platformGuideConfigRulesItem5">
                      LumaPlay config detection requires platform=uplay and
                      emu=lumaplay.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideRescanSummary">
                    Rescan vs Regenerate Schema
                  </summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideRescanItem1">
                      Regenerate Schema is used for Steam/Uplay/Epic/GOG schema
                      refresh.
                    </li>
                    <li id="platformGuideRescanItem2">
                      For Xenia, RPCS3, shadPS4 and Steam Official, schema
                      regenerate is blocked by design.
                    </li>
                    <li id="platformGuideRescanItem3">
                      For those platforms/emulators, use Folders ‚Üí Rescan to
                      rebuild from source files.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideOnboardingSummary">
                    Boot onboarding and startup gate
                  </summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideOnboardingItem1">
                      On first run (or onboarding version change), startup waits
                      for folder selection before full scanning.
                    </li>
                    <li id="platformGuideOnboardingItem2">
                      While onboarding is pending, folder watchers are deferred
                      to avoid unwanted auto-config activity.
                    </li>
                    <li id="platformGuideOnboardingItem3">
                      Reminder messages are emitted periodically (about every
                      20s by default) until a decision is made.
                    </li>
                    <li id="platformGuideOnboardingItem4">
                      Tray action Resume Startup applies skip-all and mutes all
                      discovered folders for auto-config.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideStateFiltersSummary">
                    Filters and notification toggles
                  </summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideStateFiltersItem1">
                      Ignored folders are stored as blocked watched folders and
                      are not scanned.
                    </li>
                    <li id="platformGuideStateFiltersItem2">
                      Blacklisted AppIDs are skipped by auto-config and blocked
                      for schema operations.
                    </li>
                    <li id="platformGuideStateFiltersItem3">
                      Disable Global Progress and per-game progress mute affect
                      progress notifications only.
                    </li>
                    <li id="platformGuideStateFiltersItem4">
                      Disable Playtime and Disable Platinum control only their
                      dedicated notification types.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideRecoverySummary">
                    Recovery and temp data
                  </summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideRecoveryItem1">
                      Missing watched folders are rechecked periodically (around
                      4 seconds).
                    </li>
                    <li id="platformGuideRecoveryItem2">
                      When a missing folder reappears, watcher attach and
                      follow-up scan are retried automatically.
                    </li>
                    <li id="platformGuideRecoveryItem3">
                      Temporary single-root auto-config folders in OS Temp are
                      cleaned automatically after generation.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideLogsSummary">
                    Useful log tags
                  </summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideLogsItem1">
                      Watchers: watch-save, watch-save-strict-root,
                      watch-lumaplay.
                    </li>
                    <li id="platformGuideLogsItem2">
                      Startup flow: boot:onboarding:*.
                    </li>
                    <li id="platformGuideLogsItem3">
                      Initial snapshot evaluation: initial-notify:*.
                    </li>
                    <li id="platformGuideLogsItem4">
                      Auto selection flow: auto-select:*.
                    </li>
                    <li id="platformGuideLogsItem5">
                      Steam Official handling: steam-official:*.
                    </li>
                  </ul>
                </details>
              </div>

              <div class="settings-section">
                <details class="platform-guide-item">
                  <summary id="platformGuideTroubleshootingSummary">
                    Quick troubleshooting
                  </summary>
                  <ul class="platform-guide-list">
                    <li id="platformGuideTroubleshootingItem1">
                      Check that the game is not blacklisted and progress
                      notifications are not muted globally/per-config.
                    </li>
                    <li id="platformGuideTroubleshootingItem2">
                      Verify watched folder paths and confirm the save/trophy
                      files actually change while playing.
                    </li>
                    <li id="platformGuideTroubleshootingItem3">
                      After moving saves or emulator directories, run
                      <strong>Rescan</strong> in Folders.
                    </li>
                    <li id="platformGuideTroubleshootingItem4">
                      Match privilege level between app and game
                      (non-admin/non-admin or admin/admin) for reliable
                      overlay shortcuts.
                    </li>
                    <li id="platformGuideTroubleshootingItem5">
                      If overlay hotkeys are blocked in a game, switch to a
                      3-key combination and avoid commonly intercepted keys.
                    </li>
                    <li id="platformGuideTroubleshootingItem6">
                      In elevated/protected game contexts, drag may fail; use
                      snap positions (Ctrl+Alt+Shift+1..5) or nudge mode
                      (Ctrl+Alt+Shift+Arrow Keys).
                    </li>
                    <li id="platformGuideTroubleshootingItem7">
                      If PageUp/PageDown does not work in overlay, use the
                      fallback Ctrl+PageUp / Ctrl+PageDown.
                    </li>
                    <li id="platformGuideTroubleshootingItem8">
                      If sound plays but notifications appear late, lower
                      preset cost (blur/shadows/large transforms) and reduce
                      notification duration.
                    </li>
                  </ul>
                </details>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div
      id="mainScroll"
      class="scroll-container"
      data-scroll-container="1"
      tabindex="0"
    >
      <div class="container">
        <!-- Toggle Settings Button -->
        <div
          id="mainControlsRow"
          style="
            margin-bottom: 10px;
            position: relative;
            display: flex;
            align-items: center;
            gap: 10px;
          "
        >
          <div style="display: flex; flex-direction: column; gap: 0px">
            <button id="toggleDashboardBtn" type="button">
              Show Dashboard
            </button>
            <button id="toggleBtn">Hide Options</button>
          </div>

          <!-- Progres bar -->
          <div
            id="achStats"
            style="
              display: none;
              position: absolute;
              left: 50%;
              top: 30px;
              transform: translate(-50%, -30px);
              text-align: center;
              width: 320px;
              z-index: 10;
            "
          >
            <label id="achStatsText" style="color: white; font-weight: bold"
              >Progress: 0 / 0</label
            >
            <div
              style="
                width: 100%;
                background: #ccc;
                border-radius: 8px;
                height: 12px;
                margin-top: -10px;
                position: relative;
                margin-bottom: 0px;
              "
            >
              <div
                id="achStatsBar"
                style="
                  width: 0%;
                  height: 100%;
                  background: #4caf50;
                  border-radius: 8px;
                  transition: width 0.3s;
                "
              ></div>
              <span
                id="achStatsPercent"
                style="
                  position: absolute;
                  right: 5px;
                  top: -22px;
                  font-size: 12px;
                  color: white;
                  font-weight: bold;
                "
                >0%</span
              >
            </div>
            <div
              id="achStatsPlaytime"
              style="
                margin-top: 6px;
                font-size: 12px;
                color: #ffffff;
                font-weight: bold;
              "
            >
              Playtime: 0m
            </div>
            <div
              id="achStatsLastPlayed"
              style="
                margin-top: 2px;
                font-size: 12px;
                color: #ffffff;
                font-weight: bold;
              "
            >
              Last Played: N/A
            </div>
          </div>

          <button id="playBtn" style="display: none; margin-left: auto">
            <i class="fas fa-play fa-icon" aria-hidden="true"></i>
            <span class="fa-fallback" aria-hidden="true">‚ñ∂</span>
            Play
          </button>
        </div>

        <!-- Toggleable Settings Container -->
        <div
          id="buttonContainer"
          class="config-container"
          style="display: flex; justify-content: space-between; gap: 15px"
        >
          <!-- Left Side: Create Config and Select Config -->
          <div
            class="left-config"
            style="
              flex: 1;
              min-width: 300px;
              display: flex;
              flex-direction: column;
              gap: 5px;
            "
          >
            <div>
              <div style="display: flex; gap: 20px">
                <button id="createNewConfigBtn" style="flex: 1; padding: 10px">
                  Create New Config <span class="arrow-icon">‚ñº</span>
                </button>

                <button
                  id="generateConfigsBtn"
                  style="flex: 1; padding: 10px; display: none"
                >
                  Generate Auto-Configs
                </button>
              </div>

              <div id="configModal" class="modal hidden">
                <div class="modal-content">
                  <span class="close-button" id="closeConfigModal"
                    >&times;</span
                  >
                  <h2 id="configFormTitle" style="margin-top: 0">
                    Config Form
                  </h2>

                  <div
                    id="new-config-form"
                    style="
                      display: flex;
                      flex-direction: column;
                      gap: 14px;
                      margin-top: -10px;
                    "
                  >
                    <div style="display: flex; gap: 20px">
                      <!-- Right -->
                      <div
                        style="flex: 1; display: flex; flex-direction: column"
                      >
                        <label for="configName">Config Name:</label>
                        <input
                          type="text"
                          id="configName"
                          placeholder="Enter Config Name *"
                        />

                        <label for="appid">AppID:</label>
                        <input
                          type="text"
                          id="appid"
                          placeholder="Enter AppID *"
                        />

                        <label for="configPath"
                          >Config path: ! Leave empty to generate !</label
                        >
                        <div class="input-with-button">
                          <input
                            type="text"
                            id="configPath"
                            placeholder="Example: steam_settings"
                          />
                          <button type="button" id="selectConfigFolder">
                            üìÇ
                          </button>
                        </div>

                        <label for="savePath">Save path:</label>
                        <div class="input-with-button">
                          <input
                            type="text"
                            id="savePath"
                            placeholder="Example: GSE Saves "
                          />
                          <button type="button" id="selectSaveFolder">
                            üìÇ
                          </button>
                        </div>
                      </div>

                      <!-- Left -->
                      <div
                        style="flex: 1; display: flex; flex-direction: column"
                      >
                        <label for="executablePath"
                          >Executable (optional):</label
                        >
                        <div class="input-with-button">
                          <input
                            type="text"
                            id="executablePath"
                            placeholder="Path to executable"
                          />
                          <button type="button" id="selectExecutable">
                            üìÇ
                          </button>
                        </div>

                        <label for="exeArgs">Arguments (optional):</label>
                        <input
                          type="text"
                          id="exeArgs"
                          placeholder="Optional arguments"
                        />

                        <label for="processName"
                          >Process name (optional):</label
                        >
                        <input
                          type="text"
                          id="processName"
                          placeholder="Optional ‚Äì real .exe name"
                        />
                        <label for="platformSelect">Platform:</label>
                        <select id="platformSelect">
                          <option value="auto" selected>Auto</option>
                          <option value="steam">Steam</option>
                          <option value="steam-official" disabled>
                            Steam (Official)
                          </option>
                          <option value="uplay">Uplay</option>
                          <option value="epic">Epic</option>
                          <option value="gog">GOG</option>
                          <option value="xenia" disabled>Xenia</option>
                          <option value="rpcs3" disabled>RPCS3</option>
                          <option value="shadps4" disabled>
                            PS4 (shadps4)
                          </option>
                        </select>

                        <div
                          id="steamAppIdRow"
                          class="input-with-button"
                          style="display: none"
                        >
                          <input
                            type="text"
                            id="steamAppIdInput"
                            placeholder="Mapped Steam AppID"
                          />
                          <button type="button" id="lookupSteamIdBtn">
                            ??
                          </button>
                        </div>
                      </div>
                    </div>

                    <!-- Butoane Save / Regenerate -->
                    <div
                      style="
                        display: flex;
                        justify-content: center;
                        gap: 10px;
                        flex-wrap: wrap;
                        margin-top: 5px;
                      "
                    >
                      <button
                        id="saveBtn"
                        style="
                          background-color: #4caf50;
                          color: white;
                          border: none;
                          padding: 10px 24px;
                          border-radius: 6px;
                          font-weight: bold;
                          width: auto;
                        "
                      >
                        Save Config
                      </button>
                      <button
                        id="regenSchemaBtn"
                        style="
                          background-color: #2196f3;
                          color: white;
                          border: none;
                          padding: 10px 24px;
                          border-radius: 6px;
                          font-weight: bold;
                          width: auto;
                          display: none;
                        "
                      >
                        Regenerate Schema
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <div class="config-controls clean">
              <label for="configList" class="field-label">Select Config:</label>
              <select id="configList" class="field-input">
                <option value="" disabled selected>Select</option>
              </select>
              <div
                id="muteProgressRow"
                class="checkbox-control"
                style="display: none; margin-left: 10px"
              >
                <input type="checkbox" id="muteProgressCheckbox" />
                <label for="muteProgressCheckbox"
                  >Disable Game Progress Notifications</label
                >
              </div>
              <button
                id="deleteConfigBtn"
                style="display: none; margin-top: 25px"
              >
                Delete
              </button>
              <button id="blacklistConfigBtn" style="display: none">
                Add to Blacklist
              </button>
              <div class="button-row">
                <button id="editConfigBtn" style="display: none">
                  Edit Config
                </button>
                <button id="backButton" class="hidden">Back</button>
              </div>
              <div class="language-controls">
                <label for="languageSelect" class="field-label"
                  >Select Language:</label
                >
                <select id="languageSelect" class="field-input">
                  <option value="english">English</option>
                  <option value="german">Deutsch (German)</option>
                  <option value="french">Fran√ßais (French)</option>
                  <option value="italian">Italiano (Italian)</option>
                  <option value="koreana">ÌïúÍµ≠Ïñ¥ (Korean)</option>
                  <option value="spanish">Espa√±ol (Spanish)</option>
                  <option value="thai">‡πÑ‡∏ó‡∏¢ (Thai)</option>
                  <option value="schinese">
                    ÁÆÄ‰Ωì‰∏≠Êñá (Chinese - Simplified)
                  </option>
                  <option value="tchinese">
                    ÁπÅÈ´î‰∏≠Êñá (Chinese - Traditional)
                  </option>
                  <option value="arabic">ÿßŸÑÿπÿ±ÿ®Ÿäÿ© (Arabic)</option>
                  <option value="russian">–†—É—Å—Å–∫–∏–π (Russian)</option>
                  <option value="japanese">Êó•Êú¨Ë™û (Japanese)</option>
                  <option value="portuguese">Portugu√™s (Portugal)</option>
                  <option value="danish">Dansk (Danish)</option>
                  <option value="dutch">Nederlands (Dutch)</option>
                  <option value="swedish">Svenska (Swedish)</option>
                  <option value="hungarian">Magyar (Hungarian)</option>
                  <option value="turkish">T√ºrk√ße (Turkish)</option>
                  <option value="polish">Polski (Polish)</option>
                  <option value="brazilian">Portugu√™s (Brasil)</option>
                  <option value="ukrainian">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞ (Ukrainian)</option>
                  <option value="vietnamese">Ti·∫øng Vi·ªát (Vietnamese)</option>
                  <option value="bulgarian">–ë—ä–ª–≥–∞—Ä—Å–∫–∏ (Bulgarian)</option>
                  <option value="czech">ƒåe≈°tina (Czech)</option>
                  <option value="finnish">Suomi (Finnish)</option>
                  <option value="greek">ŒïŒªŒªŒ∑ŒΩŒπŒ∫Œ¨ (Greek)</option>
                  <option value="indonesian">
                    Bahasa Indonesia (Indonesian)
                  </option>
                  <option value="norwegian">Norsk (Norwegian)</option>
                  <option value="romanian">Rom√¢nƒÉ (Romanian)</option>
                  <option value="latam">
                    Espa√±ol (Latinoam√©rica) (Spanish - Latin America)
                  </option>
                </select>
              </div>
            </div>
          </div>

          <!-- Right Side: Game Image (embedded) -->
          <div
            class="settings-container"
            style="
              flex: 1;
              min-width: 300px;
              display: flex;
              flex-direction: column;
              gap: 5px;
            "
          >
            <div id="embeddedGameImage" class="game-image-embed">
              <div id="embeddedImageContainer">
                <img id="embeddedGameImageImg" src="" alt="Game Cover" />
                <button
                  id="edit-btn"
                  type="button"
                  onclick="showAltAppIdPrompt()"
                  title="Edit image"
                  aria-label="Edit image"
                >
                  ‚úé
                </button>
              </div>

              <div
                id="embeddedFallbackPrompt"
                style="
                  display: none;
                  flex-direction: column;
                  align-items: center;
                  padding: 20px;
                  color: white;
                "
              >
                <p id="altAppIdPromptText">
                  ‚ö†Ô∏è Does the game have a different Steam AppID on Steam?
                </p>
                <input
                  type="text"
                  id="altAppId"
                  placeholder="Enter alternative AppID"
                  style="padding: 5px; font-size: 16px; width: 200px"
                />
                <div style="margin-top: 10px">
                  <button
                    id="altAppIdTryBtn"
                    type="button"
                    onclick="downloadFromAlternativeAppId()"
                  >
                    ‚úÖ Try Alternative
                  </button>
                  <button
                    id="altAppIdCancelBtn"
                    type="button"
                    onclick="cancelFallback()"
                    style="margin-left: 5px"
                  >
                    ‚úñ Cancel
                  </button>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div id="achievementsHeader" class="ach-header" style="display: none">
        <div id="achievementsSearch" class="ach-header-search">
          <button
            id="achievementsSearchToggle"
            class="ach-search-btn"
            type="button"
            title="Search achievements (Ctrl+F)"
            aria-label="Search achievements"
          >
            <i
              class="fa-solid fa-magnifying-glass fa-icon"
              aria-hidden="true"
            ></i>
            <span class="fa-fallback" aria-hidden="true">üîç</span>
          </button>
          <input
            id="achievementsSearchInput"
            class="ach-search-input"
            type="text"
            placeholder="Search achievements‚Ä¶"
            autocomplete="off"
            spellcheck="false"
          />
        </div>
      </div>
      <table class="achievements">
        <thead>
          <tr></tr>
        </thead>
        <tbody id="achievementsTableBody"></tbody>
      </table>
      <div style="height: 50px"></div>
    </div>

    <!-- Hidden elements to maintain compatibility with existing code -->
    <div style="display: none">
      <button id="testAchievementBtn">Test Achievement</button>
      <input type="checkbox" id="disableProgressCheckbox" />
      <input
        type="range"
        id="scaleSlider"
        min="0.01"
        max="2.0"
        step="0.01"
        value="1.0"
      />
      <span id="scaleValue">1.0</span>
      <select id="positionDropdown">
        <option value="center-bottom">Center Bottom</option>
        <option value="center-top">Center Top</option>
        <option value="top-right">Top Right</option>
        <option value="bottom-right">Bottom Right</option>
        <option value="top-left">Top Left</option>
        <option value="bottom-left">Bottom Left</option>
      </select>
      <select id="presetDropdown"></select>
      <select id="soundSelect"></select>
      <input type="hidden" id="platinumPresetValue" />
      <input type="hidden" id="platinumPositionValue" />
      <input type="hidden" id="platinumSoundValue" />
    </div>

    <!-- DASHBOARD -->
    <div id="dashboardOverlay" aria-hidden="true">
      <div
        id="dashboardPanel"
        role="dialog"
        aria-modal="true"
        aria-label="Games Dashboard"
      >
        <div id="dashboardHeader">
          <div id="dashboardStats" aria-live="polite">
            <span>
              <span id="dashboardGamesLabel">Games:</span>
              <strong id="gamesTotal">0</strong>
            </span>
            <span class="sep">‚Ä¢</span>
            <span>
              <span id="dashboardPerfectLabel">Perfect Games:</span>
              <strong id="perfectTotal">0</strong>
            </span>
          </div>

          <!-- SEARCH -->
          <div id="dashboardSearch">
            <input
              id="dashboardSearchInput"
              type="text"
              placeholder="Search games‚Ä¶"
              autocomplete="off"
              spellcheck="false"
            />
          </div>

          <!-- SORT CONTROL -->
          <div
            id="dashboardControls"
            style="
              margin-left: 12px;
              display: flex;
              align-items: center;
              gap: 8px;
            "
          >
            <div
              id="dashboardSortIcons"
              class="sort-icons"
              style="display: flex; gap: 6px"
            >
              <!-- Name -->
              <button
                id="sort-name"
                class="sort-btn"
                type="button"
                title="Sort by name (A‚ÜíZ / Z‚ÜíA)"
              >
                <i class="fa-solid fa-font fa-icon" aria-hidden="true"></i>
                <span class="fa-fallback" aria-hidden="true">A</span>
                <span class="dir">‚Üë</span>
              </button>

              <!-- Progress -->
              <button
                id="sort-progress"
                class="sort-btn"
                type="button"
                title="Sort by progress (low‚Üíhigh / high‚Üílow)"
              >
                <i
                  class="fa-solid fa-chart-simple fa-icon"
                  aria-hidden="true"
                ></i>
                <span class="fa-fallback" aria-hidden="true">‚ñ§</span>
                <span class="dir">‚Üë</span>
              </button>

              <!-- Last updated -->
              <button
                id="sort-time"
                class="sort-btn"
                type="button"
                title="Sort by last updated (newest / oldest)"
              >
                <i class="fa-regular fa-clock fa-icon" aria-hidden="true"></i>
                <span class="fa-fallback" aria-hidden="true">üïí</span>
                <span class="dir">‚Üì</span>
              </button>
            </div>
          </div>

          <button id="closeDashboard" type="button" title="Close">√ó</button>
        </div>

        <div id="dashboardBody">
          <div
            class="dashboard-grid"
            id="dashboardGrid"
            role="grid"
            aria-label="Games list"
            tabindex="0"
          ></div>
        </div>
      </div>

      <div
        id="dashboardContextMenu"
        class="dash-context-menu hidden"
        role="menu"
        aria-hidden="true"
      >
        <button
          id="dashboardMenuEdit"
          class="dash-menu-item"
          type="button"
          data-action="edit"
        >
          Edit
        </button>
        <button
          id="dashboardMenuRegenerate"
          class="dash-menu-item"
          type="button"
          data-action="regen"
        >
          Regenerate Schema
        </button>
        <button
          id="dashboardMenuIgnore"
          class="dash-menu-item"
          type="button"
          data-action="ignore"
        >
          Ignore Game
        </button>
        <button
          id="dashboardMenuDelete"
          class="dash-menu-item is-danger"
          type="button"
          data-action="delete"
        >
          Delete
        </button>
      </div>
    </div>

    <div
      id="appConfirmModal"
      class="modal hidden"
      aria-hidden="true"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content confirm-modal">
        <h3 id="appConfirmTitle">Confirm</h3>
        <p id="appConfirmMessage"></p>
        <label id="appConfirmCheckboxRow" class="confirm-checkbox-row hidden">
          <input id="appConfirmCheckbox" type="checkbox" />
          <span id="appConfirmCheckboxLabel"></span>
        </label>
        <label id="appConfirmCheckboxRow2" class="confirm-checkbox-row hidden">
          <input id="appConfirmCheckbox2" type="checkbox" />
          <span id="appConfirmCheckboxLabel2"></span>
        </label>
        <div class="confirm-actions">
          <button id="appConfirmCancelBtn" type="button">Cancel</button>
          <button id="appConfirmOkBtn" type="button">OK</button>
        </div>
      </div>
    </div>
    <div
      id="bootOnboardingModal"
      class="modal hidden"
      aria-hidden="true"
      role="dialog"
      aria-modal="true"
    >
      <div class="modal-content boot-onboarding-modal">
        <h3 id="bootOnboardingTitle">Choose folders for Auto-Config</h3>
        <p id="bootOnboardingMessage">
          Was found folders with achievement data. Select which folders should be
          scanned automatically.
        </p>
        <div
          id="bootOnboardingList"
          class="boot-onboarding-list"
          role="list"
          tabindex="0"
          aria-label="Auto-config folder selection"
        ></div>
        <p id="bootOnboardingHint" class="boot-onboarding-hint"></p>
        <div id="bootOnboardingActions" class="confirm-actions">
          <button id="bootOnboardingSkipBtn" type="button">
            Skip and mute all
          </button>
          <button id="bootOnboardingStartBtn" type="button">
            Start Auto-Config
          </button>
        </div>
        <div id="bootOnboardingDone" class="hidden">
          <p id="bootOnboardingDoneMessage"></p>
          <div class="confirm-actions">
            <button id="bootOnboardingDoneOkBtn" type="button">OK</button>
          </div>
        </div>
      </div>
    </div>

    <script src="utils/i18n-ui.js"></script>
    <script>

      if (window.electron.platform() === "linux") {
        document.getElementsByClassName('input-with-button')[3].style = "pointer-events: none; opacity: 0.2;"
      }

      window.__coverNameCache = window.__coverNameCache || {};
      function rememberCoverName(appid, displayName) {
        if (!appid || !displayName) return;
        const key = String(appid);
        window.__coverNameCache[key] = String(displayName).trim();
      }
      function rememberCoverNamesFromList(list) {
        if (!Array.isArray(list)) return;
        list.forEach((cfg) => {
          if (cfg?.appid && (cfg.displayName || cfg.name)) {
            rememberCoverName(cfg.appid, cfg.displayName || cfg.name);
          }
        });
      }
      function getCoverSearchTerm(appid) {
        if (!appid) return "";
        const key = String(appid);
        return window.__coverNameCache[key] || "";
      }

      window.__preferencesCache = window.__preferencesCache || null;
      window.__preferencesLoadPromise = null;
      const tUiFmt = (key, params = {}, fallback) => {
        let text = tUi(key, fallback);
        if (!params || typeof params !== "object") return text;
        for (const [k, v] of Object.entries(params)) {
          text = text.replaceAll(`{${k}}`, v);
        }
        return text;
      };
      const blacklistLabelCache = new Map();

      function deepEqual(a, b) {
        if (a === b) return true;
        if (Array.isArray(a) && Array.isArray(b)) {
          if (a.length !== b.length) return false;
          for (let i = 0; i < a.length; i += 1) {
            if (!deepEqual(a[i], b[i])) return false;
          }
          return true;
        }
        if (
          a &&
          b &&
          typeof a === "object" &&
          typeof b === "object" &&
          a.constructor === Object &&
          b.constructor === Object
        ) {
          const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
          for (const k of keys) {
            if (!deepEqual(a[k], b[k])) return false;
          }
          return true;
        }
        return false;
      }

      async function loadPreferencesCached() {
        if (window.__preferencesLoadPromise) {
          return window.__preferencesLoadPromise;
        }
        window.__preferencesLoadPromise = (async () => {
          try {
            const prefs = await window.api.loadPreferences();
            window.__preferencesCache = { ...(prefs || {}) };
            return window.__preferencesCache;
          } catch (err) {
            console.error(
              tUi("log.preferencesLoadFailed", "Failed to load preferences:"),
              err,
            );
            return window.__preferencesCache || {};
          } finally {
            window.__preferencesLoadPromise = null;
          }
        })();
        return window.__preferencesLoadPromise;
      }

      function getCachedPreferences() {
        return window.__preferencesCache || {};
      }

      async function refreshPreferencesCache() {
        try {
          await loadPreferencesCached();
        } catch (err) {
          console.warn(
            tUi(
              "log.preferencesCacheRefreshFailed",
              "Failed to refresh preferences cache:",
            ),
            err,
          );
        }
      }
      async function maybeRequestPlatinum(
        configMeta,
        achievementsList,
        savedAchievementsObj,
      ) {
        if (!configMeta) return;
        if (configMeta.platinum === true) return; // already flagged, skip
        const total = Array.isArray(achievementsList)
          ? achievementsList.length
          : 0;
        if (!total) return;
        const saved = savedAchievementsObj?.achievements || {};
        const earned = Object.values(saved).filter((x) => x?.earned).length;
        if (earned !== total) return;

        window.__platinumManualSent = window.__platinumManualSent || new Set();
        const key =
          configMeta.name ||
          configMeta.configName ||
          configMeta.appid ||
          configMeta.appId ||
          "";
        if (!key || window.__platinumManualSent.has(key)) return;
        window.__platinumManualSent.add(key);

        const payload = {
          configName: configMeta.name || configMeta.configName || "",
          appid: configMeta.appid || configMeta.appId || null,
          savePath: configMeta.save_path || configMeta.savePath || null,
          configPath: configMeta.config_path || configMeta.configPath || null,
          suppressNotify: false,
        };

        try {
          if (window.api?.requestPlatinumManual) {
            await window.api.requestPlatinumManual(payload);
          } else if (window.electron?.ipcRenderer?.invoke) {
            await window.electron.ipcRenderer.invoke(
              "platinum:manual",
              payload,
            );
          }
        } catch (err) {
          console.warn(
            tUi(
              "log.manualPlatinumTriggerFailed",
              "Failed to trigger manual platinum:",
            ),
            err,
          );
        }
      }

      if (!window.__savePrefsPatched && window.api?.savePreferences) {
        window.__savePrefsPatched = true;
        const originalSavePreferences = window.api.savePreferences;
        window.api.savePreferences = async (prefs) => {
          const current = getCachedPreferences();
          const pending = { ...(prefs || {}) };
          Object.keys(pending).forEach((key) => {
            if (deepEqual(pending[key], current[key])) {
              delete pending[key];
            }
          });
          if (!Object.keys(pending).length) return current;
          const result = await originalSavePreferences(pending);
          try {
            const merged = {
              ...current,
              ...pending,
            };
            delete merged.steamApiKeyMasked;
            window.__preferencesCache = merged;
          } catch (err) {
            console.warn(
              tUi(
                "log.preferencesCacheUpdateFailed",
                "Failed to update preferences cache:",
              ),
              err,
            );
          }
          return result;
        };
      }

      function patchApiWithCacheRefresh(target, method) {
        if (!target || typeof target[method] !== "function") return;
        const flag = `__prefsCacheWrapped_${method}`;
        if (target[flag]) return;
        const original = target[method];
        target[method] = async (...args) => {
          const result = await original(...args);
          await refreshPreferencesCache();
          return result;
        };
        target[flag] = true;
      }

      patchApiWithCacheRefresh(window.api, "blacklistConfig");
      patchApiWithCacheRefresh(window.api, "resetBlacklist");
      patchApiWithCacheRefresh(window.api, "getBlacklist");
      if (window.folders) {
        ["add", "remove", "block", "unblock"].forEach((method) =>
          patchApiWithCacheRefresh(window.folders, method),
        );
      }

      //Start with Windows
      async function handleStartWithWindowsToggle(enabled) {
        const checkbox = document.getElementById(
          "settings-startWindowsCheckbox",
        );
        try {
          await window.api.setStartWithWindows(enabled);
          await window.api.savePreferences({ startWithWindows: enabled });
        } catch (err) {
          if (checkbox) checkbox.checked = !enabled;
          alert(
            tUi(
              "alert.autoStartUpdateFailed",
              "Failed to update auto-start setting. Please run as administrator.",
            ),
          );
        }
      }

      // Image script
      window.addEventListener("DOMContentLoaded", () => {
        const embedRoot = document.getElementById("embeddedGameImage");
        const imgWrap = document.getElementById("embeddedImageContainer");
        const imgEl = document.getElementById("embeddedGameImageImg");
        const fallbackBox = document.getElementById("embeddedFallbackPrompt");
        const fallbackIcon = new URL(
          "./assets/achievements-logo.png",
          window.location.href,
        ).toString();
        const steamGridUrlCache = new Map();
        function buildSteamGridSearchTerm(input) {
          return String(input || "")
            .trim()
            .replace(/\+/g, " ")
            .replace(/\s+/g, "+");
        }
        function normalizeCoverPlatform(value) {
          return String(value || "")
            .trim()
            .toLowerCase();
        }
        function isSteamGridOnlyPlatform(value) {
          const platform = normalizeCoverPlatform(value);
          return (
            platform === "xenia" ||
            platform === "rpcs3" ||
            platform === "shadps4" ||
            platform === "ps4"
          );
        }
        function stripCoverSuffix(name) {
          let out = String(name || "").trim();
          if (!out) return "";
          const rx =
            /\s*\((?:steam|steam[-\s]?official|xenia|rpcs3|ps4|shadps4)\)\s*$/i;
          while (rx.test(out)) out = out.replace(rx, "").trim();
          return out;
        }
        async function downloadFromSteamGrid(
          targetAppId,
          rawTerm,
          size = "600x900",
          platformHint = null,
        ) {
          const term = buildSteamGridSearchTerm(rawTerm);
          if (!term) return false;
          const logCover = (level, message, meta = {}) => {
            try {
              if (window.api?.logCoverEvent) {
                window.api.logCoverEvent(level, message, meta);
              }
            } catch {}
          };
          const cacheKey = `${size}::${term.toLowerCase()}`;
          if (steamGridUrlCache.has(cacheKey)) {
            const cached = steamGridUrlCache.get(cacheKey);
            if (cached === null) return false;
            try {
              await downloadAndSave(targetAppId, cached, platformHint);
              return true;
            } catch (err) {
              steamGridUrlCache.delete(cacheKey);
            }
          }
          try {
            const response = await window.api.getSteamGridDbCover({
              term,
              size,
            });
            if (response?.ok && response.url) {
              steamGridUrlCache.set(cacheKey, response.url);
              await downloadAndSave(targetAppId, response.url, platformHint);
              return true;
            }
            logCover("warn", "steamgrid:ipc-failed", {
              appid: targetAppId,
              term,
              size,
              message: response?.message || "no-url",
            });
          } catch (err) {
            logCover("warn", "steamgrid:ipc-error", {
              appid: targetAppId,
              term,
              size,
              error: err?.message || String(err),
            });
          }
          steamGridUrlCache.set(cacheKey, null);
          return false;
        }
        if (!embedRoot || !imgWrap || !imgEl) return;
        const isPlatinumFlagEnabled = (value) => {
          if (value === true || value === 1) return true;
          const normalized = String(value || "")
            .trim()
            .toLowerCase();
          return normalized === "true" || normalized === "1";
        };
        const perfectBadge = document.createElement("img");
        perfectBadge.src = new URL(
          "./assets/trophy-icon.png",
          window.location.href,
        ).toString();
        perfectBadge.alt = "Perfect Game";
        perfectBadge.style.position = "absolute";
        perfectBadge.style.left = "10px";
        perfectBadge.style.bottom = "10px";
        perfectBadge.style.width = "30%";
        perfectBadge.style.height = "25%";
        perfectBadge.style.display = "none";
        perfectBadge.style.pointerEvents = "none";
        perfectBadge.style.zIndex = "5";
        imgWrap.style.position = "relative";
        imgWrap.appendChild(perfectBadge);
        window.__setEmbeddedPlatinumBadgeByConfig = (configMeta) => {
          const shouldShow = isPlatinumFlagEnabled(configMeta?.platinum);
          perfectBadge.style.display = shouldShow ? "block" : "none";
        };

        // --- fallback logo ---
        function showFallbackLogo() {
          imgEl.onload = null;
          imgEl.onerror = null;
          imgEl.src = fallbackIcon;
          imgWrap.style.display = "flex";
          if (fallbackBox) fallbackBox.style.display = "none";
        }
        window.__showFallbackLogo = showFallbackLogo;
        showFallbackLogo();

        // --- UI helpers ---
        function setVisible(hasImage) {
          if (hasImage) {
            if (fallbackBox) fallbackBox.style.display = "none";
            imgWrap.style.display = "flex";
          } else {
            imgWrap.style.display = "flex";
            if (fallbackBox) fallbackBox.style.display = "none";
          }
        }

        function fileUrl(p) {
          return `file:///${encodeURI(String(p).replace(/\\/g, "/"))}`;
        }

        function setImg(src) {
          return new Promise((resolve, reject) => {
            const versioned = `${src}${
              src.includes("?") ? "&" : "?"
            }_=${Date.now()}`;

            imgEl.onload = () => resolve();
            imgEl.onerror = () =>
              reject(new Error(`image load failed: ${versioned}`));
            imgEl.src = "";
            requestAnimationFrame(() => {
              imgEl.src = versioned;
            });
          });
        }

        async function setImgFromLocal(localPath) {
          const url = fileUrl(localPath);
          await setImg(url);
        }

        const NOT_FOUND_TAG = "steamdb-miss";
        const isNotFoundError = (err) =>
          !!err && (err.tag === NOT_FOUND_TAG || err.code === NOT_FOUND_TAG);

        const CDN_HOSTS = [
          "https://shared.fastly.steamstatic.com",
          "https://shared.cloudflare.steamstatic.com",
          "https://cdn.akamai.steamstatic.com/",
        ];
        const remoteAppIdCache = new Map();
        async function resolveRemoteAppId(appid) {
          const key = String(appid || "");
          if (!/^\d+$/.test(key)) return key;
          if (remoteAppIdCache.has(key)) return remoteAppIdCache.get(key);
          try {
            const mapped = await window.api.getSteamLookupAppId(key);
            const effective =
              mapped && /^\d+$/.test(String(mapped)) ? String(mapped) : key;
            remoteAppIdCache.set(key, effective);
            return effective;
          } catch {
            remoteAppIdCache.set(key, key);
            return key;
          }
        }
        async function downloadAndSave(targetAppId, url, platformHint = null) {
          const logCover = (level, message, meta = {}) => {
            try {
              if (window.api?.logCoverEvent) {
                window.api.logCoverEvent(level, message, meta);
              }
            } catch {}
          };
          logCover("info", "download:start", {
            appid: targetAppId,
            platform: platformHint || "auto",
            url,
          });
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) throw new Error("HTTP " + res.status);
          const blob = await res.blob();
          const buf = new Uint8Array(await blob.arrayBuffer());
          const platform =
            platformHint ||
            (await resolvePlatformForCurrentApp(targetAppId)) ||
            null;
          await window.api.saveGameImage(String(targetAppId), buf, platform);
          logCover("info", "download:saved", {
            appid: targetAppId,
            platform: platform || "auto",
            url,
          });
        }
        async function resolvePlatformForCurrentApp(appid) {
          try {
            const selectedConfig = document.getElementById("configList")?.value;
            if (selectedConfig && window.api.getConfigByName) {
              const cfg = await window.api.getConfigByName(selectedConfig);
              const cfgAppId = cfg?.appid || cfg?.appId;
              if (cfg && String(cfgAppId || "") === String(appid || cfgAppId)) {
                return cfg.platform || null;
              }
            }
          } catch {}
          return null;
        }

        const inFlightCovers = new Map();
        async function downloadFromCdnAndCache(
          targetAppId,
          fetchAppIdOverride = null,
          options = {},
        ) {
          const key = String(targetAppId);
          if (inFlightCovers.has(key)) {
            return inFlightCovers.get(key);
          }
          const task = (async () => {
            const fetchAppId = fetchAppIdOverride || targetAppId;
            const platform =
              options?.platform ||
              (await resolvePlatformForCurrentApp(targetAppId)) ||
              null;
            const rawFallbackName = String(
              options?.gameName || getCoverSearchTerm(targetAppId) || "",
            ).trim();
            const fallbackName =
              stripCoverSuffix(rawFallbackName) || rawFallbackName;
            const normalizedPlatform = normalizeCoverPlatform(platform);
            const steamGridOnly = isSteamGridOnlyPlatform(normalizedPlatform);
            const steamGridSize =
              options?.gridSize && String(options.gridSize).trim().length
                ? String(options.gridSize)
                : "600x900";
            const logCover = (level, message, meta = {}) => {
              try {
                if (window.api?.logCoverEvent) {
                  window.api.logCoverEvent(level, message, meta);
                }
              } catch {}
            };
            logCover("info", "cascade:start", {
              targetAppId,
              fetchAppId,
              platform,
              steamGridOnly,
              coverName: fallbackName || null,
              steamGridSize,
            });
            if (steamGridOnly) {
              if (fallbackName) {
                const ok = await downloadFromSteamGrid(
                  targetAppId,
                  fallbackName,
                  steamGridSize,
                  platform,
                );
                if (ok) {
                  logCover("info", "steamgrid:hit", {
                    targetAppId,
                    fetchAppId,
                    term: fallbackName,
                    steamGridSize,
                  });
                  return true;
                }
              }
              logCover("warn", "steamgrid:only-miss", {
                targetAppId,
                fetchAppId,
                term: fallbackName || null,
              });
              return false;
            }
            const plain = [
              `https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/${fetchAppId}/library_600x900.jpg`,
              `https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/${fetchAppId}/library_600x900.jpg`,
              `https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/${fetchAppId}/portrait.png`,
              `https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/${fetchAppId}/portrait.png`,
              `https://cdn.akamai.steamstatic.com/steam/apps/${fetchAppId}/library_600x900.jpg`,
              `https://cdn.akamai.steamstatic.com/steam/apps/${fetchAppId}/header.jpg`,
            ];

            for (const url of plain) {
              try {
                await downloadAndSave(targetAppId, url, platform);
                logCover("info", "cdn:hit", { targetAppId, fetchAppId, url });
                return true;
              } catch (err) {
                logCover("warn", "cdn:miss", {
                  targetAppId,
                  fetchAppId,
                  url,
                  error: err?.message || String(err),
                });
              }
            }

            try {
              const r = await window.api.getSteamDbCover(fetchAppId);
              if (r?.url) {
                await downloadAndSave(targetAppId, r.url, platform);
                logCover("info", "steamdb:hit", {
                  targetAppId,
                  fetchAppId,
                  url: r.url,
                });
                return true;
              }
            } catch (err) {
              logCover("warn", "steamdb:fail", {
                targetAppId,
                fetchAppId,
                error: err?.message || String(err),
              });
            }

            try {
              await downloadFromStoreHeader(fetchAppId, targetAppId);
              logCover("info", "store:hit", {
                targetAppId,
                fetchAppId,
              });
              return true;
            } catch (err) {
              logCover("warn", "store:fail", {
                targetAppId,
                fetchAppId,
                error: err?.message || String(err),
              });
            }

            if (fallbackName) {
              const ok = await downloadFromSteamGrid(
                targetAppId,
                fallbackName,
                steamGridSize,
                platform,
              );
              if (ok) {
                logCover("info", "steamgrid:hit", {
                  targetAppId,
                  fetchAppId,
                  term: fallbackName,
                  steamGridSize,
                });
                return true;
              }
            }

            logCover("warn", "covers:all-sources-failed", {
              targetAppId,
              fetchAppId,
            });
            return false;
          })().finally(() => inFlightCovers.delete(key));

          inFlightCovers.set(key, task);
          return task;
        }
        async function downloadFromStoreHeader(
          fetchAppId,
          targetAppId = fetchAppId,
        ) {
          try {
            const res = await fetch(
              `https://store.steampowered.com/api/appdetails?appids=${fetchAppId}`,
              { cache: "no-store" },
            );
            if (!res.ok) throw new Error(`Store API HTTP ${res.status}`);

            const data = await res.json();
            const entry = data?.[String(fetchAppId)];
            const headerUrl =
              entry?.data?.library_assets?.library_600x900 ||
              entry?.data?.library_assets?.logo ||
              entry?.data?.header_image ||
              entry?.data?.capsule_image;

            if (!headerUrl) {
              const err = new Error("Store: no image field");
              err.tag = NOT_FOUND_TAG;
              throw err;
            }

            await downloadAndSave(targetAppId, headerUrl);
            return true;
          } catch (err) {
            if (!err.tag) err.tag = NOT_FOUND_TAG;
            throw err;
          }
        }

        // --- loader: local -> (fallback) -> CDN -> local ---
        async function loadLocalCover(appid) {
          if (!appid) {
            showFallbackLogo();
            return;
          }

          const fetchAppId = await resolveRemoteAppId(appid);
          const coverNameHint = getCoverSearchTerm(appid) || "";
          const platform =
            (await resolvePlatformForCurrentApp(appid)) || "steam";

          try {
            const localPath = await window.api.checkLocalGameImage(
              String(appid),
              platform,
            );

            if (localPath) {
              try {
                await setImgFromLocal(localPath);
                setVisible(true);
                return;
              } catch {
                showFallbackLogo();
                return;
              }
            }
            showFallbackLogo();

            const ok = await downloadFromCdnAndCache(
              String(appid),
              fetchAppId,
              { gameName: coverNameHint, platform },
            );
            if (!ok) return;

            const newLocal = await window.api.checkLocalGameImage(
              String(appid),
              platform,
            );
            if (newLocal) {
              try {
                await setImgFromLocal(newLocal);
                setVisible(true);
              } catch {
                showFallbackLogo();
              }
            } else {
              showFallbackLogo();
            }
          } catch {
            showFallbackLogo();
          }
        }
        window.__applyEmbeddedGameImageForAppId = async function (appid) {
          if (!appid) {
            showFallbackLogo();
            return;
          }
          try {
            await loadLocalCover(String(appid));
          } catch {
            showFallbackLogo();
          }
        };

        // ‚úé prompt
        window.showAltAppIdPrompt = function () {
          if (fallbackBox) fallbackBox.style.display = "flex";
          imgWrap.style.display = "none";
          const input = document.getElementById("altAppId");
          if (input) {
            input.focus();
            input.select();
          }
        };

        window.cancelFallback = function () {
          if (fallbackBox) fallbackBox.style.display = "none";
          imgWrap.style.display = "flex";
        };

        // alt AppID
        window.downloadFromAlternativeAppId = async function () {
          const input = document.getElementById("altAppId");
          const alt = (input?.value || "").trim();
          if (!/^\d+$/.test(alt)) {
            alert(tUi("alert.invalidAppId", "Please enter a valid AppID"));
            return;
          }

          const selectedConfig = document.getElementById("configList")?.value;
          const currentConfig = selectedConfig
            ? await window.api.getConfigByName(selectedConfig)
            : null;
          const currentAppId =
            currentConfig?.appid && /^\d+$/.test(String(currentConfig.appid))
              ? String(currentConfig.appid)
              : alt;
          const platform =
            currentConfig?.platform ||
            (await resolvePlatformForCurrentApp(currentAppId)) ||
            null;
          const coverName =
            getCoverSearchTerm(currentAppId) ||
            currentConfig?.displayName ||
            currentConfig?.name ||
            "";
          if (coverName) {
            rememberCoverName(currentAppId, coverName);
          }

          const ok = await downloadFromCdnAndCache(String(currentAppId), alt, {
            gameName: coverName,
            platform,
          });

          if (!ok) {
            alert(
              tUi(
                "alert.altAppIdNoImage",
                "No image available for the alternate AppID.",
              ),
            );
            return;
          }

          await loadLocalCover(String(currentAppId));
          if (fallbackBox) fallbackBox.style.display = "none";
          imgWrap.style.display = "flex";
        };

        // update main
        if (!window.__imageListenerAttached) {
          window.api.onImageUpdate(async (payload) => {
            const appid =
              typeof payload === "object" && payload?.appid
                ? String(payload.appid)
                : /^\d+$/.test(String(payload))
                  ? String(payload)
                  : null;
            if (appid) await loadLocalCover(appid);
            else showFallbackLogo();
          });

          window.__imageListenerAttached = true;
        }
        window.loadLocalCover = loadLocalCover;
      });

      window.addEventListener("DOMContentLoaded", () => {
        const iconParam = new URLSearchParams(location.search).get("icon");
        if (!iconParam) return;
        const url = decodeURIComponent(iconParam);
        const el = document.getElementById("appIcon");
        if (el) el.src = url;
      });
      function getAppIconUrl() {
        const q = new URLSearchParams(location.search).get("icon");
        return q ? decodeURIComponent(q) : "";
      }
      //Achievements Images
      async function resolveAchievementIcon(imgEl, cfgPath, rel) {
        const FALLBACK = getAppIconUrl();
        const r = String(rel || "");
        const base = r.split(/[\\/]/).pop();

        const candidates = []
          .concat(r ? [`${cfgPath}\\${r}`] : [])
          .concat([
            `${cfgPath}\\achievement_images\\${base}`,
            `${cfgPath}\\steam_settings\\achievement_images\\${base}`,
            `${cfgPath}\\img\\${base}`,
            `${cfgPath}\\images\\${base}`,
          ])
          .filter((v, i, a) => v && a.indexOf(v) === i)
          .map((p) => `file:///${p.replace(/\\/g, "/")}`);

        let i = 0;
        const tryNext = () => {
          if (i >= candidates.length) {
            imgEl.src = FALLBACK;
            return;
          }
          imgEl.onerror = () => {
            i++;
            tryNext();
          };
          imgEl.src = candidates[i];
        };
        tryNext();
      }

      function setAchievementsHeaderVisible(visible) {
        const header = document.getElementById("achievementsHeader");
        if (!header) return;
        header.style.display = visible ? "flex" : "none";
        if (!visible) {
          const input = document.getElementById("achievementsSearchInput");
          if (input) input.value = "";
          const wrap = document.getElementById("achievementsSearch");
          if (wrap) wrap.classList.remove("open");
        }
      }

      function setAchievementsSearchOpen(open, selectAll = true) {
        const header = document.getElementById("achievementsHeader");
        const wrap = document.getElementById("achievementsSearch");
        const input = document.getElementById("achievementsSearchInput");
        if (!header || !wrap || !input) return;
        if (header.style.display === "none") return;
        wrap.classList.toggle("open", open);
        if (open) {
          input.focus({ preventScroll: true });
          if (selectAll) input.select();
        } else {
          input.value = "";
          applyAchievementsSearchFilter();
          input.blur();
        }
      }

      function applyAchievementsSearchFilter() {
        const input = document.getElementById("achievementsSearchInput");
        const query = String(input?.value || "")
          .trim()
          .toLowerCase();
        const rows = document.querySelectorAll("#achievementsTableBody tr");
        rows.forEach((row) => {
          const hay = String(row?.dataset?.search || "");
          row.style.display = !query || hay.includes(query) ? "" : "none";
        });
      }

      function ensureAchievementsSearchAttached() {
        if (window.__achSearchAttached) return;
        const wrap = document.getElementById("achievementsSearch");
        const input = document.getElementById("achievementsSearchInput");
        const toggle = document.getElementById("achievementsSearchToggle");
        if (!wrap || !input || !toggle) return;
        toggle.addEventListener("click", () => {
          const open = !wrap.classList.contains("open");
          setAchievementsSearchOpen(open, true);
        });
        if (!input) return;
        input.addEventListener("input", applyAchievementsSearchFilter);
        input.addEventListener("blur", () => {
          if (!input.value.trim()) setAchievementsSearchOpen(false);
        });
        input.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            e.preventDefault();
            e.stopPropagation();
            setAchievementsSearchOpen(false);
          }
        });
        window.__achSearchAttached = true;
      }

      function focusAchievementsSearch(selectAll = true) {
        const configList = document.getElementById("configList");
        if (!configList || !configList.value) return;
        setAchievementsSearchOpen(true, selectAll);
      }
      window.focusAchievementsSearch = focusAchievementsSearch;

      async function buildMainAchievementsTable(
        selectedConfig,
        lang = "english",
      ) {
        ensureAchievementsSearchAttached();
        if (!selectedConfig) {
          setAchievementsHeaderVisible(false);
          return;
        }
        const achSearchInput = document.getElementById(
          "achievementsSearchInput",
        );
        if (achSearchInput && window.__achSearchConfig !== selectedConfig) {
          achSearchInput.value = "";
          window.__achSearchConfig = selectedConfig;
        }

        const achievementsDataObj =
          await window.api.loadAchievementData(selectedConfig);
        if (
          !achievementsDataObj ||
          !Array.isArray(achievementsDataObj.achievements)
        ) {
          const body = document.getElementById("achievementsTableBody");
          if (body) body.innerHTML = "";
          setAchievementsHeaderVisible(false);
          const achStats = document.getElementById("achStats");
          if (achStats) achStats.style.display = "none";
          const playtimeLabel = document.getElementById("achStatsPlaytime");
          const lastPlayedLabel = document.getElementById("achStatsLastPlayed");
          if (playtimeLabel)
            playtimeLabel.textContent = tUiFmt(
              "achStatsPlaytimeFmt",
              { value: "0m" },
              "Playtime: 0m",
            );
          if (lastPlayedLabel) {
            lastPlayedLabel.textContent = tUiFmt(
              "achStatsLastPlayedFmt",
              { value: "N/A" },
              "Last Played: N/A",
            );
          }
          return;
        }
        const savedAchievementsObj =
          await window.api.loadSavedAchievements(selectedConfig);
        const currentConfig = await window.api.getConfigByName(selectedConfig);
        maybeRequestPlatinum(
          { name: selectedConfig, ...(currentConfig || {}) },
          achievementsDataObj?.achievements || [],
          savedAchievementsObj,
        );

        const tableBody = document.getElementById("achievementsTableBody");
        if (!tableBody) return;
        tableBody.innerHTML = "";

        if (
          achievementsDataObj?.error ||
          !Array.isArray(achievementsDataObj?.achievements)
        )
          return;

        // Sort after name
        const seen = new Set();
        const unique = [];
        for (const a of achievementsDataObj.achievements) {
          if (!a?.name || seen.has(a.name)) continue;
          seen.add(a.name);
          unique.push(a);
        }

        // unlocked first
        const isUnlocked = (name) =>
          !!savedAchievementsObj?.achievements?.[name]?.earned;
        unique.sort(
          (a, b) => (isUnlocked(b.name) ? 1 : 0) - (isUnlocked(a.name) ? 1 : 0),
        );

        function tsToLocal(ts) {
          if (!ts) return "N/A";
          const d = new Date(String(ts).length === 10 ? ts * 1000 : Number(ts));
          return isNaN(d) ? "N/A" : d.toLocaleString();
        }

        setAchievementsHeaderVisible(true);

        for (const achievement of unique) {
          const displayName = getSafeLocalizedText(
            achievement.displayName,
            lang,
          );
          const description = getSafeLocalizedText(
            achievement.description,
            lang,
          );
          const iconGray = achievement.icon_gray || achievement.icongray;
          const icon = achievement.icon || iconGray;

          const saved = savedAchievementsObj?.achievements?.[achievement.name];
          const imgRel = saved?.earned ? icon : iconGray;
          const imagePath = `file:///${`${achievementsDataObj.config_path}\\${imgRel}`.replace(
            /\\/g,
            "/",
          )}`;

          const statusLocked =
            (window.i18nUi &&
              typeof window.i18nUi.getString === "function" &&
              window.i18nUi.getString("overlay.statusLocked", "Locked")) ||
            "Locked";
          const statusUnlocked =
            (window.i18nUi &&
              typeof window.i18nUi.getString === "function" &&
              window.i18nUi.getString("overlay.statusUnlocked", "Unlocked")) ||
            "Unlocked";
          const progressLabel =
            (window.i18nUi &&
              typeof window.i18nUi.getString === "function" &&
              window.i18nUi.getString("overlay.progressLabel", "Progress")) ||
            "Progress";
          const hiddenLabel =
            (window.i18nUi &&
              typeof window.i18nUi.getString === "function" &&
              window.i18nUi.getString("overlay.hiddenFallback", "Hidden")) ||
            "Hidden";
          const statusHTML = saved?.earned
            ? `<span class="unlocked">${statusUnlocked}</span>`
            : `<span class="locked">${statusLocked}</span>`;

          const earnedTimeText = saved?.earned_time
            ? `<br>${tsToLocal(saved.earned_time)}`
            : "";
          let progressText = "";
          if (
            Number.isFinite(saved?.progress) &&
            Number.isFinite(saved?.max_progress) &&
            saved.max_progress > 0
          ) {
            const pct = Math.min(
              100,
              Math.round((saved.progress / saved.max_progress) * 100),
            );
            progressText = `
                    <div class="achievement-progress">
                    ${progressLabel}: ${saved.progress} / ${saved.max_progress}
                    <div class="progress-bar">
                        <div class="progress-fill" style="width:${pct}%"></div>
                    </div>
                    </div>`;
          }

          const row = document.createElement("tr");
          // col image
          const tdImg = document.createElement("td");
          tdImg.className = "image";
          const achImg = document.createElement("img");
          achImg.className = "ach-icon";
          achImg.alt = "Icon";
          tdImg.appendChild(achImg);

          // col text
          const tdText = document.createElement("td");
          tdText.className = "displayName";
          const strong = document.createElement("strong");
          strong.textContent = displayName || hiddenLabel;
          const descWrap = document.createElement("span");
          descWrap.className = "description";
          descWrap.style.display = "block";
          const prefs = getCachedPreferences() || {};
          const isHiddenInSchema = Number(achievement.hidden) === 1;
          const isUnlockedState = !!saved?.earned;
          const canShowHiddenDesc =
            isUnlockedState && description
              ? true
              : prefs.showHiddenDescription === true;
          const descText =
            isHiddenInSchema && !canShowHiddenDesc
              ? hiddenLabel
              : description || "";
          row.dataset.search =
            `${displayName || ""} ${descText || ""} ${achievement.name || ""}`
              .toLowerCase()
              .trim();
          descWrap.appendChild(document.createElement("em")).textContent =
            descText;
          tdText.appendChild(strong);
          tdText.appendChild(document.createElement("br"));
          tdText.appendChild(descWrap);

          // progress
          if (
            Number.isFinite(saved?.progress) &&
            Number.isFinite(saved?.max_progress) &&
            saved.max_progress > 0
          ) {
            const pct = Math.min(
              100,
              Math.round((saved.progress / saved.max_progress) * 100),
            );
            const progWrap = document.createElement("div");
            progWrap.className = "achievement-progress";
            progWrap.textContent = `${progressLabel}: ${saved.progress} / ${saved.max_progress}`;
            const bar = document.createElement("div");
            bar.className = "progress-bar";
            const fill = document.createElement("div");
            fill.className = "progress-fill";
            fill.style.width = `${pct}%`;
            bar.appendChild(fill);
            progWrap.appendChild(bar);
            tdText.appendChild(progWrap);
          }

          // col status
          const tdStatus = document.createElement("td");
          tdStatus.className = "status";
          const st = document.createElement("span");
          st.className = saved?.earned ? "unlocked" : "locked";
          st.textContent = saved?.earned ? statusUnlocked : statusLocked;
          tdStatus.appendChild(st);
          if (saved?.earned_time) {
            tdStatus.appendChild(document.createElement("br"));
            tdStatus.appendChild(
              document.createTextNode(tsToLocal(saved.earned_time)),
            );
          }

          row.append(tdImg, tdText, tdStatus);
          tableBody.appendChild(row);
          const imgEl = row.querySelector("img.ach-icon");
          resolveAchievementIcon(
            imgEl,
            achievementsDataObj.config_path,
            imgRel,
          );
        }
        applyAchievementsSearchFilter();

        // Main Progress Bar
        updateAchievementStats(
          unique.map((a) => ({ ...a, earned: isUnlocked(a.name) })),
        );
        const achStats = document.getElementById("achStats");
        if (achStats) achStats.style.display = "block";
        await updatePlaytimeLabel(selectedConfig);
      }

      (function attachRefreshAchievementsHandlerOnce() {
        if (window.__refreshAchievementsHandlerAttached) return;
        window.__refreshAchievementsHandlerAttached = true;

        window.api.on("refresh-achievements-table", async (configName) => {
          const cfg =
            configName || document.getElementById("configList")?.value;
          if (cfg) {
            const lang =
              document.getElementById("languageSelect")?.value || "english";
            try {
              await buildMainAchievementsTable(cfg, lang);
            } catch {}
          }

          if (
            window.__dashboardOpen &&
            typeof window.updateCardProgressUI === "function"
          ) {
            const name =
              configName || document.getElementById("configList")?.value;
            if (name) {
              const card = document.querySelector(
                `.dash-card[data-name="${CSS.escape(name)}"]`,
              );
              if (card) {
                try {
                  await window.updateCardProgressUI(card, name);
                } catch {}
              }
            }
          }
        });
      })();

      function formatPlaytimeLabel(ms) {
        const totalSeconds = Math.max(0, Math.floor(Number(ms || 0) / 1000));
        if (!totalSeconds) return "0s";

        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        const parts = [];
        if (hours) parts.push(`${hours}h`);
        if (minutes) parts.push(`${minutes}m`);

        // always show seconds if nothing else rendered, or when <1h to match request
        if (!parts.length) {
          parts.push(`${seconds}s`);
        } else if (hours === 0 && seconds) {
          parts.push(`${seconds}s`);
        } else if (hours > 0 && seconds) {
          parts.push(`${seconds}s`);
        }
        return parts.join(" ").trim();
      }

      function formatLastPlayed(ts) {
        const value = Number(ts || 0);
        if (!Number.isFinite(value) || value <= 0) return "N/A";
        const d = new Date(value);
        return isNaN(d) ? "N/A" : d.toLocaleString();
      }

      async function updatePlaytimeLabel(configName) {
        const label = document.getElementById("achStatsPlaytime");
        const lastPlayedLabel = document.getElementById("achStatsLastPlayed");
        if (!label || !configName) return;
        try {
          const res = await window.api.getTotalPlaytime(configName);
          const totalMs =
            typeof res === "number" ? res : Number(res?.totalMs || 0);
          const updatedAt =
            typeof res === "object" && res ? Number(res.updatedAt || 0) : 0;
          label.textContent = tUiFmt(
            "achStatsPlaytimeFmt",
            { value: formatPlaytimeLabel(totalMs) },
            `Playtime: ${formatPlaytimeLabel(totalMs)}`,
          );
          if (lastPlayedLabel) {
            lastPlayedLabel.textContent = tUiFmt(
              "achStatsLastPlayedFmt",
              { value: formatLastPlayed(updatedAt) },
              `Last Played: ${formatLastPlayed(updatedAt)}`,
            );
          }
        } catch {
          label.textContent = tUiFmt(
            "achStatsPlaytimeFmt",
            { value: "0m" },
            "Playtime: 0m",
          );
          if (lastPlayedLabel) {
            lastPlayedLabel.textContent = tUiFmt(
              "achStatsLastPlayedFmt",
              { value: "N/A" },
              "Last Played: N/A",
            );
          }
        }
      }

      const notificationQueue = [];
      let isNotificationActive = false;

      function showNotification(message, backgroundColor = "#4CAF50") {
        notificationQueue.push({ message, backgroundColor });
        if (!isNotificationActive) {
          processNextNotification();
        }
      }

      function processNextNotification() {
        if (notificationQueue.length === 0) {
          isNotificationActive = false;
          return;
        }

        isNotificationActive = true;
        const { message, backgroundColor } = notificationQueue.shift();

        const notif = document.createElement("div");
        notif.textContent = message;
        notif.style.position = "fixed";
        notif.style.top = "100px";
        notif.style.left = "50%";
        notif.style.transform = "translateX(-50%)";
        notif.style.backgroundColor = backgroundColor;
        notif.style.color = "white";
        notif.style.padding = "10px 20px";
        notif.style.borderRadius = "5px";
        notif.style.boxShadow = "0px 2px 8px rgba(0,0,0,0.3)";
        notif.style.zIndex = 9999;
        notif.style.fontWeight = "bold";
        notif.style.fontFamily = "sans-serif";
        notif.style.opacity = "0";
        notif.style.transition = "opacity 0.3s ease";
        notif.style.pointerEvents = "none";
        notif.style.userSelect = "none";
        document.body.appendChild(notif);
        requestAnimationFrame(() => (notif.style.opacity = "1"));

        setTimeout(() => {
          notif.style.opacity = "0";
          setTimeout(() => {
            notif.remove();
            processNextNotification();
          }, 300);
        }, 4000);
      }

      const SUPPRESS_MSG_PATTERNS = [
        /Save path is missing/i,
        /Config path is missing/i,
        /Achievements missing/i,
      ];

      const TECHNICAL_WARN_PATTERNS = [
        /\bDeprecationWarning\b/i,
        /\[DEP\d{4}\]/i,
        /--trace-deprecation/i,
        /node:internal\/process\/warning/i,
        /fs\.rmdir\(path,\s*\{\s*recursive:\s*true\s*\}\)/i,
      ];

      const _shownWarns = new Set();
      function shouldShowOnce(msg) {
        const key = msg.replace(/\s+/g, " ").trim();
        if (_shownWarns.has(key)) return false;
        _shownWarns.add(key);
        setTimeout(() => _shownWarns.delete(key), 2000);
        return true;
      }

      function isTechnicalWarn(msg) {
        const text = String(msg || "");
        return TECHNICAL_WARN_PATTERNS.some((rx) => rx.test(text));
      }

      window.api.onNotify(({ message, color }) => {
        if (isTechnicalWarn(message)) return;

        const isConfigPathWarn = SUPPRESS_MSG_PATTERNS.some((rx) =>
          rx.test(message),
        );

        if (window.__dashboardOpen && isConfigPathWarn) return;

        if (isConfigPathWarn && !shouldShowOnce(message)) return;

        showNotification(message, color || "#4CAF50");
      });

      window.addEventListener("DOMContentLoaded", () => {
        const originalLog = console.log.bind(console);
        const originalWarn = console.warn.bind(console);
        const originalError = console.error.bind(console);
        const originalAlert = window.alert.bind(window);

        const toMsg = (args) =>
          args
            .map((a) => {
              if (typeof a === "string") return a;
              try {
                return JSON.stringify(a);
              } catch {
                return String(a);
              }
            })
            .join(" ");

        console.log = (...args) => {
          originalLog(...args);
          const msg = toMsg(args);
          if (isTechnicalWarn(msg)) return;
          showNotification(msg, "#4CAF50");
        };

        console.warn = (...args) => {
          originalWarn(...args);
          const msg = toMsg(args);
          if (isTechnicalWarn(msg)) return;
          showNotification(msg, "#ff9800");
        };

        console.error = (...args) => {
          originalError(...args);
          const msg = toMsg(args);
          if (isTechnicalWarn(msg)) return;
          showNotification(msg, "#f44336");
        };

        window.alert = (message) => {
          showNotification(String(message), "#2196f3");
        };
      });

      const scaleSlider = document.getElementById("scaleSlider");
      const scaleValue = document.getElementById("scaleValue");

      function updateScaleLabel() {
        const value = parseFloat(scaleSlider.value);
        scaleValue.textContent = `${Math.round(value * 100)}%`;
        scaleSlider.style.background = `linear-gradient(to right, #007bff 0%, #007bff ${
          value * 100
        }%, #ccc ${value * 100}%, #ccc 100%)`;
      }
      scaleSlider.addEventListener("input", () => {
        updateScaleLabel();
        window.api.savePreferences({ notificationScale: scaleSlider.value });
      });
      updateScaleLabel();

      window.addEventListener("DOMContentLoaded", () => {
        const minimizeBtn = document.getElementById("minimizeBtn");
        const maximizeBtn = document.getElementById("maximizeBtn");
        const closeBtn = document.getElementById("closeBtn");

        document
          .getElementById("closeConfigModal")
          .addEventListener("click", () => {
            document.getElementById("configModal").classList.add("hidden");
            resetConfigForm();
          });
      });

      const platformSelect = document.getElementById("platformSelect");
      const steamAppIdInput = document.getElementById("steamAppIdInput");
      const steamAppIdRow = document.getElementById("steamAppIdRow");
      const lookupSteamIdBtn = document.getElementById("lookupSteamIdBtn");

      function toggleSteamAppIdRow(shouldShow) {
        if (!steamAppIdRow) return;
        steamAppIdRow.style.display = shouldShow ? "flex" : "none";
        if (!shouldShow && steamAppIdInput) {
          steamAppIdInput.value = "";
        }
      }

      async function lookupSteamAppId(manualTrigger = false) {
        if (!steamAppIdInput) return;
        const appidInput = document.getElementById("appid");
        const appIdValue = appidInput?.value.trim();
        if (!appIdValue) {
          if (manualTrigger) {
            showNotification(
              tUi("notify.enterAppId", "Enter the AppID."),
              "#FFC107",
            );
          }
          return;
        }
        try {
          const mapped = await window.api.getSteamLookupAppId(appIdValue);
          if (mapped) {
            steamAppIdInput.value = mapped;
            if (manualTrigger) {
              showNotification(
                tUiFmt(
                  "notify.steamAppIdFound",
                  { appid: mapped },
                  `Steam AppID found: ${mapped}`,
                ),
                "#4CAF50",
              );
            }
            console.info("[platform] steam-id-resolved", {
              appid: appIdValue,
              steamAppId: mapped,
              manual: manualTrigger,
            });
          } else if (manualTrigger) {
            showNotification(
              tUi(
                "notify.steamAppIdNotFound",
                "No mapping found. Enter Steam AppID manually.",
              ),
              "#FFC107",
            );
          }
          if (!mapped) {
            console.warn(tUi("log.platformSteamIdMiss", "steam-id-miss"), {
              appid: appIdValue,
              manual: manualTrigger,
            });
          }
        } catch (err) {
          if (manualTrigger) {
            showNotification(
              tUi("notify.steamAppIdLookupFailed", "Lookup Steam ID failed."),
              "#f44336",
            );
          }
          console.error(
            tUi("log.platformSteamIdLookupError", "steam-id-lookup-error"),
            {
              appid: appIdValue,
              error: err?.message || String(err),
            },
          );
        }
      }

      if (platformSelect) {
        platformSelect.addEventListener("change", async (event) => {
          const nextValue = (event.target.value || "").toLowerCase();
          const showSteamField = nextValue === "uplay";
          toggleSteamAppIdRow(showSteamField);
          if (
            showSteamField &&
            steamAppIdInput &&
            !steamAppIdInput.value.trim()
          ) {
            await lookupSteamAppId(false);
          }
        });
      }

      if (lookupSteamIdBtn) {
        lookupSteamIdBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          await lookupSteamAppId(true);
        });
      }

      let editingConfigName = null;
      let pendingSchemaRefresh = null;

      function resetConfigForm() {
        const form = document.getElementById("new-config-form");
        const button = document.getElementById("createNewConfigBtn");
        const regenBtn = document.getElementById("regenSchemaBtn");
        document.getElementById("configName").value = "";
        document.getElementById("appid").value = "";
        document.getElementById("configPath").value = "";
        document.getElementById("savePath").value = "";
        document.getElementById("executablePath").value = "";
        document.getElementById("exeArgs").value = "";
        document.getElementById("processName").value = "";
        if (platformSelect) {
          platformSelect.value = "auto";
          platformSelect.disabled = false;
          platformSelect.title = "";
        }
        toggleSteamAppIdRow(false);
        if (steamAppIdInput) {
          steamAppIdInput.value = "";
        }

        editingConfigName = null;
        if (regenBtn) regenBtn.style.display = "none";

        if (!form.classList.contains("hidden")) {
          form.classList.add("hidden");
        }

        button.innerHTML = `${tUi(
          "ui.config.createNewBtn",
          "Create New Config",
        )} <span class="arrow-icon">‚ñº</span>`;
        document.getElementById("configFormTitle").textContent = tUi(
          "ui.config.formCreateTitle",
          "Create New Config",
        );
      }

      document
        .getElementById("createNewConfigBtn")
        .addEventListener("click", () => {
          resetConfigForm();
          document.getElementById("configModal").classList.remove("hidden");
          document.getElementById("new-config-form").classList.remove("hidden");
          document.getElementById("configFormTitle").textContent = tUi(
            "ui.config.formCreateTitle",
            "Create New Config",
          );
        });

      async function openEditConfigModalByName(configName) {
        if (!configName) return;
        try {
          if (window.__dashboardOpen) {
            window.closeDashboard?.();
          }
          const currentConfig = await window.api.getConfigByName(configName);

          if (!currentConfig) {
            alert(tUi("alert.configNotFound", "Config not found!"));
            return;
          }

          document.getElementById("configName").value = currentConfig.name;
          document.getElementById("appid").value = currentConfig.appid;
          document.getElementById("configPath").value =
            currentConfig.config_path;
          document.getElementById("savePath").value = currentConfig.save_path;
          document.getElementById("executablePath").value =
            currentConfig.executable || "";
          document.getElementById("exeArgs").value =
            currentConfig.arguments || "";
          document.getElementById("processName").value =
            currentConfig.process_name || "";
          const currentPlatform = (
            currentConfig.platform || "auto"
          ).toLowerCase();
          if (platformSelect) {
            platformSelect.value = [
              "steam",
              "steam-official",
              "uplay",
              "epic",
              "gog",
              "xenia",
              "rpcs3",
              "shadps4",
            ].includes(currentPlatform)
              ? currentPlatform
              : "auto";
            platformSelect.disabled = true;
            platformSelect.title = tUi(
              "tooltip.platformLocked",
              "Platform is locked for existing configs. Create a new config to change it.",
            );
            toggleSteamAppIdRow(platformSelect.value === "uplay");
          }
          if (steamAppIdInput) {
            steamAppIdInput.value = currentConfig.steamAppId || "";
          }

          editingConfigName = currentConfig.name;
          const regenBtn = document.getElementById("regenSchemaBtn");
          if (regenBtn) regenBtn.style.display = "inline-block";
          const form = document.getElementById("new-config-form");
          if (form.style.display !== "block") {
            document.getElementById("configModal").classList.remove("hidden");
          }
          const button = document.getElementById("createNewConfigBtn");

          form.classList.remove("hidden");
          button.innerHTML = `${tUi(
            "ui.config.editing",
            "Editing...",
          )} <span class="arrow-icon rotate-up">‚ñº</span>`;
          document.getElementById("configFormTitle").textContent = tUi(
            "ui.config.formEditTitle",
            "Edit Config",
          );
        } catch (err) {
          console.error(tUi("log.editError", "Edit error:"), err);
          alert(
            tUi(
              "alert.configLoadFailed",
              "Something went wrong loading the config.",
            ),
          );
        }
      }
      window.openEditConfigModalByName = openEditConfigModalByName;

      document
        .getElementById("editConfigBtn")
        .addEventListener("click", async () => {
          const configName = document.getElementById("configList").value;
          if (!configName) return;
          await openEditConfigModalByName(configName);
        });

      document
        .getElementById("selectConfigFolder")
        .addEventListener("click", async () => {
          const selectedPath = await window.api.selectFolder();
          if (selectedPath) {
            document.getElementById("configPath").value = selectedPath;
          }
        });

      document
        .getElementById("selectSaveFolder")
        .addEventListener("click", async () => {
          const selectedPath = await window.api.selectFolder();
          if (selectedPath) {
            document.getElementById("savePath").value = selectedPath;
          }
        });

      document.getElementById("saveBtn").addEventListener("click", async () => {
        const configName = document.getElementById("configName").value;
        const appid = document.getElementById("appid").value;
        const configPath = document.getElementById("configPath").value;
        const savePath = document.getElementById("savePath").value;
        const executable = document.getElementById("executablePath").value;
        const arguments = document.getElementById("exeArgs").value;
        const processName = document.getElementById("processName").value;
        const selectedPlatform = platformSelect?.value?.toLowerCase() || "auto";
        const steamAppId = steamAppIdInput?.value.trim() || "";

        if (!configName || !appid) {
          const notif = document.createElement("div");
          notif.textContent = tUi(
            "alert.nameAppIdRequired",
            "Name and AppID are required!",
          );
          notif.style.position = "fixed";
          notif.style.top = "100px";
          notif.style.left = "50%";
          notif.style.transform = "translateX(-50%)";
          notif.style.backgroundColor = "#f44336";
          notif.style.color = "white";
          notif.style.padding = "10px 20px";
          notif.style.borderRadius = "5px";
          notif.style.boxShadow = "0px 2px 8px rgba(0,0,0,0.3)";
          notif.style.zIndex = 9999;
          notif.style.fontWeight = "bold";
          notif.style.fontFamily = "sans-serif";

          document.body.appendChild(notif);
          setTimeout(() => notif.remove(), 3000);
          return;
        }

        try {
          const check = await window.api.isAppIdBlacklisted(appid);
          if (check?.blacklisted) {
            showNotification(
              tUiFmt(
                "alert.appidBlacklisted",
                { appid: check.appid },
                `${check.appid} is on Blacklist. Please remove it to continue.`,
              ),
              "#f44336",
            );
            return;
          }
        } catch (err) {
          console.error(
            tUi("log.blacklistCheckFailed", "Blacklist check failed:"),
            err,
          );
        }

        const config = {
          name: configName,
          appid: appid,
          config_path: configPath || null,
          save_path: savePath || null,
          executable: executable || null,
          arguments: arguments || "",
          process_name: processName || "",
        };
        if (selectedPlatform && selectedPlatform !== "auto") {
          config.platform = selectedPlatform;
        }
        if (steamAppId) {
          config.steamAppId = steamAppId;
        }

        const result =
          editingConfigName && editingConfigName !== configName
            ? await window.api.renameAndSaveConfig(editingConfigName, config)
            : await window.api.saveConfig(config);

        showNotification(
          result.message,
          result.success ? "#4CAF50" : "#f44336",
        );

        if (result.success) {
          const cacheOldName =
            editingConfigName && editingConfigName !== configName
              ? editingConfigName
              : null;
          window.__clearDashboardCachesFor?.(configName);
          if (cacheOldName) {
            window.__clearDashboardCachesFor?.(cacheOldName);
          }
          editingConfigName = null;
          document.getElementById("createNewConfigBtn").innerText = tUi(
            "ui.config.createNewBtn",
            "Create New Config",
          );
          localStorage.setItem("configSavedMessage", result.message);
          localStorage.setItem(
            "configSavedSuccess",
            result.success ? "true" : "false",
          );

          window.location.reload();
        }
      });

      const regenSchemaBtn = document.getElementById("regenSchemaBtn");
      if (regenSchemaBtn) {
        regenSchemaBtn.addEventListener("click", async () => {
          const configName = document.getElementById("configName").value;
          const appid = document.getElementById("appid").value;
          const selectedPlatform =
            platformSelect?.value?.toLowerCase() || "auto";

          if (!configName || !appid) {
            showNotification(
              tUi("alert.nameAppIdRequired", "Name and AppID are required!"),
              "#f44336",
            );
            return;
          }
          if (editingConfigName && editingConfigName !== configName) {
            showNotification(
              tUi(
                "alert.saveRenamedConfigFirst",
                "Save the renamed config before regenerating the schema.",
              ),
              "#FFC107",
            );
            return;
          }

          try {
            const check = await window.api.isAppIdBlacklisted(appid);
            if (check?.blacklisted) {
              showNotification(
                tUiFmt(
                  "alert.appidBlacklisted",
                  { appid: check.appid },
                  `${check.appid} is on Blacklist. Please remove it to continue.`,
                ),
                "#f44336",
              );
              return;
            }
          } catch (err) {
            console.error(
              tUi("log.blacklistCheckFailed", "Blacklist check failed:"),
              err,
            );
          }

          try {
            pendingSchemaRefresh = {
              appid: String(appid).trim(),
              name: editingConfigName || configName,
            };
            document.getElementById("closeConfigModal")?.click();

            const result = await window.api.regenerateSchema({
              name: editingConfigName || configName,
              appid,
              platform: selectedPlatform,
            });
            showNotification(
              result?.message ||
                tUi(
                  "notify.schemaRegenerateFinished",
                  "Schema regeneration finished.",
                ),
              result?.success ? "#4CAF50" : "#f44336",
            );
            if (result?.config_path) {
              document.getElementById("configPath").value = result.config_path;
            }
            if (result?.success) {
              const targetName = editingConfigName || configName;
              const lang =
                document.getElementById("languageSelect")?.value || "english";
              const list = document.getElementById("configList");
              if (list) {
                list.value = targetName;
                list.dispatchEvent(new Event("change", { bubbles: true }));
              } else {
                const preset =
                  document.getElementById("presetDropdown")?.value || "default";
                const position =
                  document.getElementById("positionDropdown")?.value ||
                  "center-bottom";
                window.api.updateConfig({
                  configName: targetName,
                  preset,
                  position,
                });
              }
              try {
                await buildMainAchievementsTable(targetName, lang);
              } catch (err) {
                console.error(
                  tUi(
                    "log.refreshAchievementsFailed",
                    "Refresh achievements table failed:",
                  ),
                  err,
                );
              }
            }
          } catch (err) {
            console.error(
              tUi("log.schemaRegenerateFailed", "Regenerate schema failed:"),
              err,
            );
            showNotification(
              tUi(
                "alert.schemaRegenerateFailed",
                "Failed to regenerate schema.",
              ),
              "#f44336",
            );
          }
        });
      }

      window.api.onSchemaReady(async (data) => {
        if (!pendingSchemaRefresh) return;
        const appidMatch =
          data?.appid &&
          pendingSchemaRefresh.appid &&
          String(data.appid) === pendingSchemaRefresh.appid;
        const nameMatch =
          data?.name &&
          pendingSchemaRefresh.name &&
          String(data.name) === pendingSchemaRefresh.name;
        if (!(appidMatch || nameMatch)) return;
        const targetName = pendingSchemaRefresh.name;
        pendingSchemaRefresh = null;

        try {
          if (typeof reloadConfigsDropdown === "function") {
            await reloadConfigsDropdown(true);
          }
        } catch (err) {
          console.error(
            tUi(
              "log.reloadConfigsAfterSchemaFailed",
              "Reload configs after schema failed:",
            ),
            err,
          );
        }

        const lang =
          document.getElementById("languageSelect")?.value || "english";
        const selected =
          typeof window.selectConfigInDropdown === "function"
            ? window.selectConfigInDropdown(targetName)
            : false;
        if (selected) {
          try {
            await buildMainAchievementsTable(targetName, lang);
          } catch (err) {
            console.error(
              tUi(
                "log.refreshAchievementsFailed",
                "Refresh achievements table failed:",
              ),
              err,
            );
          }
        }
      });

      document
        .getElementById("toggleBtn")
        .addEventListener("click", function () {
          let container = document.getElementById("buttonContainer");
          if (container.classList.contains("hidden")) {
            container.classList.remove("hidden");
            container.style.display = "flex";
            this.textContent = tUi("ui.toggle.hideOptions", "Hide Options");
          } else {
            container.classList.add("hidden");
            container.style.display = "none";
            this.textContent = tUi("ui.toggle.showOptions", "Show Options");
          }
        });

      document
        .getElementById("selectExecutable")
        .addEventListener("click", async () => {
          const selectedExe = await window.api.selectExecutable();
          if (selectedExe) {
            document.getElementById("executablePath").value = selectedExe;
          }
        });

      document.getElementById("playBtn").addEventListener("click", async () => {
        const name = document.getElementById("configList")?.value;
        if (!name) return;
        const config = await window.api.getConfigByName(name);
        if (config?.executable) {
          const args = config.arguments || "";
          await window.api.launchExecutable(config.executable, args);
        }
      });

      const languageSelect = document.getElementById("languageSelect");
      const appLanguageSelect = document.getElementById("appLanguageSelect");
      let uiLanguage = "english";
      let achievementLanguageManual = false;
      let syncingAchievementLanguage = false;

      const normalizeLangValue = (value) => {
        const raw = String(value || "").trim();
        if (!raw) return "english";
        return raw === "LATAM" ? "latam" : raw.toLowerCase();
      };

      const syncAppLanguageOptions = () => {
        if (!languageSelect || !appLanguageSelect) return;
        appLanguageSelect.innerHTML = languageSelect.innerHTML;
      };

      async function applyUiLanguage(lang) {
        const prevLang = uiLanguage;
        uiLanguage = normalizeLangValue(lang);
        if (
          window.i18nUi &&
          typeof window.i18nUi.setUiLanguage === "function"
        ) {
          await window.i18nUi.setUiLanguage(uiLanguage);
        }
        syncAppLanguageOptions();
        if (appLanguageSelect) appLanguageSelect.value = uiLanguage;
        if (typeof updateSortIconsUI === "function") {
          updateSortIconsUI();
        }
        if (typeof window.refreshFoldersList === "function") {
          window.refreshFoldersList();
        }
        if (typeof window.refreshBlacklistList === "function") {
          window.refreshBlacklistList();
        }
        if (typeof window.refreshShortcutLabel === "function") {
          window.refreshShortcutLabel();
        }
        if (typeof window.refreshInteractShortcutLabel === "function") {
          window.refreshInteractShortcutLabel();
        }
        if (typeof window.refreshInteractShortcutInfo === "function") {
          window.refreshInteractShortcutInfo();
        }
        if (typeof window.refreshBootLoadingText === "function") {
          window.refreshBootLoadingText();
        }
        if (window.__dashboardOpen && typeof buildDashboard === "function") {
          await buildDashboard();
        }
        if (window.api?.refreshUILanguage && uiLanguage !== prevLang) {
          const configName = document.getElementById("configList")?.value;
          window.api.refreshUILanguage({
            uiLanguage,
            configName: configName || null,
          });
        }
      }

      async function applyAchievementLanguage(lang, opts = {}) {
        const normalized = normalizeLangValue(lang);
        const configName = document.getElementById("configList").value;
        const payload = { language: normalized };
        if (opts.manual === true) {
          payload.achievementLanguageManual = true;
          achievementLanguageManual = true;
        }
        syncingAchievementLanguage = true;
        if (languageSelect) languageSelect.value = normalized;
        syncingAchievementLanguage = false;
        await window.api.savePreferences(payload);
        window.api.refreshUILanguage({
          language: normalized,
          configName,
          uiLanguage,
        });
        if (configName) {
          await buildMainAchievementsTable(configName, normalized);
        }
        localStorage.setItem("preferredLanguage", normalized);
      }

      if (appLanguageSelect) {
        appLanguageSelect.addEventListener("change", async (e) => {
          const selectedLang = normalizeLangValue(e.target.value);
          await window.api.savePreferences({ uiLanguage: selectedLang });
          await applyUiLanguage(selectedLang);
          if (!achievementLanguageManual) {
            await applyAchievementLanguage(selectedLang, { manual: false });
          }
        });
      }

      if (languageSelect) {
        languageSelect.addEventListener("change", async (e) => {
          if (syncingAchievementLanguage) return;
          const selectedLang = normalizeLangValue(e.target.value);
          await applyAchievementLanguage(selectedLang, { manual: true });
        });
      }
      function getLocalizedText(obj, lang = "english") {
        if (!obj) return "";
        if (typeof obj === "string") return obj;
        return obj[lang] || obj["english"] || "";
      }

      const presetDropdown = document.getElementById("presetDropdown");
      const positionDropdown = document.getElementById("positionDropdown");
      const configList = document.getElementById("configList");
      const deleteConfigBtn = document.getElementById("deleteConfigBtn");
      const editConfigBtn = document.getElementById("editConfigBtn");
      const backButton = document.getElementById("backButton");
      const blacklistConfigBtn = document.getElementById("blacklistConfigBtn");
      const muteProgressRow = document.getElementById("muteProgressRow");
      const muteProgressCheckbox = document.getElementById(
        "muteProgressCheckbox",
      );
      const showBlacklistedCheckbox = document.getElementById(
        "settings-showBlacklistedCheckbox",
      );
      const resetBlacklistBtn = document.getElementById(
        "settings-resetBlacklistBtn",
      );

      const configMetaIndex = new Map();
      const blacklistState = {
        appids: new Set(),
        showBlacklisted: false,
      };
      let lastSelectedConfigMeta = null;

      function normalizeConfigEntry(entry) {
        if (!entry) return null;
        if (typeof entry === "string") {
          return {
            name: entry,
            displayName: entry,
            appid: null,
            platform: null,
            blacklisted: false,
            executable: null,
            arguments: "",
            process_name: "",
          };
        }
        const name = entry.name || entry.configName || "";
        if (!name) return null;
        return {
          name,
          displayName:
            entry.displayName || entry.title || entry.name || entry.configName,
          appid: entry.appid ? String(entry.appid) : null,
          platform: entry.platform || null,
          blacklisted: !!entry.blacklisted,
          executable: entry.executable || null,
          arguments: entry.arguments || "",
          process_name: entry.process_name || entry.processName || "",
        };
      }

      function normalizeConfigList(list) {
        return Array.isArray(list)
          ? list
              .map((item) => normalizeConfigEntry(item))
              .filter((item) => item && item.name)
          : [];
      }

      function cacheConfigMeta(list) {
        configMetaIndex.clear();
        list.forEach((cfg) => {
          if (cfg && cfg.name) {
            configMetaIndex.set(cfg.name, cfg);
          }
        });
      }

      function isAppIdInBlacklist(appid) {
        if (!appid) return false;
        return blacklistState.appids.has(String(appid));
      }

      async function syncBlacklistList() {
        try {
          const res = await window.api.getBlacklist();
          blacklistState.appids = new Set(res?.appids || []);
        } catch (err) {
          console.warn(
            tUi("log.blacklistLoadFailed", "Failed to load blacklist:"),
            err,
          );
          blacklistState.appids = new Set();
        }
      }

      function resolveBlacklistName(appid) {
        if (!appid) return null;
        // Prefer cached meta by appid
        for (const meta of configMetaIndex.values()) {
          if (!meta?.appid) continue;
          if (String(meta.appid) === String(appid)) {
            return (
              meta.displayName ||
              meta.name ||
              meta.appid ||
              meta.appId ||
              `App ${appid}`
            );
          }
        }
        if (
          lastSelectedConfigMeta &&
          String(lastSelectedConfigMeta.appid || "") === String(appid || "")
        ) {
          return (
            lastSelectedConfigMeta.displayName ||
            lastSelectedConfigMeta.name ||
            `App ${appid}`
          );
        }
        return null;
      }

      async function renderBlacklistList() {
        const listEl = document.getElementById("blacklistList");
        if (!listEl) return;
        listEl.innerHTML = "";

        const entries = Array.from(blacklistState.appids || []);
        if (entries.length === 0) {
          listEl.innerHTML = `<div style="padding:10px; color:#aaa;"><small>${tUi(
            "blacklist.empty",
            "No blacklisted apps.",
          )}</small></div>`;
          return;
        }

        // Build a map appid -> displayName from cached configs
        const nameById = new Map();
        configMetaIndex.forEach((cfg) => {
          if (cfg?.appid) {
            const id = String(cfg.appid);
            const name =
              cfg.displayName ||
              cfg.name ||
              cfg.appid ||
              cfg.appId ||
              `App ${id}`;
            nameById.set(id, name);
          }
        });

        for (const appid of entries) {
          const row = document.createElement("div");
          row.className = "wf-row";
          row.setAttribute("role", "listitem");
          row.dataset.appid = appid;

          const pathEl = document.createElement("div");
          pathEl.className = "wf-path";
          const cachedLabel = blacklistLabelCache.get(appid);
          const label =
            cachedLabel ||
            nameById.get(appid) ||
            resolveBlacklistName(appid) ||
            `App ${appid}`;
          pathEl.textContent = `${appid} ‚Äî ${label}`;
          pathEl.title = pathEl.textContent;

          const actions = document.createElement("div");
          actions.className = "wf-actions";

          const btnRemove = document.createElement("button");
          btnRemove.className = "icon-btn remove";
          btnRemove.title = tUi(
            "tooltip.blacklistRemove",
            "Remove from blacklist",
          );
          btnRemove.innerHTML = faWithFallback("fa-regular fa-trash-can", "üóë");
          btnRemove.addEventListener("click", async () => {
            try {
              await window.api.blacklistConfig({
                appid,
                remove: true,
              });
              await syncBlacklistList();
              renderBlacklistList();
              await reloadConfigsDropdown(true);
              if (typeof buildDashboard === "function") {
                await buildDashboard();
              }
            } catch (err) {
              console.error(
                tUi(
                  "log.blacklistRemoveFailed",
                  "Failed to remove from blacklist:",
                ),
                err,
              );
              alert(
                tUi(
                  "alert.blacklistRemoveFailed",
                  "Failed to remove this AppID from blacklist.",
                ),
              );
            }
          });

          actions.appendChild(btnRemove);
          row.appendChild(pathEl);
          row.appendChild(actions);
          listEl.appendChild(row);

          // Async resolve label from config if missing
          if (
            !cachedLabel &&
            (!nameById.has(appid) || label === `App ${appid}`)
          ) {
            (async () => {
              try {
                const res = await window.api.getConfigByAppId(appid);
                const fetchedLabel =
                  res?.displayName || res?.name || `App ${appid}`;
                blacklistLabelCache.set(appid, fetchedLabel);
                const currentRow = listEl.querySelector(
                  `.wf-row[data-appid="${appid}"] .wf-path`,
                );
                if (currentRow) {
                  currentRow.textContent = `${appid} ‚Äî ${fetchedLabel}`;
                  currentRow.title = currentRow.textContent;
                }
              } catch {}
            })();
          }
        }
      }
      window.refreshBlacklistList = renderBlacklistList;

      function applyShowBlacklistPreference(value) {
        const next = !!value;
        blacklistState.showBlacklisted = next;
        if (showBlacklistedCheckbox) {
          showBlacklistedCheckbox.checked = next;
        }
        renderBlacklistList();
      }

      function updateBlacklistButtonState(appid) {
        if (!blacklistConfigBtn) return;
        if (!appid) {
          blacklistConfigBtn.disabled = true;
          blacklistConfigBtn.textContent = tUi(
            "dashboardMenuIgnore",
            "Ignore Game",
          );
          return;
        }
        blacklistConfigBtn.disabled = false;
        const isBlacklisted = isAppIdInBlacklist(appid);
        if (blacklistState.showBlacklisted && isBlacklisted) {
          blacklistConfigBtn.textContent = tUi(
            "dashboardMenuRemoveBlacklist",
            "Remove from Blacklist",
          );
        } else {
          blacklistConfigBtn.textContent = tUi(
            "dashboardMenuIgnore",
            "Ignore Game",
          );
        }
      }

      const confirmModal = document.getElementById("appConfirmModal");
      const confirmTitleEl = document.getElementById("appConfirmTitle");
      const confirmMessageEl = document.getElementById("appConfirmMessage");
      const confirmCheckboxRow = document.getElementById(
        "appConfirmCheckboxRow",
      );
      const confirmCheckbox = document.getElementById("appConfirmCheckbox");
      const confirmCheckboxLabel = document.getElementById(
        "appConfirmCheckboxLabel",
      );
      const confirmCheckboxRow2 = document.getElementById(
        "appConfirmCheckboxRow2",
      );
      const confirmCheckbox2 = document.getElementById("appConfirmCheckbox2");
      const confirmCheckboxLabel2 = document.getElementById(
        "appConfirmCheckboxLabel2",
      );
      const confirmOkBtn = document.getElementById("appConfirmOkBtn");
      const confirmCancelBtn = document.getElementById("appConfirmCancelBtn");
      let confirmResolve = null;
      let confirmLastFocus = null;
      let confirmCheckboxValue = false;
      let confirmCheckboxValue2 = false;
      const tUi = (key, fallback) =>
        window.i18nUi && typeof window.i18nUi.getString === "function"
          ? window.i18nUi.getString(key, fallback)
          : fallback;

      function closeAppConfirm(result) {
        if (!confirmModal || !confirmResolve) return;
        const resolver = confirmResolve;
        confirmResolve = null;
        confirmModal.classList.add("hidden");
        confirmModal.setAttribute("aria-hidden", "true");
        confirmModal.inert = false;
        document.body.classList.remove("modal-open");
        if (confirmCheckboxRow && confirmCheckbox) {
          confirmCheckboxValue = !confirmCheckboxRow.classList.contains(
            "hidden",
          )
            ? confirmCheckbox.checked === true
            : false;
          confirmCheckboxRow.classList.add("hidden");
          confirmCheckbox.checked = false;
          if (confirmCheckboxLabel) confirmCheckboxLabel.textContent = "";
        } else {
          confirmCheckboxValue = false;
        }
        if (confirmCheckboxRow2 && confirmCheckbox2) {
          confirmCheckboxValue2 = !confirmCheckboxRow2.classList.contains(
            "hidden",
          )
            ? confirmCheckbox2.checked === true
            : false;
          confirmCheckboxRow2.classList.add("hidden");
          confirmCheckbox2.checked = false;
          if (confirmCheckboxLabel2) confirmCheckboxLabel2.textContent = "";
        } else {
          confirmCheckboxValue2 = false;
        }
        if (confirmLastFocus && typeof confirmLastFocus.focus === "function") {
          try {
            confirmLastFocus.focus();
          } catch {}
        }
        confirmLastFocus = null;
        resolver(result);
      }

      async function showAppConfirm(opts = {}) {
        if (
          !confirmModal ||
          !confirmTitleEl ||
          !confirmMessageEl ||
          !confirmOkBtn ||
          !confirmCancelBtn
        ) {
          return window.confirm(
            opts?.message ||
              tUi("main.dialog.confirm.message", "Are you sure?"),
          );
        }

        if (confirmResolve) {
          closeAppConfirm(false);
        }

        try {
          await safeRefocus();
        } catch {}

        confirmLastFocus = document.activeElement;
        confirmTitleEl.textContent =
          opts.title || tUi("appConfirmTitle", "Confirm");
        confirmMessageEl.textContent =
          opts.message || tUi("main.dialog.confirm.message", "Are you sure?");
        confirmOkBtn.textContent = opts.okText || tUi("appConfirmOkBtn", "OK");
        confirmCancelBtn.textContent =
          opts.cancelText || tUi("appConfirmCancelBtn", "Cancel");
        if (confirmCheckboxRow && confirmCheckbox && confirmCheckboxLabel) {
          if (opts.checkboxLabel) {
            confirmCheckboxLabel.textContent = opts.checkboxLabel;
            confirmCheckbox.checked = opts.checkboxDefault === true;
            confirmCheckboxRow.classList.remove("hidden");
          } else {
            confirmCheckboxRow.classList.add("hidden");
            confirmCheckbox.checked = false;
            confirmCheckboxLabel.textContent = "";
          }
        }
        if (confirmCheckboxRow2 && confirmCheckbox2 && confirmCheckboxLabel2) {
          if (opts.checkboxLabel2) {
            confirmCheckboxLabel2.textContent = opts.checkboxLabel2;
            confirmCheckbox2.checked = opts.checkboxDefault2 === true;
            confirmCheckboxRow2.classList.remove("hidden");
          } else {
            confirmCheckboxRow2.classList.add("hidden");
            confirmCheckbox2.checked = false;
            confirmCheckboxLabel2.textContent = "";
          }
        }
        confirmModal.inert = false;
        confirmModal.classList.remove("hidden");
        confirmModal.setAttribute("aria-hidden", "false");
        document.body.classList.add("modal-open");
        confirmOkBtn.focus();

        return new Promise((resolve) => {
          confirmResolve = resolve;
        });
      }

      if (confirmOkBtn) {
        confirmOkBtn.addEventListener("click", () => closeAppConfirm(true));
      }
      if (confirmCancelBtn) {
        confirmCancelBtn.addEventListener("click", () =>
          closeAppConfirm(false),
        );
      }
      if (confirmModal) {
        confirmModal.addEventListener("click", (event) => {
          if (event.target === confirmModal) {
            closeAppConfirm(false);
          }
        });
      }
      document.addEventListener("keydown", (event) => {
        if (!confirmResolve) return;
        if (event.key === "Escape") {
          event.preventDefault();
          closeAppConfirm(false);
        }
        if (event.key === "Enter") {
          event.preventDefault();
          closeAppConfirm(true);
        }
      });

      function logUiEvent(level, message, meta) {
        try {
          const safeLevel = level || "info";
          window.api?.logUiEvent?.(safeLevel, message, meta);
        } catch {}
      }

      async function safeConfirm(opts) {
        logUiEvent("info", "ui:confirm:start", {
          title: opts?.title || "",
          message: opts?.message || "",
        });
        try {
          const result = await showAppConfirm(opts);
          logUiEvent("info", "ui:confirm:result", { result });
          return result;
        } catch (err) {
          logUiEvent("warn", "ui:confirm-failed", {
            message: err?.message || String(err),
          });
        }
        try {
          const message = opts?.message || "Are you sure?";
          const result = window.confirm(message);
          logUiEvent("info", "ui:confirm:fallback-result", { result });
          return result;
        } catch {
          return false;
        }
      }

      async function safeConfirmWithCheckbox(opts) {
        logUiEvent("info", "ui:confirm:start", {
          title: opts?.title || "",
          message: opts?.message || "",
          checkbox: !!opts?.checkboxLabel,
        });
        try {
          const result = await showAppConfirm(opts);
          const checked = confirmCheckboxValue === true;
          const checked2 = confirmCheckboxValue2 === true;
          logUiEvent("info", "ui:confirm:result", {
            result,
            checked,
            checked2,
          });
          return { confirmed: result === true, checked, checked2 };
        } catch (err) {
          logUiEvent("warn", "ui:confirm-failed", {
            message: err?.message || String(err),
          });
        }
        try {
          const message = opts?.message || "Are you sure?";
          const result = window.confirm(message);
          logUiEvent("info", "ui:confirm:fallback-result", { result });
          return {
            confirmed: result === true,
            checked: false,
            checked2: false,
          };
        } catch {
          return { confirmed: false, checked: false, checked2: false };
        }
      }

      async function safeRefocus() {
        try {
          if (window.ui?.refocus) {
            logUiEvent("info", "ui:refocus:start");
            await window.ui.refocus();
          }
        } catch (err) {
          console.warn(tUi("log.refocusFailed", "Refocus failed:"), err);
          logUiEvent("warn", "ui:refocus-failed", {
            message: err?.message || String(err),
          });
        }
      }

      function logUiError(label, err) {
        const message =
          err && typeof err === "object"
            ? err.message || String(err)
            : String(err || "");
        const stack =
          err && typeof err === "object" && err.stack ? err.stack : undefined;
        try {
          window.api?.logUiEvent?.("error", label, { message, stack });
        } catch {}
        try {
          console.error(label, err);
        } catch {}
      }

      window.addEventListener("error", (event) => {
        logUiError("ui:error", event?.error || event?.message || event);
      });

      window.addEventListener("unhandledrejection", (event) => {
        logUiError("ui:unhandled-rejection", event?.reason || event);
      });

      function normalizeProgressMutePath(value) {
        if (!value) return "";
        return String(value).trim().replace(/\//g, "\\").toLowerCase();
      }

      function buildProgressMuteKey(configPath, configName) {
        if (configPath) return `path:${normalizeProgressMutePath(configPath)}`;
        if (configName) return `name:${String(configName)}`;
        return "";
      }

      async function resolveProgressMuteKey() {
        const selectedName = configList?.value || "";
        if (!selectedName) return "";
        let cfg = lastSelectedConfigMeta;
        if (!cfg || cfg.name !== selectedName) {
          try {
            cfg = await window.api.getConfigByName(selectedName);
          } catch {
            cfg = null;
          }
        }
        return buildProgressMuteKey(
          cfg?.config_path || cfg?.configPath || "",
          selectedName,
        );
      }

      async function updateMuteProgressUI() {
        if (!muteProgressRow || !muteProgressCheckbox) return;
        const selectedName = configList?.value || "";
        if (!selectedName) {
          muteProgressRow.style.display = "none";
          muteProgressCheckbox.checked = false;
          return;
        }
        try {
          await loadPreferencesCached();
        } catch {}
        const key = await resolveProgressMuteKey();
        const prefs = getCachedPreferences() || {};
        const list = Array.isArray(prefs.progressMutedConfigs)
          ? prefs.progressMutedConfigs
          : [];
        muteProgressCheckbox.checked = key ? list.includes(key) : false;
        muteProgressRow.style.display = "flex";
      }

      function updateMainConfig() {
        const selectedConfig = configList.value;
        const preset = presetDropdown.value;
        const position = positionDropdown.value;

        if (selectedConfig) {
          window.api.updateConfig({
            configName: selectedConfig,
            preset: preset,
            position: position,
          });
        }
      }

      async function deleteConfigByName(configName, displayName = "") {
        if (!configName) return;
        const label = displayName || configName;
        const confirmDelete = await safeConfirmWithCheckbox({
          title: tUi("confirm.deleteConfig.title", "Delete config"),
          message: tUiFmt(
            "confirm.deleteConfig.message",
            { name: label },
            `Do you want to delete: ${label}?`,
          ),
          checkboxLabel: tUi(
            "confirm.deleteConfig.deleteExtras",
            "Do you want to delete also the Schema, Cache and Images?",
          ),
          checkboxLabel2: tUi(
            "confirm.deleteConfig.deleteSave",
            "Do you want to delete save data from the save path?",
          ),
        });
        if (!confirmDelete?.confirmed) return;

        await safeRefocus();

        try {
          const wasSelected = configList?.value === configName;
          const response = await window.api.deleteConfig(configName, {
            deleteExtras: confirmDelete.checked === true,
            deleteSaveFiles: confirmDelete.checked2 === true,
          });
          if (response?.success) {
            if (typeof reloadConfigsDropdown === "function") {
              await reloadConfigsDropdown(true);
            }

            if (wasSelected && configList) {
              configList.value = "";
              document.getElementById("backButton").style.display = "none";

              const selectOption = configList.querySelector('option[value=""]');
              if (selectOption) {
                selectOption.selected = true;
                selectOption.disabled = true;
              }

              document.getElementById("deleteConfigBtn").style.display = "none";
              document.getElementById("blacklistConfigBtn").style.display =
                "none";
              document.getElementById("editConfigBtn").style.display = "none";
              document.getElementById("playBtn").style.display = "none";
              document.getElementById("achStats").style.display = "none";
              updateMuteProgressUI().catch(() => {});
              resetConfigForm();

              const tableBody = document.getElementById(
                "achievementsTableBody",
              );
              if (tableBody) tableBody.innerHTML = "";

              window.api.updateConfig({
                configName: null,
                preset: null,
                position: null,
              });
              window.api.toggleOverlay(null);
              window.api.onLoadOverlayData(null);
              window.__showFallbackLogo?.();
              window.__setEmbeddedPlatinumBadgeByConfig?.(null);
            }

            if (typeof buildDashboard === "function") {
              await buildDashboard();
            }
          } else {
            console.error(
              tUi("log.deleteError", "Error on delete:"),
              response?.error || response,
            );
          }
        } catch (error) {
          console.error(tUi("log.deleteError", "Error on delete:"), error);
        }
      }
      window.deleteConfigByName = deleteConfigByName;

      presetDropdown.addEventListener("change", updateMainConfig);

      positionDropdown.addEventListener("change", updateMainConfig);

      configList.addEventListener("change", updateMainConfig);

      if (muteProgressCheckbox) {
        muteProgressCheckbox.addEventListener("change", async () => {
          const key = await resolveProgressMuteKey();
          if (!key) return;
          await loadPreferencesCached();
          const prefs = getCachedPreferences() || {};
          const list = Array.isArray(prefs.progressMutedConfigs)
            ? [...prefs.progressMutedConfigs]
            : [];
          const hasKey = list.includes(key);
          let next = list;
          if (muteProgressCheckbox.checked && !hasKey) {
            next = [...list, key];
          } else if (!muteProgressCheckbox.checked && hasKey) {
            next = list.filter((item) => item !== key);
          }
          await window.api.savePreferences({ progressMutedConfigs: next });
          await updateMuteProgressUI();
        });
      }

      function getSafeLocalizedText(input, lang = "english") {
        if (!input) return "Hidden";
        if (typeof input === "string") return input.trim() || "Hidden";
        if (typeof input === "object") {
          return (
            input[lang] ||
            input.english ||
            Object.values(input).find(
              (v) => typeof v === "string" && v.trim() !== "",
            ) ||
            "Hidden"
          );
        }
        return "Hidden";
      }

      window.addEventListener("DOMContentLoaded", async () => {
        try {
          await syncBlacklistList();
          const configsRaw = await window.api.loadConfigs();
          const configs = normalizeConfigList(configsRaw);
          cacheConfigMeta(configs);
          rememberCoverNamesFromList(configs);
          const configList = document.getElementById("configList");
          if (configList) {
            configList.innerHTML =
              '<option value="" disabled selected>Select</option>';
            const visibleConfigs = blacklistState.showBlacklisted
              ? configs
              : configs.filter((cfg) => !isAppIdInBlacklist(cfg.appid));
            visibleConfigs.forEach((config) => {
              const option = document.createElement("option");
              option.value = config.name;
              option.textContent = config.displayName || config.name;
              if (isAppIdInBlacklist(config.appid)) {
                option.textContent += " (Ignored)";
              }
              configList.appendChild(option);
            });
          }
        } catch (error) {
          console.error(
            tUi("log.configLoadError", "Config Load Error:"),
            error,
          );
        } finally {
          window.__uiConfigsReady = true;
          window.__markUiDataReady?.();
        }

        function formatTimestamp(timestamp) {
          if (!timestamp) return "N/A";
          const date = new Date(timestamp * 1000);
          return date.toLocaleString();
        }

        configList.addEventListener("change", async () => {
          const selectedConfig = configList.value;
          if (!selectedConfig) {
            lastSelectedConfigMeta = null;
            updateBlacklistButtonState(null);
            const tableBody = document.querySelector("#achievementsTableBody");
            if (tableBody) tableBody.innerHTML = "";
            const achStats = document.getElementById("achStats");
            if (achStats) achStats.style.display = "none";
            const playBtn = document.getElementById("playBtn");
            if (playBtn) playBtn.style.display = "none";
            setAchievementsHeaderVisible(false);
            window.__showFallbackLogo?.();
            window.__setEmbeddedPlatinumBadgeByConfig?.(null);
            updateMuteProgressUI().catch(() => {});
            return;
          }
          window.__setEmbeddedPlatinumBadgeByConfig?.(null);
          const cachedMeta = configMetaIndex.get(selectedConfig) || null;
          const blocked =
            !!cachedMeta?.appid &&
            blacklistState.appids.has(String(cachedMeta.appid));

          updateBlacklistButtonState(cachedMeta?.appid || null);

          if (selectedConfig && !blocked) {
            window.api.updateConfig({
              configName: selectedConfig,
              preset: presetDropdown.value,
              position: positionDropdown.value,
            });
          }
          const achievementsDataObj =
            await window.api.loadAchievementData(selectedConfig);
          const savedAchievementsObj =
            await window.api.loadSavedAchievements(selectedConfig);
          const currentConfig =
            await window.api.getConfigByName(selectedConfig);
          maybeRequestPlatinum(
            currentConfig,
            achievementsDataObj?.achievements || [],
            savedAchievementsObj,
          );
          lastSelectedConfigMeta = currentConfig || null;
          window.__setEmbeddedPlatinumBadgeByConfig?.(currentConfig || null);
          updateBlacklistButtonState(currentConfig?.appid || null);
          if (currentConfig?.appid) {
            const resolvedName =
              currentConfig.displayName ||
              currentConfig.name ||
              currentConfig.appid;
            rememberCoverName(currentConfig.appid, resolvedName);
            window.__showFallbackLogo?.();
            window
              .__applyEmbeddedGameImageForAppId(currentConfig.appid)
              ?.catch(() => {});
          } else {
            window.__showFallbackLogo?.();
          }
          const playBtn = document.getElementById("playBtn");
          if (playBtn)
            playBtn.style.display = currentConfig?.executable && 
                  window.electron.platform() !== "linux"
              ? "inline-block"
              : "none";

          const tableBody = document.querySelector("#achievementsTableBody");
          if (tableBody) {
            tableBody.innerHTML = "";
          } else {
            console.error(
              tUi("log.tableBodyMissing", "Table body could not be found."),
            );
            return;
          }

          if (achievementsDataObj.error) {
            setAchievementsHeaderVisible(false);
            alert(achievementsDataObj.error);
            return;
          }

          if (!Array.isArray(achievementsDataObj.achievements)) {
            setAchievementsHeaderVisible(false);
            if (achievementsDataObj.achievements == null) {
              const achStats = document.getElementById("achStats");
              if (achStats) achStats.style.display = "none";
              const playtimeLabel = document.getElementById("achStatsPlaytime");
              const lastPlayedLabel =
                document.getElementById("achStatsLastPlayed");
              if (playtimeLabel)
                playtimeLabel.textContent = tUiFmt(
                  "achStatsPlaytimeFmt",
                  { value: "0m" },
                  "Playtime: 0m",
                );
              if (lastPlayedLabel) {
                lastPlayedLabel.textContent = tUiFmt(
                  "achStatsLastPlayedFmt",
                  { value: "N/A" },
                  "Last Played: N/A",
                );
              }
              return;
            }
            console.warn(
              "Achievements payload is not an array; skipping table render.",
            );
            return;
          }

          const lang = document.getElementById("languageSelect").value;
          await buildMainAchievementsTable(selectedConfig, lang);

          const statsArray = achievementsDataObj.achievements.map((a) => {
            const saved = savedAchievementsObj?.achievements?.[a.name];
            return { ...a, earned: !!saved?.earned };
          });
          updateAchievementStats(statsArray);
          const achStatsEl = document.getElementById("achStats");
          if (achStatsEl) achStatsEl.style.display = "block";
          updateMuteProgressUI().catch(() => {});
        });
      });

      window.addEventListener("DOMContentLoaded", async () => {
        try {
          const presetsData = await window.api.loadPresets();
          const presetDropdown = document.getElementById("presetDropdown");
          presetDropdown.innerHTML = "";

          const defaultPresetsGroup = document.createElement("optgroup");
          defaultPresetsGroup.label = "Default Presets";

          const userPresetsGroup = document.createElement("optgroup");
          userPresetsGroup.label = "Users Presets";

          // Check if we have the new structured format or old format
          if (presetsData.isStructured) {
            // Handle new structured format with separate folders

            const defaultPresetsList = Array.isArray(presetsData.defaultPresets)
              ? presetsData.defaultPresets
              : Array.isArray(presetsData.scalable)
                ? presetsData.scalable
                : [];
            const userPresetsList = Array.isArray(presetsData.userPresets)
              ? presetsData.userPresets
              : Array.isArray(presetsData.nonScalable)
                ? presetsData.nonScalable
                : [];

            // Add bundled/default presets
            defaultPresetsList.forEach((preset) => {
              const option = document.createElement("option");
              option.value = preset;
              option.textContent = preset;
              defaultPresetsGroup.appendChild(option);
            });

            // Add user presets
            userPresetsList.forEach((preset) => {
              const option = document.createElement("option");
              option.value = preset;
              option.textContent = preset;
              userPresetsGroup.appendChild(option);
            });
          } else {
            // Handle old format for backwards compatibility
            presetsData.forEach((preset) => {
              const option = document.createElement("option");
              option.value = preset;
              option.textContent = preset;

              // Fallback grouping for flat structures
              if (
                preset === "Modern" ||
                preset === "xqjan" ||
                preset === "Neon Future"
              ) {
                defaultPresetsGroup.appendChild(option);
              } else {
                userPresetsGroup.appendChild(option);
              }
            });
          }

          presetDropdown.appendChild(defaultPresetsGroup);
          presetDropdown.appendChild(userPresetsGroup);
        } catch (error) {
          console.error(
            tUi("log.presetsLoadError", "Error loading presets:"),
            error,
          );
        } finally {
          window.__uiPresetsReady = true;
          window.__markUiDataReady?.();
        }
      });

      document.addEventListener("DOMContentLoaded", function () {
        const testButton = document.getElementById("testAchievementBtn");
        const configList = document.getElementById("configList");
        const presetDropdown = document.getElementById("presetDropdown");
        const positionDropdown = document.getElementById("positionDropdown");

        let position = positionDropdown.value;

        positionDropdown.addEventListener("change", function () {
          position = positionDropdown.value;
        });

        testButton.addEventListener("click", async function () {
          const preset = presetDropdown.value || "default";
          const position = positionDropdown.value;
          const sound = document.getElementById("soundSelect").value;
          const scale = parseFloat(
            document.getElementById("scaleSlider").value,
          );

          window.api.showTestNotification({
            preset,
            position,
            sound,
            scale,
          });
        });
      });
      document.addEventListener("DOMContentLoaded", async function () {
        async function loadConfigs() {
          try {
            await reloadConfigsDropdown(true);
          } catch (error) {
            console.error(
              tUi("log.configLoadError", "Config Load Error:"),
              error,
            );
          }
        }
        configList.addEventListener("change", function () {
          if (deleteConfigBtn) {
            deleteConfigBtn.style.display = configList.value
              ? "inline-block"
              : "none";
          }
          if (blacklistConfigBtn) {
            blacklistConfigBtn.style.display = configList.value
              ? "inline-block"
              : "none";
          }
          if (!configList.value) {
            lastSelectedConfigMeta = null;
            updateBlacklistButtonState(null);
          }
        });

        deleteConfigBtn.addEventListener("click", async function () {
          const selectedConfig = configList.value;
          if (!selectedConfig) return;
          await deleteConfigByName(selectedConfig);
        });
        blacklistConfigBtn.addEventListener("click", async () => {
          try {
            const selectedConfig = configList.value;
            if (!selectedConfig) return;
            const configMeta =
              lastSelectedConfigMeta ||
              (await window.api.getConfigByName(selectedConfig));
            const targetAppId = configMeta?.appid
              ? String(configMeta.appid)
              : null;
            if (!targetAppId) {
              alert(
                tUi(
                  "alert.missingAppIdConfig",
                  "Missing AppID for this configuration.",
                ),
              );
              return;
            }

            const currentlyBlacklisted = isAppIdInBlacklist(targetAppId);
            const removeMode =
              blacklistState.showBlacklisted && currentlyBlacklisted;

            logUiEvent("info", "ui:blacklist-config:click", {
              configName: selectedConfig,
              appid: targetAppId,
              remove: removeMode,
            });

            const confirmed = await safeConfirm({
              title: removeMode
                ? tUi("confirm.blacklistRemove.title", "Remove from blacklist")
                : tUi("confirm.blacklistAdd.title", "Add to blacklist"),
              message: removeMode
                ? tUiFmt(
                    "confirm.blacklistRemove.message",
                    { name: selectedConfig },
                    `Remove ${selectedConfig} from blacklist?`,
                  )
                : tUiFmt(
                    "confirm.blacklistAdd.message",
                    { name: selectedConfig },
                    `Ignore ${selectedConfig} and stop tracking it?`,
                  ),
            });
            logUiEvent("info", "ui:blacklist-config:confirm", {
              configName: selectedConfig,
              appid: targetAppId,
              remove: removeMode,
              confirmed,
            });
            if (!confirmed) return;

            await safeRefocus();

            logUiEvent("info", "ui:blacklist-config:ipc-start", {
              configName: selectedConfig,
              appid: targetAppId,
              remove: removeMode,
            });
            const response = await window.api.blacklistConfig({
              configName: selectedConfig,
              appid: targetAppId,
              remove: removeMode,
            });
            logUiEvent(
              response?.success ? "info" : "warn",
              "ui:blacklist-config:ipc-result",
              {
                configName: selectedConfig,
                appid: targetAppId,
                remove: removeMode,
                success: response?.success === true,
                error: response?.error || null,
              },
            );
            if (!response?.success) {
              alert(
                response?.error ||
                  tUi(
                    "alert.blacklistUpdateFailed",
                    "Failed to update blacklist",
                  ),
              );
              return;
            }

            if (Array.isArray(response.blacklist)) {
              blacklistState.appids = new Set(response.blacklist);
            } else {
              await syncBlacklistList();
            }
            renderBlacklistList();

            await reloadConfigsDropdown(true);
            if (!blacklistState.showBlacklisted) {
              configList.value = "";
              [
                "deleteConfigBtn",
                "blacklistConfigBtn",
                "editConfigBtn",
                "playBtn",
              ].forEach((id) => {
                const el = document.getElementById(id);
                if (el) el.style.display = "none";
              });
              document.getElementById("backButton").style.display = "none";
              const tableBody = document.getElementById(
                "achievementsTableBody",
              );
              if (tableBody) tableBody.innerHTML = "";
              const achStats = document.getElementById("achStats");
              if (achStats) achStats.style.display = "none";
              updateMuteProgressUI().catch(() => {});
              try {
                window.api.updateConfig({
                  configName: null,
                  preset: null,
                  position: null,
                });
                window.api.toggleOverlay(null);
                window.api.onLoadOverlayData(null);
              } catch {}
              window.__showFallbackLogo?.();
            } else {
              configList.dispatchEvent(new Event("change", { bubbles: true }));
            }

            if (typeof buildDashboard === "function") {
              await buildDashboard();
            }
          } catch (err) {
            logUiError("ui:blacklist-config-failed", err);
            alert(
              tUi(
                "alert.blacklistUpdateFailedDetails",
                "Failed to update blacklist. See logs for details.",
              ),
            );
          }
        });
      });

      if (showBlacklistedCheckbox) {
        showBlacklistedCheckbox.addEventListener("change", async (e) => {
          const next = !!e.target.checked;
          try {
            await window.api.savePreferences({
              showBlacklistedGames: next,
            });
            applyShowBlacklistPreference(next);
            await reloadConfigsDropdown(true);
            if (typeof buildDashboard === "function") {
              await buildDashboard();
            }
            await syncBlacklistList();
            renderBlacklistList();
          } catch (err) {
            console.error(
              tUi(
                "log.blacklistVisibilityToggleFailed",
                "Failed to toggle blacklist visibility:",
              ),
              err,
            );
            alert(
              tUi(
                "alert.blacklistVisibilityFailed",
                "Failed to update blacklist visibility setting.",
              ),
            );
            e.target.checked = !next;
          }
        });
      }

      if (resetBlacklistBtn) {
        resetBlacklistBtn.addEventListener("click", async () => {
          try {
            logUiEvent("info", "ui:blacklist-reset:click");
            const confirmed = await safeConfirm({
              title: tUi("confirm.blacklistReset.title", "Reset blacklist"),
              message: tUi(
                "confirm.blacklistReset.message",
                "Remove all blacklisted games?",
              ),
            });
            logUiEvent("info", "ui:blacklist-reset:confirm", { confirmed });
            if (!confirmed) return;

            await safeRefocus();
            logUiEvent("info", "ui:blacklist-reset:ipc-start");
            const response = await window.api.resetBlacklist();
            logUiEvent(
              response?.success ? "info" : "warn",
              "ui:blacklist-reset:ipc-result",
              {
                success: response?.success === true,
                error: response?.error || null,
              },
            );
            await syncBlacklistList();
            renderBlacklistList();
            await reloadConfigsDropdown(true);
            if (typeof buildDashboard === "function") {
              await buildDashboard();
            }
          } catch (err) {
            logUiError("ui:blacklist-reset-failed", err);
            alert(
              err?.message ||
                tUi("alert.blacklistResetFailed", "Failed to reset blacklist"),
            );
          }
        });
      }

      //Dashboard
      function enableDashboardHoverSync() {
        const grid = document.getElementById("dashboardGrid");
        if (!grid || grid.__hoverSyncBound) return;
        grid.__hoverSyncBound = true;

        let raf = 0;
        let lastCard = null;
        const search = document.getElementById("dashboardSearchInput");

        const activateFromHover = (card) => {
          if (!card || card === lastCard) return;
          lastCard = card;

          const name = card.getAttribute("data-name") || "";
          setActiveCard(name);

          try {
            const cards = getDashCards(false);
            __dashNav.index = Math.max(0, cards.indexOf(card));
          } catch {}

          try {
            getDashCards(false).forEach((c) =>
              c.querySelector(".dash-play")?.classList.remove("force-show"),
            );
            card.querySelector(".dash-play")?.classList.add("force-show");
          } catch {}

          const searchFocused = document.activeElement === search;
          const shouldFocus =
            !searchFocused && !isSettingsOpen() && window.__dashboardOpen;

          if (shouldFocus && document.activeElement !== card) {
            card.focus({ preventScroll: true });
          }
        };

        grid.addEventListener("pointerover", (e) => {
          if (!window.__dashboardOpen || e.pointerType === "touch" || e.buttons)
            return;

          const card = e.target.closest(".dash-card");
          if (!card || !grid.contains(card)) return;

          cancelAnimationFrame(raf);
          raf = requestAnimationFrame(() => activateFromHover(card));
        });
      }

      (function () {
        const seen = new Set();

        window.api.onAchievementsMissing((payload) => {
          if (window.__dashboardOpen) return;

          const data =
            payload && typeof payload === "object"
              ? payload
              : { configName: String(payload || ""), reason: "" };

          const { configName, reason } = data || {};

          const selected = document.getElementById("configList")?.value || "";
          if (!selected || selected !== configName) return;

          const key = `${reason}|${configName}`;
          if (seen.has(key)) return;
          seen.add(key);
          setTimeout(() => seen.delete(key), 4000);

          let msg = "";
          switch (reason) {
            case "no-config-path":
              msg = `‚ö†Ô∏è Config path is missing for "${configName}". Generate of Select steam_settings in order to see the achievements.`;
              break;
            case "no-file":
              msg = `‚ö†Ô∏è Achievements missing for "${configName}" (achievements.json not found config path).`;
              break;
            case "no-save-path":
              msg = `‚ö†Ô∏è Save path is missing for "${configName}". Achievements will not be tracked.`;
              break;
            default:
              msg = `‚ö†Ô∏è Achievements missing for "${configName}".`;
          }
          showNotification(msg, "#FFC107");
        });
      })();

      document
        .getElementById("backButton")
        .addEventListener("click", async () => {
          const configList = document.getElementById("configList");
          const backButton = document.getElementById("backButton");

          // 1) reset UI + state
          if (configList) configList.value = "";
          if (backButton) {
            backButton.classList.add("hidden");
            backButton.style.display = "none";
          }
          const selectOption = configList?.querySelector?.('option[value=""]');
          if (selectOption) {
            selectOption.selected = true;
            selectOption.disabled = true;
          }

          const hide = (id) => {
            const el = document.getElementById(id);
            if (el) el.style.display = "none";
          };
          hide("deleteConfigBtn");
          hide("editConfigBtn");
          hide("playBtn");
          hide("achStats");
          hide("blacklistConfigBtn");
          hide("muteProgressRow");
          const tableBody = document.getElementById("achievementsTableBody");
          if (tableBody) tableBody.innerHTML = "";
          setAchievementsHeaderVisible(false);

          try {
            window.api.updateConfig({
              configName: null,
              preset: null,
              position: null,
            });
            window.api.toggleOverlay(null);
            window.api.onLoadOverlayData(null);
          } catch {}

          window.__showFallbackLogo?.();

          try {
            await loadPreferencesCached();
            const prefs = getCachedPreferences();
            if (prefs?.showDashboardOnStart) {
              await window.openDashboard?.();
            }
          } catch (e) {
            console.warn(
              tUi(
                "log.dashboardOpenAfterBackFailed",
                "Cannot open Dashboard after Back:",
              ),
              e,
            );
          }
        });

      window.api.onToggleOverlayShortcut(() => {
        const selectedConfig = document.getElementById("configList").value;
        if (!selectedConfig) {
          alert(tUi("alert.selectConfig", "Select a config!"));
          return;
        }
        window.api.toggleOverlay(selectedConfig);
      });

      configList.addEventListener("change", () => {
        if (!configList.value) return;

        if (backButton) {
          backButton.classList.remove("hidden");
          backButton.style.display = "inline-block";
        }
        if (deleteConfigBtn) deleteConfigBtn.style.display = "inline-block";
        if (editConfigBtn) editConfigBtn.style.display = "inline-block";
        if (blacklistConfigBtn)
          blacklistConfigBtn.style.display = "inline-block";
        updateMuteProgressUI().catch(() => {});
        resetConfigForm();
      });

      window.onload = async () => {
        const soundSelect = document.getElementById("soundSelect");

        try {
          await loadPreferencesCached();

          const prefs = getCachedPreferences();
          try {
            window.__dashboardShowOnStart = !!prefs.showDashboardOnStart;
            window.__prepareDashboardForStartup?.();
            window.__markUiDataReady?.();
          } catch {}

          const sounds = await window.api.getSounds();

          const muteOption = document.createElement("option");

          muteOption.value = "mute";

          muteOption.textContent = "üîá Mute";

          soundSelect.appendChild(muteOption);

          sounds.forEach((sound) => {
            const option = document.createElement("option");

            option.value = sound;

            option.textContent = sound;

            soundSelect.appendChild(option);
          });

          renderSteamApiKeyStatusFromPrefs(prefs);

          if (
            prefs &&
            prefs.sound &&
            soundSelect.querySelector(`option[value="${prefs.sound}"]`)
          ) {
            soundSelect.value = prefs.sound;
          }

          if (prefs.disableProgress !== undefined) {
            document.getElementById("disableProgressCheckbox").checked =
              prefs.disableProgress;
          }

          if (prefs.disablePlaytime !== undefined) {
            const cb = document.getElementById(
              "settings-disablePlaytimeCheckbox",
            );

            if (cb) cb.checked = !!prefs.disablePlaytime;
          }

          if (typeof window.api.disableProgress === "function") {
            window.api.disableProgress(!!prefs?.disableProgress);
          }

          if (typeof window.api.setDisablePlaytime === "function") {
            window.api.setDisablePlaytime(!!prefs?.disablePlaytime);
          }
        } catch (err) {
          console.error(tUi("log.soundLoadError", "Sound Load Error:"), err);
        } finally {
          window.__markUiDataReady?.();
        }
      };

      window.api.onPlaySound(async (soundName) => {
        if (soundName && soundName !== "mute") {
          await playCustomSound(soundName);
        }
      });

      if (window.api?.on) {
        window.api.on("blacklist:updated", async (_evt, payload) => {
          try {
            if (Array.isArray(payload?.appids)) {
              blacklistState.appids = new Set(payload.appids);
            } else {
              await syncBlacklistList();
            }
            renderBlacklistList();
            window.__dashboardNeedsRebuild = true;
            if (
              window.__dashboardOpen &&
              typeof buildDashboard === "function"
            ) {
              await buildDashboard();
            }
          } catch (err) {
            console.warn(
              tUi(
                "log.blacklistUpdateHandlingFailed",
                "Blacklist update handling failed:",
              ),
              err,
            );
          }
        });
      }

      let soundAudioContext = null;

      function getSoundVolumeValue() {
        const prefs = getCachedPreferences();
        const slider = document.getElementById("settings-soundVolumeSlider");
        const sliderValue = slider ? Number(slider.value) : NaN;
        const volumeRaw = Number.isFinite(sliderValue)
          ? sliderValue
          : Number(prefs.soundVolume);
        const volume = Number.isFinite(volumeRaw) ? volumeRaw / 100 : 1;
        return Math.max(0, Math.min(2, volume));
      }

      function playAudioWithVolume(audio, volume, label) {
        const vol = Math.max(0, Math.min(2, volume));
        if (vol <= 1) {
          audio.volume = vol;
          audio.play().catch((err) => {
            console.error(label, err);
          });
          return;
        }
        const AudioCtx = window.AudioContext || window.webkitAudioContext;
        if (!AudioCtx) {
          audio.volume = 1;
          audio.play().catch((err) => {
            console.error(label, err);
          });
          return;
        }
        try {
          if (!soundAudioContext || soundAudioContext.state === "closed") {
            soundAudioContext = new AudioCtx();
          }
          if (soundAudioContext.state === "suspended") {
            soundAudioContext.resume().catch(() => {});
          }
          const source = soundAudioContext.createMediaElementSource(audio);
          const gainNode = soundAudioContext.createGain();
          gainNode.gain.value = vol;
          source.connect(gainNode).connect(soundAudioContext.destination);
          const cleanup = () => {
            try {
              source.disconnect();
            } catch {}
            try {
              gainNode.disconnect();
            } catch {}
          };
          audio.addEventListener("ended", cleanup, { once: true });
          audio.addEventListener("error", cleanup, { once: true });
        } catch (err) {
          audio.volume = 1;
        }
        audio.play().catch((err) => {
          console.error(label, err);
        });
      }

      function playSelectedSound() {
        const soundSelect = document.getElementById("soundSelect");
        const selectedSound = soundSelect?.value;

        if (!selectedSound || selectedSound === "mute") return;

        const audio = new Audio(`sounds/${selectedSound}`);
        const volume = getSoundVolumeValue();
        playAudioWithVolume(audio, volume, "?? Sound play error:");
      }

      async function playCustomSound(fileName) {
        if (!fileName || fileName === "mute") return;

        try {
          const fullPath = await window.api.getSoundFullPath(fileName);
          const audio = new Audio(fullPath);
          const volume = getSoundVolumeValue();
          playAudioWithVolume(audio, volume, "?? Custom sound play error:");
        } catch (err) {
          console.error(
            tUi("log.soundPathLoadFailed", "Failed to load sound path:"),
            err,
          );
        }
      }

      async function loadPreferences() {
        await loadPreferencesCached();
        const prefs = getCachedPreferences();
        renderSteamApiKeyStatusFromPrefs(prefs);
        applyShowBlacklistPreference(prefs?.showBlacklistedGames);
        await syncBlacklistList();
        renderBlacklistList();

        if (prefs.position)
          document.getElementById("positionDropdown").value = prefs.position;
        const settingsPositionDropdown = document.getElementById(
          "settings-positionDropdown",
        );
        if (settingsPositionDropdown && prefs.position) {
          settingsPositionDropdown.value = prefs.position;
        }
        if (prefs.preset)
          document.getElementById("presetDropdown").value = prefs.preset;
        const settingsPresetDropdown = document.getElementById(
          "settings-presetDropdown",
        );
        if (settingsPresetDropdown && prefs.preset) {
          settingsPresetDropdown.value = prefs.preset;
        }
        if (prefs.sound)
          document.getElementById("soundSelect").value = prefs.sound;
        const settingsSoundSelect = document.getElementById(
          "settings-soundSelect",
        );
        if (settingsSoundSelect && prefs.sound) {
          settingsSoundSelect.value = prefs.sound;
        }
        if (prefs.notificationScale) {
          const scaleSlider = document.getElementById("scaleSlider");
          scaleSlider.value = prefs.notificationScale;
          updateScaleLabel();
          const settingsScaleSlider = document.getElementById(
            "settings-scaleSlider",
          );
          if (settingsScaleSlider) {
            settingsScaleSlider.value = prefs.notificationScale;
            updateSettingsScaleLabel();
          }
        }
        if (prefs.notificationDuration !== undefined) {
          const settingsDurationSlider = document.getElementById(
            "settings-durationSlider",
          );
          if (settingsDurationSlider) {
            settingsDurationSlider.value = prefs.notificationDuration;
            updateSettingsDurationLabel();
          }
        }
        if (prefs.soundVolume !== undefined) {
          const settingsSoundVolumeSlider = document.getElementById(
            "settings-soundVolumeSlider",
          );
          if (settingsSoundVolumeSlider) {
            settingsSoundVolumeSlider.value = prefs.soundVolume;
            updateSettingsSoundVolumeLabel();
          }
        }
        const hiddenPlatPos = document.getElementById("platinumPositionValue");
        if (prefs.platinumPosition) {
          const el = document.getElementById(
            "settings-platinumPositionDropdown",
          );
          if (el) el.value = prefs.platinumPosition;
        }
        if (hiddenPlatPos) {
          hiddenPlatPos.value =
            prefs.platinumPosition ||
            hiddenPlatPos.value ||
            prefs.position ||
            "center-bottom";
        }
        const hiddenPlatPreset = document.getElementById("platinumPresetValue");
        if (prefs.platinumPreset) {
          const el = document.getElementById("settings-platinumPresetDropdown");
          if (el) el.value = prefs.platinumPreset;
        }
        if (hiddenPlatPreset) {
          hiddenPlatPreset.value =
            prefs.platinumPreset ||
            hiddenPlatPreset.value ||
            prefs.preset ||
            "default";
        }
        const hiddenPlatSound = document.getElementById("platinumSoundValue");
        if (prefs.platinumSound) {
          const el = document.getElementById("settings-platinumSoundSelect");
          if (el) el.value = prefs.platinumSound;
        }
        if (hiddenPlatSound) {
          hiddenPlatSound.value =
            prefs.platinumSound ||
            hiddenPlatSound.value ||
            prefs.sound ||
            "mute";
        }
        if (prefs.disableProgress !== undefined) {
          const cb = document.getElementById("disableProgressCheckbox");
          if (cb) cb.checked = prefs.disableProgress;
        }
        if (prefs.disablePlaytime !== undefined) {
          const cb = document.getElementById(
            "settings-disablePlaytimeCheckbox",
          );
          if (cb) cb.checked = prefs.disablePlaytime;
        }
        {
          const cb = document.getElementById(
            "settings-enableLumaPlayWatcherCheckbox",
          );
          if (cb) cb.checked = prefs?.lumaPlayWatcherEnabled === true;
        }
        {
          const hwCb = document.getElementById(
            "settings-disableHardwareAccelerationCheckbox",
          );
          if (hwCb) {
            hwCb.checked =
              prefs?.disableHardwareAcceleration === undefined
                ? true
                : !!prefs.disableHardwareAcceleration;
          }
        }

        if (prefs.windowZoomFactor) {
          const zoomDropdown = document.getElementById("app-zoom-dropdown");
          if (zoomDropdown) {
            zoomDropdown.value = prefs.windowZoomFactor.toString();
            document.body.dataset.zoom = String(
              Math.round((prefs.windowZoomFactor || 1) * 100),
            );
            document.body.dataset.effectiveZoom = String(
              Math.round((prefs.windowZoomFactor || 1) * 100),
            );
            window.api.setZoom(prefs.windowZoomFactor);
          }
        }
        if (prefs.disablePlatinum !== undefined) {
          const cb = document.getElementById(
            "settings-disablePlatinumCheckbox",
          );
          if (cb) cb.checked = prefs.disablePlatinum;
        }
        if (prefs.overlayShortcut) {
          document.getElementById("overlay-shortcut-btn").textContent =
            prefs.overlayShortcut;
        }
        if (prefs.overlayInteractShortcut) {
          document.getElementById("overlay-interact-shortcut-btn").textContent =
            formatInteractShortcutLabel(prefs.overlayInteractShortcut);
        }
      }

      window.addEventListener("DOMContentLoaded", async () => {
        try {
          await loadPreferencesCached();
          const prefs = getCachedPreferences();
          const storedUiLang = normalizeLangValue(
            prefs.uiLanguage || prefs.language || "english",
          );
          achievementLanguageManual = prefs.achievementLanguageManual === true;
          await applyUiLanguage(storedUiLang);
          const storedAchLang = normalizeLangValue(
            prefs.language ||
              localStorage.getItem("preferredLanguage") ||
              "english",
          );
          if (!achievementLanguageManual) {
            await applyAchievementLanguage(storedUiLang, { manual: false });
          } else if (languageSelect) {
            languageSelect.value = storedAchLang;
          }
          renderSteamApiKeyStatusFromPrefs(prefs);
          applyShowBlacklistPreference(prefs?.showBlacklistedGames);
          if (prefs) {
            if (prefs.position)
              document.getElementById("positionDropdown").value =
                prefs.position;
            const settingsPositionDropdown = document.getElementById(
              "settings-positionDropdown",
            );
            if (settingsPositionDropdown && prefs.position) {
              settingsPositionDropdown.value = prefs.position;
            }
            if (prefs.preset)
              document.getElementById("presetDropdown").value = prefs.preset;
            const settingsPresetDropdown = document.getElementById(
              "settings-presetDropdown",
            );
            if (settingsPresetDropdown && prefs.preset) {
              settingsPresetDropdown.value = prefs.preset;
            }
            if (prefs.sound)
              document.getElementById("soundSelect").value = prefs.sound;
            const settingsSoundSelect = document.getElementById(
              "settings-soundSelect",
            );
            if (settingsSoundSelect && prefs.sound) {
              settingsSoundSelect.value = prefs.sound;
            }
            if (prefs.notificationScale) {
              const scaleSlider = document.getElementById("scaleSlider");
              scaleSlider.value = prefs.notificationScale;
              updateScaleLabel();
              const settingsScaleSlider = document.getElementById(
                "settings-scaleSlider",
              );
              if (settingsScaleSlider) {
                settingsScaleSlider.value = prefs.notificationScale;
                updateSettingsScaleLabel();
              }
            }
            if (prefs.notificationDuration !== undefined) {
              const settingsDurationSlider = document.getElementById(
                "settings-durationSlider",
              );
              if (settingsDurationSlider) {
                settingsDurationSlider.value = prefs.notificationDuration;
                updateSettingsDurationLabel();
              }
            }
            const hiddenPlatPos = document.getElementById(
              "platinumPositionValue",
            );
            if (prefs.platinumPosition) {
              const el = document.getElementById(
                "settings-platinumPositionDropdown",
              );
              if (el) el.value = prefs.platinumPosition;
            }
            if (hiddenPlatPos) {
              hiddenPlatPos.value =
                prefs.platinumPosition ||
                hiddenPlatPos.value ||
                prefs.position ||
                "center-bottom";
            }
            const hiddenPlatPreset = document.getElementById(
              "platinumPresetValue",
            );
            if (prefs.platinumPreset) {
              const el = document.getElementById(
                "settings-platinumPresetDropdown",
              );
              if (el) el.value = prefs.platinumPreset;
            }
            if (hiddenPlatPreset) {
              hiddenPlatPreset.value =
                prefs.platinumPreset ||
                hiddenPlatPreset.value ||
                prefs.preset ||
                "default";
            }
            const hiddenPlatSound =
              document.getElementById("platinumSoundValue");
            if (prefs.platinumSound) {
              const el = document.getElementById(
                "settings-platinumSoundSelect",
              );
              if (el) el.value = prefs.platinumSound;
            }
            if (hiddenPlatSound) {
              hiddenPlatSound.value =
                prefs.platinumSound ||
                hiddenPlatSound.value ||
                prefs.sound ||
                "mute";
            }
            if (prefs.disableProgress !== undefined) {
              const cb = document.getElementById("disableProgressCheckbox");
              if (cb) cb.checked = prefs.disableProgress;
            }

            if (prefs.disablePlaytime !== undefined) {
              const cb1 = document.getElementById(
                "settings-disablePlaytimeCheckbox",
              );
              if (cb1) cb1.checked = prefs.disablePlaytime;
            }
            if (prefs.disablePlatinum !== undefined) {
              const cb = document.getElementById(
                "settings-disablePlatinumCheckbox",
              );
              if (cb) cb.checked = prefs.disablePlatinum;
            }

            if (prefs.windowZoomFactor) {
              const zoomDropdown = document.getElementById("app-zoom-dropdown");
              if (zoomDropdown) {
                zoomDropdown.value = prefs.windowZoomFactor.toString();
                document.body.dataset.zoom = String(
                  Math.round((prefs.windowZoomFactor || 1) * 100),
                );
                document.body.dataset.effectiveZoom = String(
                  Math.round((prefs.windowZoomFactor || 1) * 100),
                );
                window.api.setZoom(prefs.windowZoomFactor);
              }
            }
            if (prefs?.overlayShortcut) {
              document.getElementById("overlay-shortcut-btn").textContent =
                prefs.overlayShortcut;
            } else {
              document.getElementById("overlay-shortcut-btn").textContent = tUi(
                "overlay-shortcut-btn",
                "Set Shortcut",
              );
            }
            if (prefs?.overlayInteractShortcut) {
              document.getElementById(
                "overlay-interact-shortcut-btn",
              ).textContent = formatInteractShortcutLabel(
                prefs.overlayInteractShortcut,
              );
            } else {
              document.getElementById(
                "overlay-interact-shortcut-btn",
              ).textContent = formatInteractShortcutLabel(
                DEFAULT_OVERLAY_INTERACT_SHORTCUT,
              );
            }

            const ssInput = document.getElementById(
              "settings-screenshotFolder",
            );
            const ssButton = document.getElementById(
              "settings-selectScreenshotFolder",
            );
            if (ssInput) {
              ssInput.value = prefs?.screenshotFolder || "";
            }
            if (ssButton) {
              ssButton.addEventListener("click", async () => {
                const dir = await window.api.selectFolder();
                if (dir) {
                  ssInput.value = dir;
                  await window.api.savePreferences({ screenshotFolder: dir });
                  console.log(
                    tUi("log.screenshotFolderSet", "Screenshot folder set to:"),
                    dir,
                  );
                }
              });
            }

            const dsCb = document.getElementById(
              "settings-disableScreenshotCheckbox",
            );
            if (dsCb) {
              dsCb.checked = !!(prefs && prefs.disableAchievementScreenshot);
              dsCb.addEventListener("change", async (e) => {
                await window.api.savePreferences({
                  disableAchievementScreenshot: e.target.checked,
                });
              });
            }
          }

          const steamApiKeyInput = document.getElementById(
            "settings-steamApiKeyInput",
          );
          const steamApiKeySaveBtn = document.getElementById(
            "settings-steamApiKeySave",
          );
          const steamApiKeyClearBtn = document.getElementById(
            "settings-steamApiKeyClear",
          );

          steamApiKeySaveBtn.addEventListener("click", async () => {
            const input = document.getElementById("settings-steamApiKeyInput");
            if (!input) return;
            const raw = input.value.trim();
            if (!raw || raw === input.placeholder) return;

            try {
              await window.api.savePreferences({ steamApiKey: raw });
              await refreshSteamApiKeyStatus();
              console.log(tUi("log.steamApiKeySaved", "Steam API key saved."));
            } catch (err) {
              console.error(
                tUi("log.steamApiKeySaveError", "Steam API key save error:"),
                err,
              );
            }
          });

          if (steamApiKeyClearBtn) {
            steamApiKeyClearBtn.addEventListener("click", async () => {
              const confirmed = await safeConfirm({
                title: tUi(
                  "confirm.steamApiRemove.title",
                  "Remove Steam API key",
                ),
                message: tUi(
                  "confirm.steamApiRemove.message",
                  "Remove the stored Steam API key?",
                ),
              });
              if (!confirmed) return;
              try {
                await window.api.savePreferences({ steamApiKey: "" });
                if (steamApiKeyInput) steamApiKeyInput.value = "";
                await refreshSteamApiKeyStatus();
              } catch (err) {
                console.error(
                  tUi(
                    "log.steamApiKeyClearError",
                    "Steam API key clear error:",
                  ),
                  err,
                );
              }
            });
          }
        } catch (e) {
          console.warn(
            tUi("log.settingsLoadFailed", "Settings cannot be loaded:"),
            e,
          );
          try {
            window.__dashboardShowOnStart = false;
            if (typeof window.__maybeHideBootLoading === "function") {
              window.__maybeHideBootLoading();
            }
          } catch {}
        }
      });

      window.addEventListener("DOMContentLoaded", async () => {
        await loadPreferencesCached();
        const prefs = getCachedPreferences();
        renderSteamApiKeyStatusFromPrefs(prefs);
        const startMaxEl = document.getElementById(
          "settings-startMaximizedCheckbox",
        );
        if (startMaxEl) {
          startMaxEl.checked = !!prefs.startMaximized;
          startMaxEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({
              startMaximized: e.target.checked,
            });
            console.log(
              e.target.checked
                ? tUi("log.appStartMaximized", "App will start maximized")
                : tUi(
                    "log.appStartMaximizeDisabled",
                    "App will not force maximize on startup",
                  ),
            );
          });
        }
        const startInTrayEl = document.getElementById(
          "settings-startInTrayCheckbox",
        );
        if (startInTrayEl) {
          startInTrayEl.checked = !!prefs.startInTray;
          startInTrayEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({ startInTray: e.target.checked });
            console.log(
              e.target.checked
                ? tUi("log.appStartInTray", "App will start in tray")
                : tUi("log.appShowOnStartup", "App will show on startup"),
            );
          });
        }
        const closeToTrayEl = document.getElementById(
          "settings-closeToTrayCheckbox",
        );
        if (closeToTrayEl) {
          closeToTrayEl.checked = !!prefs.closeToTray;
          closeToTrayEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({ closeToTray: e.target.checked });
            console.log(
              e.target.checked
                ? tUi("log.appCloseToTray", "App will close to tray")
                : tUi("log.appCloseFully", "App will close fully"),
            );
          });
        }
        const enableLumaPlayWatcherEl = document.getElementById(
          "settings-enableLumaPlayWatcherCheckbox",
        );
        if (enableLumaPlayWatcherEl) {
          enableLumaPlayWatcherEl.checked =
            prefs?.lumaPlayWatcherEnabled === true;
          enableLumaPlayWatcherEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({
              lumaPlayWatcherEnabled: e.target.checked,
            });
            await loadPreferencesCached().catch(() => {});
            await window.refreshFoldersList?.();
          });
        }

        const startWindowsEl = document.getElementById(
          "settings-startWindowsCheckbox",
        );
        if (startWindowsEl) {
          let initial = await window.api
            .getStartWithWindows()
            .catch(() => null);
          if (initial === null) initial = !!prefs.startWithWindows;
          startWindowsEl.checked = initial;
          startWindowsEl.addEventListener("change", (e) =>
            handleStartWithWindowsToggle(e.target.checked),
          );
        }

        const showHiddenDescEl = document.getElementById(
          "settings-showHiddenDescription",
        );
        if (showHiddenDescEl) {
          showHiddenDescEl.checked = !!prefs.showHiddenDescription;
          showHiddenDescEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({
              showHiddenDescription: e.target.checked,
            });
            await loadPreferencesCached().catch(() => {});
            const cfg = document.getElementById("configList")?.value;
            const lang =
              document.getElementById("languageSelect")?.value || "english";
            if (cfg) {
              try {
                await buildMainAchievementsTable(cfg, lang);
              } catch {}
            }
          });
        }

        const hwAccelEl = document.getElementById(
          "settings-disableHardwareAccelerationCheckbox",
        );
        if (hwAccelEl) {
          hwAccelEl.checked =
            prefs?.disableHardwareAcceleration === undefined
              ? true
              : !!prefs.disableHardwareAcceleration;
          hwAccelEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({
              disableHardwareAcceleration: e.target.checked,
            });
          });
        }

        const showDashEl = document.getElementById(
          "settings-showDashboardOnStartCheckbox",
        );
        if (showDashEl) {
          showDashEl.checked = !!prefs.showDashboardOnStart;
          showDashEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({
              showDashboardOnStart: e.target.checked,
            });
            window.__dashboardShowOnStart = !!e.target.checked;
            window.__prepareDashboardForStartup?.();
            window.__markUiDataReady?.();
            console.log(
              e.target.checked
                ? tUi(
                    "log.dashboardShowOnLaunch",
                    "Dashboard will show on launch",
                  )
                : tUi(
                    "log.dashboardHideOnLaunch",
                    "Dashboard will not show on launch",
                  ),
            );
          });
        }

        if (prefs.showDashboardOnStart) {
          window.__prepareDashboardForStartup?.();
        }
      });
      window.api.onPlaytimeUpdate?.((payload = {}) => {
        const activeRaw = document.getElementById("configList")?.value || "";
        const activeSafe = sanitizeConfigName(activeRaw);
        const payloadSafe = sanitizeConfigName(payload.configName || "");

        if (activeSafe && payloadSafe && activeSafe === payloadSafe) {
          const label = document.getElementById("achStatsPlaytime");
          const lastPlayedLabel = document.getElementById("achStatsLastPlayed");
          if (label) {
            label.textContent = tUiFmt(
              "achStatsPlaytimeFmt",
              { value: formatPlaytimeLabel(payload.totalMs) },
              `Playtime: ${formatPlaytimeLabel(payload.totalMs)}`,
            );
          }
          if (lastPlayedLabel) {
            lastPlayedLabel.textContent = tUiFmt(
              "achStatsLastPlayedFmt",
              { value: formatLastPlayed(payload.updatedAt) },
              `Last Played: ${formatLastPlayed(payload.updatedAt)}`,
            );
          }
        }
      });
      [
        "positionDropdown",
        "presetDropdown",
        "soundSelect",
        "languageSelect",
        "scaleSlider",
        "disableProgressCheckbox",
        "app-zoom-dropdown",
      ].forEach((id) => {
        const el = document.getElementById(id);
        if (el) {
          el.addEventListener("change", () => {
            const zoomValue = parseFloat(
              document.getElementById("app-zoom-dropdown")?.value || 1,
            );
            const prefs = {
              position: document.getElementById("positionDropdown")?.value,
              preset: document.getElementById("presetDropdown")?.value,
              sound: document.getElementById("soundSelect")?.value,
              language: document.getElementById("languageSelect")?.value,
              notificationScale: parseFloat(
                document.getElementById("scaleSlider")?.value || 1,
              ),
              disableProgress: document.getElementById(
                "disableProgressCheckbox",
              )?.checked,
              windowZoomFactor: parseFloat(
                document.getElementById("app-zoom-dropdown")?.value || 1,
              ),
              windowZoomFactor: zoomValue,
            };
            document.body.dataset.zoom = String(
              Math.round((zoomValue || 1) * 100),
            );
            document.body.dataset.effectiveZoom = String(
              Math.round((zoomValue || 1) * 100),
            );
            window.api.savePreferences(prefs);
            window.api.setZoom(prefs.windowZoomFactor); // set zoom live
          });
        }
      });

      window.addEventListener("DOMContentLoaded", () => {
        const savedMessage = localStorage.getItem("configSavedMessage");
        const success = localStorage.getItem("configSavedSuccess") === "true";

        if (savedMessage) {
          showNotification(savedMessage, success ? "#4CAF50" : "#f44336");
          localStorage.removeItem("configSavedMessage");
          localStorage.removeItem("configSavedSuccess");
        }
      });

      function updateAchievementStats(achievements) {
        const total = achievements.length;
        const unlocked = achievements.filter(
          (a) => a.earned === true || a.earned === 1,
        ).length;

        const label = document.getElementById("achStatsText");
        const bar = document.getElementById("achStatsBar");
        const percentLabel = document.getElementById("achStatsPercent");

        const percentage = total > 0 ? Math.round((unlocked / total) * 100) : 0;

        if (label && bar && percentLabel) {
          label.textContent = tUiFmt(
            "achStatsProgress",
            { unlocked, total },
            `Progress: ${unlocked} / ${total}`,
          );
          bar.style.width = `${percentage}%`;
          percentLabel.textContent = `${percentage}%`;
          document.getElementById("achStats").style.display = "block";
        }
      }
      let __watcherAutoSelect = null;
      window.api.on("auto-select-config", async (configName) => {
        const configList = document.getElementById("configList");
        __watcherAutoSelect = sanitizeConfigName(configName);
        if (!configList) return;

        const currentSafe = sanitizeConfigName(configList.value || "");
        if (currentSafe === __watcherAutoSelect) {
          return; // already selected, avoid duplicate reloads
        }

        const cached = configMetaIndex.get(configName);
        if (
          !blacklistState.showBlacklisted &&
          cached?.appid &&
          isAppIdInBlacklist(cached.appid)
        ) {
          return;
        }

        const ensureOption = async () => {
          const hasOption = !!configList.querySelector(
            `option[value="${configName.replace(/"/g, '\\"')}"]`,
          );
          if (!hasOption) {
            await reloadConfigsDropdown();
          }
        };

        await ensureOption();

        // if still missing, abort gracefully
        const optionExists = !!configList.querySelector(
          `option[value="${configName.replace(/"/g, '\\"')}"]`,
        );
        if (!optionExists) return;

        configList.value = configName;
        configList.dispatchEvent(new Event("change", { bubbles: true }));
      });

      async function reloadConfigsDropdown(forceRefreshBlacklist = false) {
        if (forceRefreshBlacklist) {
          await syncBlacklistList();
        }
        const dropdown = document.getElementById("configList");
        if (!dropdown) {
          console.error(
            tUi("log.configListMissing", "configList element not found."),
          );
          return;
        }

        const configsRaw = await window.api.loadConfigs();
        const configs = normalizeConfigList(configsRaw);
        cacheConfigMeta(configs);
        const selectedBefore = dropdown.value;

        dropdown.innerHTML = "";

        const defaultOption = document.createElement("option");
        defaultOption.value = "";
        defaultOption.textContent = "Select";
        defaultOption.disabled = true;
        defaultOption.selected = true;
        dropdown.appendChild(defaultOption);

        const visibleConfigs = blacklistState.showBlacklisted
          ? configs
          : configs.filter((cfg) => !isAppIdInBlacklist(cfg.appid));

        visibleConfigs.forEach((config) => {
          const option = document.createElement("option");
          option.value = config.name;
          option.textContent = config.displayName || config.name;
          if (isAppIdInBlacklist(config.appid)) {
            option.textContent += " (Ignored)";
          }
          dropdown.appendChild(option);
        });

        const prevSanitized = sanitizeConfigName(selectedBefore || "");
        const autoSelectSanitized = sanitizeConfigName(
          __watcherAutoSelect || "",
        );
        const findMatchingValue = () => {
          const byPrev = visibleConfigs.find(
            (cfg) => sanitizeConfigName(cfg.name) === prevSanitized,
          );
          if (byPrev) return byPrev.name;
          const byAuto = visibleConfigs.find(
            (cfg) => sanitizeConfigName(cfg.name) === autoSelectSanitized,
          );
          if (byAuto) return byAuto.name;
          return "";
        };
        const matchValue = findMatchingValue();
        if (matchValue) {
          dropdown.value = matchValue;
          const defaultOpt = dropdown.querySelector('option[value=""]');
          if (defaultOpt) defaultOpt.selected = false;
        }
        const currentValue = dropdown.value;
        if (currentValue) {
          const cachedMeta = configMetaIndex.get(currentValue);
          lastSelectedConfigMeta = cachedMeta || null;
          updateBlacklistButtonState(cachedMeta?.appid || null);
        } else {
          lastSelectedConfigMeta = null;
          updateBlacklistButtonState(null);
          setAchievementsHeaderVisible(false);
        }
      }

      document
        .getElementById("generateConfigsBtn")
        .addEventListener("click", async () => {
          const selectedFolder = await window.api.selectFolder();
          if (!selectedFolder) {
            alert(
              tUi(
                "alert.savePathRequired",
                "Canceled: You must select a save path folder to continue!",
              ),
            );
            return;
          }

          const result =
            await window.autoConfigApi.generateConfigs(selectedFolder);
          if (result.success) {
            console.log(
              tUi(
                "log.configsGeneratedSuccess",
                "Configs generated successfully!",
              ),
            );
            await reloadConfigsDropdown();
          } else {
            console.error(
              tUiFmt(
                "log.generateConfigsFailed",
                { error: result.message },
                `Failed to generate configs: ${result.message}`,
              ),
            );
          }
        });

      function faWithFallback(iconClasses, fallbackChar) {
        return `<i class="${iconClasses} fa-icon" aria-hidden="true"></i><span class="fa-fallback" aria-hidden="true">${fallbackChar}</span>`;
      }

      // Window control buttons
      document.getElementById("minimizeBtn").addEventListener("click", () => {
        window.customApi.minimizeWindow();
      });

      document.getElementById("maximizeBtn").addEventListener("click", () => {
        window.customApi.maximizeWindow();
      });

      document.getElementById("closeBtn").addEventListener("click", () => {
        window.customApi.closeWindow();
      });

      // Update maximize button icon when window state changes
      const getMaximizeBtnInnerHtml = (isMaximized) =>
        isMaximized
          ? '<i class="far fa-clone" aria-hidden="true"></i><span class="titlebar-fallback" aria-hidden="true">‚ñ£</span>'
          : '<i class="far fa-square" aria-hidden="true"></i><span class="titlebar-fallback" aria-hidden="true">‚ñ°</span>';
      window.electron?.ipcRenderer?.on?.(
        "window-state-change",
        (isMaximized) => {
          const maximizeBtn = document.getElementById("maximizeBtn");
          if (!maximizeBtn) return;
          maximizeBtn.innerHTML = getMaximizeBtnInnerHtml(!!isMaximized);
          document.body.classList.toggle("window-maximized", !!isMaximized);
        },
      );

      // Add visual feedback when clicking buttons
      const buttons = document.querySelectorAll(".titlebar-button");
      buttons.forEach((button) => {
        button.addEventListener("mousedown", () => {
          button.style.backgroundColor = "rgba(255, 255, 255, 0.2)";
        });
        button.addEventListener("mouseup", () => {
          button.style.backgroundColor = "";
        });
        button.addEventListener("mouseleave", () => {
          button.style.backgroundColor = "";
        });
      });

      // Settings Menu Functionality
      function setInertExcept(keepIds = []) {
        const keep = new Set(["titlebar", ...keepIds]);
        Array.from(document.body.children).forEach((el) => {
          if (!(el instanceof HTMLElement)) return;
          if (keep.has(el.id)) {
            el.removeAttribute("aria-hidden");
            el.inert = false;
          } else {
            el.setAttribute("aria-hidden", "true");
            el.inert = true;
          }
        });
      }
      function clearInertAll() {
        Array.from(document.body.children).forEach((el) => {
          if (!(el instanceof HTMLElement)) return;
          el.removeAttribute("aria-hidden");
          el.inert = false;
        });
      }

      function isElementVisible(el) {
        const st = getComputedStyle(el);
        if (st.display === "none" || st.visibility === "hidden") return false;
        const r = el.getBoundingClientRect();
        return r.width > 0 && r.height > 0;
      }

      let __settingsTrapHandler = null;

      function trapFocus(container) {
        const sel =
          'a,button,input,select,textarea,[tabindex]:not([tabindex="-1"])';
        const visible = (el) => {
          if (!(el instanceof HTMLElement)) return false;
          const st = getComputedStyle(el);
          if (st.display === "none" || st.visibility === "hidden") return false;
          const r = el.getBoundingClientRect();
          return r.width > 0 && r.height > 0;
        };
        const getFocusable = () =>
          Array.from(container.querySelectorAll(sel)).filter(
            (el) => !el.disabled && el.tabIndex !== -1 && visible(el),
          );

        const activeTab =
          container.querySelector(".settings-tab.active") ||
          container.querySelector(".settings-tab");
        (activeTab || getFocusable()[0] || container).focus({
          preventScroll: true,
        });

        const handler = (e) => {
          if (e.key !== "Tab") return;
          const f = getFocusable();
          if (!f.length) return;
          const first = f[0],
            last = f[f.length - 1];

          if (e.shiftKey && document.activeElement === first) {
            e.preventDefault();
            last.focus({ preventScroll: true });
          } else if (!e.shiftKey && document.activeElement === last) {
            e.preventDefault();
            first.focus({ preventScroll: true });
          }
        };

        __settingsTrapHandler = handler;
        container.addEventListener("keydown", handler, true);
      }

      function untrapFocus(container) {
        if (__settingsTrapHandler && container) {
          container.removeEventListener("keydown", __settingsTrapHandler, true);
          __settingsTrapHandler = null;
        }
      }

      // ===== STRICT BG-SCROLL BLOCKERS (Settings + Dashboard) =====
      let __scrollBlockersOn = false;

      function installBgScrollBlockers() {
        if (__scrollBlockersOn) return;
        __scrollBlockersOn = true;

        const settingsMenu = document.getElementById("settingsMenu");
        const settingsContent = document.querySelector(".settings-content");

        const dashOverlay = document.getElementById("dashboardOverlay");
        const dashPanel = document.getElementById("dashboardPanel");
        const onboardingModal = document.getElementById("bootOnboardingModal");
        const onboardingContent =
          onboardingModal?.querySelector(".modal-content");
        const confirmModal = document.getElementById("appConfirmModal");
        const confirmContent = confirmModal?.querySelector(".modal-content");

        const isOnboardingOpen = () =>
          !!onboardingModal && !onboardingModal.classList.contains("hidden");
        const isConfirmOpen = () =>
          !!confirmModal && !confirmModal.classList.contains("hidden");

        const isAnyOpen = () =>
          (!!settingsMenu && !settingsMenu.classList.contains("hidden")) ||
          (!!dashOverlay && dashOverlay.classList.contains("open")) ||
          isOnboardingOpen() ||
          isConfirmOpen();

        const isInsideOverlay = (t) =>
          (!!settingsContent && t && settingsContent.contains(t)) ||
          (!!dashPanel && t && dashPanel.contains(t)) ||
          (isOnboardingOpen() &&
            ((!!onboardingContent && t && onboardingContent.contains(t)) ||
              (!!onboardingModal && t && onboardingModal.contains(t)))) ||
          (isConfirmOpen() &&
            ((!!confirmContent && t && confirmContent.contains(t)) ||
              (!!confirmModal && t && confirmModal.contains(t))));

        // ‚Äî mouse/trackpad/touch
        const wheelBlock = (e) => {
          if (isAnyOpen() && !isInsideOverlay(e.target)) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        };
        const touchBlock = (e) => {
          if (isAnyOpen() && !isInsideOverlay(e.target)) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        };

        // ‚Äî scroll in Main
        const SCROLL_KEYS = new Set([
          "ArrowUp",
          "ArrowDown",
          "ArrowLeft",
          "ArrowRight",
          "PageUp",
          "PageDown",
          "Home",
          "End",
          " ",
          "Spacebar",
        ]);

        const keyBlock = (e) => {
          if (!isAnyOpen()) return;

          if (!isInsideOverlay(e.target) && SCROLL_KEYS.has(e.key)) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        };

        document.addEventListener("wheel", wheelBlock, {
          passive: false,
          capture: true,
        });
        document.addEventListener("touchmove", touchBlock, {
          passive: false,
          capture: true,
        });
        document.addEventListener("keydown", keyBlock, true);

        window.___bgScrollGuards = { wheelBlock, touchBlock, keyBlock };
      }

      function removeBgScrollBlockers() {
        const settingsOpen = !document
          .getElementById("settingsMenu")
          ?.classList.contains("hidden");
        const dashOpen = document
          .getElementById("dashboardOverlay")
          ?.classList?.contains("open");
        const onboardingOpen = !document
          .getElementById("bootOnboardingModal")
          ?.classList.contains("hidden");
        const confirmOpen = !document
          .getElementById("appConfirmModal")
          ?.classList.contains("hidden");
        if (settingsOpen || dashOpen || onboardingOpen || confirmOpen) return;

        if (!__scrollBlockersOn || !window.___bgScrollGuards) return;
        __scrollBlockersOn = false;

        const { wheelBlock, touchBlock, keyBlock } = window.___bgScrollGuards;
        document.removeEventListener("wheel", wheelBlock, { capture: true });
        document.removeEventListener("touchmove", touchBlock, {
          capture: true,
        });
        document.removeEventListener("keydown", keyBlock, true);
        window.___bgScrollGuards = null;
      }

      function isSettingsOpen() {
        const m = document.getElementById("settingsMenu");
        return !!(m && !m.classList.contains("hidden"));
      }

      function refocusSettings(afterMs = 140) {
        const attempts = [afterMs, 700, 1400, 2200];
        const doFocus = () => {
          if (!isSettingsOpen()) return;
          try {
            window.ui?.refocus?.();
          } catch {}
          const content = document.querySelector(".settings-content");
          if (!content) return;
          const activeTab = content.querySelector(".settings-tab.active");
          const firstFocusable = content.querySelector(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])',
          );
          (activeTab || firstFocusable || content).focus?.({
            preventScroll: true,
          });
        };
        attempts.forEach((ms) => setTimeout(doFocus, ms));
      }

      function escGateWhileSettings(e) {
        if (e.key !== "Escape") return;
        const menu = document.getElementById("settingsMenu");
        const open = menu && !menu.classList.contains("hidden");
        if (!open) return;

        e.stopImmediatePropagation();
        e.preventDefault();

        if (window.__settingsMode === "section") {
          const activeTab = document.querySelector(".settings-tab.active");
          if (activeTab) {
            activeTab.focus({ preventScroll: true });
            window.__settingsMode = "tabs";
          }
          return;
        }

        document.getElementById("closeSettingsBtn")?.click();
      }

      let __bodyOverflowPrev = "";

      function openSettingsModal() {
        const settingsMenu = document.getElementById("settingsMenu");
        const content = document.querySelector(".settings-content");

        setInertExcept(["settingsMenu", "titlebar"]);
        settingsMenu.classList.remove("hidden");
        document.documentElement.classList.add("settings-open");
        document.body.classList.add("settings-open");

        installBgScrollBlockers();

        const stopOutside = (e) => {
          if (!settingsMenu || settingsMenu.classList.contains("hidden"))
            return;
          if (!content.contains(e.target)) {
            e.preventDefault();
            e.stopPropagation();
          }
        };
        if (!window.__settingsWheelGuards) {
          document.addEventListener("wheel", stopOutside, {
            passive: false,
            capture: true,
          });
          document.addEventListener("touchmove", stopOutside, {
            passive: false,
            capture: true,
          });
          window.__settingsWheelGuards = true;
        }

        trapFocus(content);
        settingsEnterTabsMode();
        document.addEventListener("keydown", escGateWhileSettings, {
          capture: true,
        });
      }

      if (window.api?.on) {
        window.api.on("tray:open-settings", () => {
          if (typeof openSettingsModal === "function") {
            openSettingsModal();
          } else {
            document.getElementById("settingsBtn")?.click();
          }
        });
      }

      function closeSettingsModal() {
        window.__settingsMode = null;

        const settingsMenu = document.getElementById("settingsMenu");
        const content = document.querySelector(".settings-content");

        untrapFocus(content);
        settingsMenu.classList.add("hidden");

        document.documentElement.classList.remove("settings-open");
        document.body.classList.remove("settings-open");

        document.removeEventListener("keydown", escGateWhileSettings, {
          capture: true,
        });

        removeBgScrollBlockers();

        if (window.__dashboardOpen) {
          try {
            setBackgroundInert(true);
          } catch {}
          refocusDashboard();
        } else {
          clearInertAll();
        }
      }

      document
        .getElementById("settingsBtn")
        .addEventListener("click", (event) => {
          event.stopPropagation();
          syncSettingsToModal();
          openSettingsModal();
        });

      document
        .getElementById("closeSettingsBtn")
        .addEventListener("click", async () => {
          syncSettingsFromModal();
          await persistSettingsPreferences();
          closeSettingsModal();
        });

      document
        .getElementById("settingsMenu")
        .addEventListener("click", async (event) => {
          const settingsContent = document.querySelector(".settings-content");
          if (!settingsContent.contains(event.target)) {
            syncSettingsFromModal();
            await persistSettingsPreferences();
            closeSettingsModal();
          }
        });

      // Tab switching
      document.querySelectorAll(".settings-tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          // Remove active class from all tabs
          document
            .querySelectorAll(".settings-tab")
            .forEach((t) => t.classList.remove("active"));
          document
            .querySelectorAll(".tab-content")
            .forEach((c) => c.classList.remove("active"));

          // Add active class to clicked tab and corresponding content
          tab.classList.add("active");
          const tabId = tab.getAttribute("data-tab");
          if (tabId === "shortcuts") ensureShortcutsTabContent();
          const tabContent = document.getElementById(tabId + "Tab");
          if (tabContent) {
            tabContent.classList.add("active");
            tabContent.removeAttribute("hidden");
          }

          // Enter section mode after switching tabs
          window.settingsEnterSectionMode();
        });
      });

      // Achievement test button in settings
      document
        .getElementById("settings-testAchievementBtn")
        .addEventListener("click", function () {
          const preset =
            document.getElementById("settings-presetDropdown").value ||
            "default";
          const position = document.getElementById(
            "settings-positionDropdown",
          ).value;
          const sound = document.getElementById("settings-soundSelect").value;
          const scale = parseFloat(
            document.getElementById("settings-scaleSlider").value,
          );

          window.api.showTestNotification({
            preset,
            position,
            sound,
            scale,
          });
        });

      // Settings scale slider
      const settingsScaleSlider = document.getElementById(
        "settings-scaleSlider",
      );
      const settingsScaleValue = document.getElementById("settings-scaleValue");
      const settingsScaleValueDisplay = document.getElementById(
        "settings-scaleValueDisplay",
      );
      const settingsDurationSlider = document.getElementById(
        "settings-durationSlider",
      );
      const settingsDurationValue = document.getElementById(
        "settings-durationValue",
      );
      const settingsDurationValueDisplay = document.getElementById(
        "settings-durationValueDisplay",
      );
      const settingsSoundVolumeSlider = document.getElementById(
        "settings-soundVolumeSlider",
      );
      const settingsSoundVolumeValue = document.getElementById(
        "settings-soundVolumeValue",
      );
      const settingsSoundVolumeValueDisplay = document.getElementById(
        "settings-soundVolumeValueDisplay",
      );

      function updateSettingsScaleLabel() {
        const value = parseFloat(settingsScaleSlider.value);
        const percentage = Math.round(value * 100);
        settingsScaleValue.textContent = value.toFixed(2);
        settingsScaleValueDisplay.textContent = `${percentage}%`;
        settingsScaleSlider.style.background = `linear-gradient(to right, var(--dracula-cyan) 0%, var(--dracula-cyan) ${percentage}%, #ccc ${percentage}%, #ccc 100%)`;
      }

      function updateSettingsDurationLabel() {
        const value = parseFloat(settingsDurationSlider.value);
        if (!Number.isFinite(value) || value <= 0) {
          settingsDurationValue.textContent = "Auto";
          settingsDurationValueDisplay.textContent = "Auto";
          settingsDurationSlider.style.background = `linear-gradient(to right, var(--dracula-cyan) 0%, #ccc 0%, #ccc 100%)`;
          return;
        }
        const seconds = Math.max(0.5, value);
        settingsDurationValue.textContent = `${seconds.toFixed(1)}s`;
        settingsDurationValueDisplay.textContent = `${seconds.toFixed(1)}s`;
        const percentage = Math.round((seconds / 10) * 100);
        settingsDurationSlider.style.background = `linear-gradient(to right, var(--dracula-cyan) 0%, var(--dracula-cyan) ${percentage}%, #ccc ${percentage}%, #ccc 100%)`;
      }

      function updateSettingsSoundVolumeLabel() {
        const value = parseInt(settingsSoundVolumeSlider.value, 10);
        const percent = Number.isFinite(value) ? value : 100;
        settingsSoundVolumeValue.textContent = `${percent}%`;
        settingsSoundVolumeValueDisplay.textContent = `${percent}%`;
        const percentage = Math.round((percent / 200) * 100);
        settingsSoundVolumeSlider.style.background = `linear-gradient(to right, var(--dracula-cyan) 0%, var(--dracula-cyan) ${percentage}%, #ccc ${percentage}%, #ccc 100%)`;
      }

      updateSettingsDurationLabel();
      updateSettingsSoundVolumeLabel();

      function renderSteamApiKeyStatus(masked) {
        const inputEl = document.getElementById("settings-steamApiKeyInput");
        if (!inputEl) return;

        if (masked) {
          inputEl.value = masked;
          inputEl.placeholder = tUi(
            "placeholder.settings-steamApiKeyInputSaved",
            "Enter your Steam Web API key",
          );
        } else {
          inputEl.value = "";
          inputEl.placeholder = tUi(
            "placeholder.settings-steamApiKeyInput",
            "No key saved. Enter your Steam Web API key",
          );
        }
      }

      function renderSteamApiKeyStatusFromPrefs(prefs) {
        renderSteamApiKeyStatus(prefs?.steamApiKeyMasked || "");
      }

      async function refreshSteamApiKeyStatus() {
        try {
          await loadPreferencesCached();
          renderSteamApiKeyStatusFromPrefs(getCachedPreferences());
        } catch (err) {
          console.error(
            tUi("log.steamApiKeyStatusError", "Steam API key status error:"),
            err,
          );
        }
      }

      settingsScaleSlider.addEventListener("input", () => {
        updateSettingsScaleLabel();
        window.api.savePreferences({
          notificationScale: settingsScaleSlider.value,
        });
      });

      settingsDurationSlider.addEventListener("input", () => {
        updateSettingsDurationLabel();
        window.api.savePreferences({
          notificationDuration: settingsDurationSlider.value,
        });
      });

      settingsSoundVolumeSlider.addEventListener("input", () => {
        updateSettingsSoundVolumeLabel();
        window.api.savePreferences({
          soundVolume: settingsSoundVolumeSlider.value,
        });
      });

      // Save Settings without config
      document
        .getElementById("settings-disableProgressCheckbox")
        .addEventListener("change", async (e) => {
          const isChecked = e.target.checked;
          window.api.disableProgress(isChecked);
          await window.api.savePreferences({ disableProgress: isChecked });
        });

      document
        .getElementById("settings-disablePlaytimeCheckbox")
        .addEventListener("change", async (e) => {
          const on = e.target.checked;
          window.api.setDisablePlaytime(on);
          await window.api.savePreferences({ disablePlaytime: on });
        });

      document
        .getElementById("settings-disablePlatinumCheckbox")
        .addEventListener("change", async (e) => {
          await window.api.savePreferences({
            disablePlatinum: e.target.checked,
          });
        });

      document
        .getElementById("settings-positionDropdown")
        .addEventListener("change", (e) =>
          window.api.savePreferences({ position: e.target.value }),
        );

      document
        .getElementById("settings-platinumPositionDropdown")
        .addEventListener("change", (e) => {
          const hidden = document.getElementById("platinumPositionValue");
          if (hidden) hidden.value = e.target.value;
          window.api.savePreferences({ platinumPosition: e.target.value });
        });

      document
        .getElementById("settings-presetDropdown")
        .addEventListener("change", (e) =>
          window.api.savePreferences({ preset: e.target.value }),
        );

      document
        .getElementById("settings-platinumPresetDropdown")
        .addEventListener("change", (e) => {
          const hidden = document.getElementById("platinumPresetValue");
          if (hidden) hidden.value = e.target.value;
          window.api.savePreferences({ platinumPreset: e.target.value });
        });

      document
        .getElementById("settings-soundSelect")
        .addEventListener("change", (e) => {
          window.api.savePreferences({ sound: e.target.value });
        });

      document
        .getElementById("settings-platinumSoundSelect")
        .addEventListener("change", (e) => {
          const hidden = document.getElementById("platinumSoundValue");
          if (hidden) hidden.value = e.target.value;
          window.api.savePreferences({ platinumSound: e.target.value });
        });

      // Function to sync values between main UI and settings menu
      function syncSettingsToModal() {
        // Copy preset options
        const mainPresetDropdown = document.getElementById("presetDropdown");
        const settingsPresetDropdown = document.getElementById(
          "settings-presetDropdown",
        );

        if (mainPresetDropdown && settingsPresetDropdown) {
          settingsPresetDropdown.innerHTML = mainPresetDropdown.innerHTML;
          if (mainPresetDropdown.value) {
            settingsPresetDropdown.value = mainPresetDropdown.value;
          }
          const prefs = getCachedPreferences();
          const platinumPresetDropdown = document.getElementById(
            "settings-platinumPresetDropdown",
          );
          if (platinumPresetDropdown) {
            platinumPresetDropdown.innerHTML = mainPresetDropdown.innerHTML;
            platinumPresetDropdown.value =
              prefs.platinumPreset || platinumPresetDropdown.value || "default";
          }
        }

        // Copy sound options
        const mainSoundSelect = document.getElementById("soundSelect");
        const settingsSoundSelect = document.getElementById(
          "settings-soundSelect",
        );

        if (mainSoundSelect && settingsSoundSelect) {
          settingsSoundSelect.innerHTML = mainSoundSelect.innerHTML;
          if (mainSoundSelect.value) {
            settingsSoundSelect.value = mainSoundSelect.value;
          }
          const prefs = getCachedPreferences();
          const platinumSoundSelect = document.getElementById(
            "settings-platinumSoundSelect",
          );
          if (platinumSoundSelect) {
            platinumSoundSelect.innerHTML = mainSoundSelect.innerHTML;
            platinumSoundSelect.value =
              prefs.platinumSound || platinumSoundSelect.value || "mute";
          }
        }

        // Sync position dropdown
        const mainPositionDropdown =
          document.getElementById("positionDropdown");
        const settingsPositionDropdown = document.getElementById(
          "settings-positionDropdown",
        );

        if (mainPositionDropdown && settingsPositionDropdown) {
          settingsPositionDropdown.value = mainPositionDropdown.value;
        }
        const settingsPlatinumPositionDropdown = document.getElementById(
          "settings-platinumPositionDropdown",
        );
        if (settingsPlatinumPositionDropdown && mainPositionDropdown) {
          if (!settingsPlatinumPositionDropdown.value) {
            settingsPlatinumPositionDropdown.value = mainPositionDropdown.value;
          }
        }

        // Sync scale slider
        const mainScaleSlider = document.getElementById("scaleSlider");
        const settingsScaleSlider = document.getElementById(
          "settings-scaleSlider",
        );

        if (mainScaleSlider && settingsScaleSlider) {
          settingsScaleSlider.value = mainScaleSlider.value;
          updateSettingsScaleLabel();
        }

        const prefs = getCachedPreferences();
        const settingsDurationSlider = document.getElementById(
          "settings-durationSlider",
        );
        if (settingsDurationSlider) {
          settingsDurationSlider.value = prefs.notificationDuration ?? 0;
          updateSettingsDurationLabel();
        }
        const settingsSoundVolumeSlider = document.getElementById(
          "settings-soundVolumeSlider",
        );
        if (settingsSoundVolumeSlider) {
          settingsSoundVolumeSlider.value = prefs.soundVolume ?? 100;
          updateSettingsSoundVolumeLabel();
        }

        // Sync disable progress checkbox
        const mainDisableProgressCheckbox = document.getElementById(
          "disableProgressCheckbox",
        );
        const settingsDisableProgressCheckbox = document.getElementById(
          "settings-disableProgressCheckbox",
        );

        if (mainDisableProgressCheckbox && settingsDisableProgressCheckbox) {
          settingsDisableProgressCheckbox.checked =
            mainDisableProgressCheckbox.checked;
        }
        const settingsDisablePlatinumCheckbox = document.getElementById(
          "settings-disablePlatinumCheckbox",
        );
        if (settingsDisablePlatinumCheckbox) {
          // no main checkbox; leave as stored
        }
        const steamApiKeyInput = document.getElementById(
          "settings-steamApiKeyInput",
        );
        if (steamApiKeyInput) {
          steamApiKeyInput.value = "";
        }
        refreshSteamApiKeyStatus();
      }

      function syncSettingsFromModal() {
        // Copy values from settings menu to main UI
        const mainPresetDropdown = document.getElementById("presetDropdown");
        const settingsPresetDropdown = document.getElementById(
          "settings-presetDropdown",
        );

        if (
          mainPresetDropdown &&
          settingsPresetDropdown &&
          settingsPresetDropdown.value
        ) {
          mainPresetDropdown.value = settingsPresetDropdown.value;
        }

        // Copy sound options
        const mainSoundSelect = document.getElementById("soundSelect");
        const settingsSoundSelect = document.getElementById(
          "settings-soundSelect",
        );

        if (
          mainSoundSelect &&
          settingsSoundSelect &&
          settingsSoundSelect.value
        ) {
          mainSoundSelect.value = settingsSoundSelect.value;
        }

        // Sync position dropdown
        const mainPositionDropdown =
          document.getElementById("positionDropdown");
        const settingsPositionDropdown = document.getElementById(
          "settings-positionDropdown",
        );

        if (mainPositionDropdown && settingsPositionDropdown) {
          mainPositionDropdown.value = settingsPositionDropdown.value;
        }

        // Sync scale slider
        const mainScaleSlider = document.getElementById("scaleSlider");
        const settingsScaleSlider = document.getElementById(
          "settings-scaleSlider",
        );

        if (mainScaleSlider && settingsScaleSlider) {
          mainScaleSlider.value = settingsScaleSlider.value;
          const event = new Event("input");
          mainScaleSlider.dispatchEvent(event);
        }

        // Sync disable progress checkbox
        const mainDisableProgressCheckbox = document.getElementById(
          "disableProgressCheckbox",
        );
        const settingsDisableProgressCheckbox = document.getElementById(
          "settings-disableProgressCheckbox",
        );

        if (mainDisableProgressCheckbox && settingsDisableProgressCheckbox) {
          mainDisableProgressCheckbox.checked =
            settingsDisableProgressCheckbox.checked;
        }
        const settingsDisablePlatinumCheckbox = document.getElementById(
          "settings-disablePlatinumCheckbox",
        );
        if (settingsDisablePlatinumCheckbox) {
          settingsDisablePlatinumCheckbox.dispatchEvent(new Event("change"));
        }
        if (typeof updateMainConfig === "function") {
          try {
            updateMainConfig();
          } catch (err) {
            console.warn(
              "Failed to update config after syncing settings:",
              err,
            );
          }
        }
      }

      function collectSettingsPreferences() {
        const byId = (id) => document.getElementById(id);
        const checkbox = (id) => !!byId(id)?.checked;
        const getVal = (id) => byId(id)?.value || "";
        const zoomValue = parseFloat(getVal("app-zoom-dropdown"));
        const settingsScale = parseFloat(getVal("settings-scaleSlider"));
        const settingsDuration = parseFloat(getVal("settings-durationSlider"));
        const settingsSoundVolume = parseInt(
          getVal("settings-soundVolumeSlider"),
          10,
        );
        const overlayLabel = (byId("overlay-shortcut-btn")?.textContent || "")
          .trim()
          .replace(/\s+/g, " ");
        const base = { ...getCachedPreferences() };
        delete base.steamApiKeyMasked;

        const pick = (value, fallback) => {
          return value !== undefined && value !== null && value !== ""
            ? value
            : fallback;
        };

        const snapshot = {
          ...base,
          preset: pick(
            getVal("settings-presetDropdown") || getVal("presetDropdown"),
            base.preset || "default",
          ),
          position: pick(
            getVal("settings-positionDropdown") || getVal("positionDropdown"),
            base.position || "center-bottom",
          ),
          sound: pick(
            getVal("settings-soundSelect") || getVal("soundSelect"),
            base.sound || "mute",
          ),
          notificationScale: Number.isFinite(settingsScale)
            ? settingsScale
            : base.notificationScale || 1,
          notificationDuration: Number.isFinite(settingsDuration)
            ? settingsDuration
            : base.notificationDuration || 0,
          soundVolume: Number.isFinite(settingsSoundVolume)
            ? settingsSoundVolume
            : (base.soundVolume ?? 100),
          disableProgress: checkbox("settings-disableProgressCheckbox"),
          disablePlaytime: checkbox("settings-disablePlaytimeCheckbox"),
          disablePlatinum: checkbox("settings-disablePlatinumCheckbox"),
          lumaPlayWatcherEnabled: checkbox(
            "settings-enableLumaPlayWatcherCheckbox",
          ),
          startMaximized: checkbox("settings-startMaximizedCheckbox"),
          startInTray: checkbox("settings-startInTrayCheckbox"),
          closeToTray: checkbox("settings-closeToTrayCheckbox"),
          showDashboardOnStart: checkbox(
            "settings-showDashboardOnStartCheckbox",
          ),
          disableHardwareAcceleration: checkbox(
            "settings-disableHardwareAccelerationCheckbox",
          ),
          screenshotFolder: pick(
            getVal("settings-screenshotFolder").trim(),
            base.screenshotFolder || "",
          ),
          disableAchievementScreenshot: checkbox(
            "settings-disableScreenshotCheckbox",
          ),
          windowZoomFactor: Number.isFinite(zoomValue)
            ? zoomValue
            : base.windowZoomFactor || 1,
          language: pick(getVal("languageSelect"), base.language || undefined),
        };

        snapshot.platinumPreset = pick(
          getVal("settings-platinumPresetDropdown") ||
            getVal("platinumPresetValue"),
          base.platinumPreset || snapshot.preset,
        );
        snapshot.platinumPosition = pick(
          getVal("settings-platinumPositionDropdown") ||
            getVal("platinumPositionValue"),
          base.platinumPosition || snapshot.position,
        );
        snapshot.platinumSound = pick(
          getVal("settings-platinumSoundSelect") ||
            getVal("platinumSoundValue"),
          base.platinumSound || snapshot.sound,
        );

        return snapshot;
      }

      async function persistSettingsPreferences() {
        await refreshPreferencesCache();
        try {
          const payload = collectSettingsPreferences();
          await window.api.savePreferences(payload);
          await refreshPreferencesCache();
        } catch (err) {
          console.error(
            tUi(
              "log.settingsSnapshotPersistFailed",
              "Failed to persist settings snapshot:",
            ),
            err,
          );
        }
      }

      // Zoom level control
      document
        .getElementById("app-zoom-dropdown")
        .addEventListener("change", (e) => {
          const zoomValue = parseFloat(e.target.value);
          window.api.setZoom(zoomValue);
          window.api.savePreferences({ windowZoomFactor: zoomValue });
        });

      // Overlay shortcut functionality
      const overlayShortcutBtn = document.getElementById(
        "overlay-shortcut-btn",
      );
      let isListeningForShortcut = false;
      let pressedKeys = new Set();
      let shortcutTimeout;
      let currentKeyHandler = null;
      const getPressKeysLabel = () =>
        tUi("ui.shortcut.pressKeys", "Press keys...");

      const normalizeShortcutKey = (event) => {
        if (event.key === "AltGraph") return "AltGraph";
        if (event.key === "Alt" && event.location === 2) return "AltGraph";
        return event.key;
      };

      const buildShortcutCombo = (keysSet, opts = {}) => {
        const allowSingle = opts.allowSingle === true;
        const keys = [];
        const hasCtrl = keysSet.has("Control");
        const hasShift = keysSet.has("Shift");
        const hasAltGr = keysSet.has("AltGraph");
        const hasAlt = keysSet.has("Alt");

        if (hasCtrl) keys.push("Control");
        if (hasShift) keys.push("Shift");
        if (hasAltGr) keys.push("AltGr");
        else if (hasAlt) keys.push("Alt");

        const mainKeys = [...keysSet].filter(
          (k) => !["Control", "Shift", "Alt", "AltGraph", "Meta"].includes(k),
        );
        if (mainKeys.length > 0) {
          const mainKey = mainKeys[0];
          keys.push(mainKey.length === 1 ? mainKey.toUpperCase() : mainKey);
          if (!allowSingle && keys.length < 2) return null;
          return keys.join("+");
        }
        return null;
      };

      overlayShortcutBtn.addEventListener("click", () => {
        if (
          overlayShortcutBtn.textContent === getPressKeysLabel() ||
          overlayShortcutBtn.classList.contains("listening")
        ) {
          cleanupShortcutRecording();
          restoreSavedShortcutLabel();
          return;
        }

        overlayShortcutBtn.textContent = getPressKeysLabel();
        overlayShortcutBtn.classList.add("listening");
        isListeningForShortcut = true;
        pressedKeys.clear();

        if (isListeningForInteractShortcut) {
          cleanupInteractShortcutRecording();
          restoreSavedInteractShortcutLabel();
        }

        const handleKeyDown = (e) => {
          if (!isListeningForShortcut) return;

          e.preventDefault();
          pressedKeys.add(normalizeShortcutKey(e));

          clearTimeout(shortcutTimeout);
          shortcutTimeout = setTimeout(() => {
            if (!isListeningForShortcut) return;
            const combo = buildShortcutCombo(pressedKeys, {
              allowSingle: false,
            });
            if (!combo) {
              overlayShortcutBtn.textContent = tUi(
                "ui.shortcut.invalidCombo",
                "Invalid combo",
              );
              setTimeout(() => restoreSavedShortcutLabel(), 1200);
            } else {
              overlayShortcutBtn.textContent = combo;
              window.api.savePreferences({ overlayShortcut: combo });
              window.api.updateOverlayShortcut?.(combo);
            }

            cleanupShortcutRecording();
          }, 400);
        };

        currentKeyHandler = handleKeyDown;
        document.addEventListener("keydown", handleKeyDown);
      });

      function cleanupShortcutRecording() {
        isListeningForShortcut = false;
        pressedKeys.clear();
        clearTimeout(shortcutTimeout);
        overlayShortcutBtn.classList.remove("listening");

        if (currentKeyHandler) {
          document.removeEventListener("keydown", currentKeyHandler);
          currentKeyHandler = null;
        }
      }

      async function restoreSavedShortcutLabel() {
        await loadPreferencesCached();
        const prefs = getCachedPreferences();
        overlayShortcutBtn.textContent =
          prefs?.overlayShortcut || tUi("overlay-shortcut-btn", "Set Shortcut");
      }
      window.refreshShortcutLabel = () => {
        if (
          !overlayShortcutBtn ||
          overlayShortcutBtn.classList.contains("listening")
        )
          return;
        restoreSavedShortcutLabel();
      };

      // Overlay interaction shortcut functionality
      const overlayInteractShortcutBtn = document.getElementById(
        "overlay-interact-shortcut-btn",
      );
      const DEFAULT_OVERLAY_INTERACT_SHORTCUT = "\\";
      let isListeningForInteractShortcut = false;
      let pressedInteractKeys = new Set();
      let interactShortcutTimeout;
      let currentInteractKeyHandler = null;

      function formatInteractShortcutLabel(value) {
        if (!value) return "";
        return value
          .replace(/(^|\\+)AltGr(\\+|$)/g, (match, p1, p2) => {
            return `${p1}${tUi("overlay-interact-shortcut-btn", "Right Alt")}${p2}`;
          })
          .replace(/(^|\\+)Backslash(\\+|$)/gi, (match, p1, p2) => {
            return `${p1}\\${p2}`;
          });
      }

      function updateInteractShortcutInfoText() {
        const infoEl = document.getElementById(
          "overlay-interact-shortcut-info",
        );
        if (!infoEl) return;
        const titleText = tUi(
          "title.overlay-interact-shortcut-info",
          "Toggle interaction: press once to enable drag/scroll, press again to return to click-through. Requires a non-modifier key (e.g. \\).",
        );
        const ariaText = tUi("aria.overlay-interact-shortcut-info", titleText);
        infoEl.title = titleText;
        infoEl.setAttribute("aria-label", ariaText);
      }
      window.refreshInteractShortcutInfo = updateInteractShortcutInfoText;

      overlayInteractShortcutBtn?.addEventListener("click", () => {
        if (
          overlayInteractShortcutBtn.textContent === getPressKeysLabel() ||
          overlayInteractShortcutBtn.classList.contains("listening")
        ) {
          cleanupInteractShortcutRecording();
          restoreSavedInteractShortcutLabel();
          return;
        }

        if (isListeningForShortcut) {
          cleanupShortcutRecording();
          restoreSavedShortcutLabel();
        }

        overlayInteractShortcutBtn.textContent = getPressKeysLabel();
        overlayInteractShortcutBtn.classList.add("listening");
        isListeningForInteractShortcut = true;
        pressedInteractKeys.clear();

        const handleKeyDown = (e) => {
          if (!isListeningForInteractShortcut) return;

          e.preventDefault();
          pressedInteractKeys.add(normalizeShortcutKey(e));

          clearTimeout(interactShortcutTimeout);
          interactShortcutTimeout = setTimeout(() => {
            if (!isListeningForInteractShortcut) return;

            const combo = buildShortcutCombo(pressedInteractKeys, {
              allowSingle: true,
            });
            if (!combo) {
              overlayInteractShortcutBtn.textContent = tUi(
                "ui.shortcut.invalidCombo",
                "Invalid combo",
              );
              setTimeout(() => restoreSavedInteractShortcutLabel(), 1200);
            } else {
              overlayInteractShortcutBtn.textContent =
                formatInteractShortcutLabel(combo);
              window.api.savePreferences({ overlayInteractShortcut: combo });
            }

            cleanupInteractShortcutRecording();
          }, 400);
        };

        currentInteractKeyHandler = handleKeyDown;
        document.addEventListener("keydown", handleKeyDown);
      });

      function cleanupInteractShortcutRecording() {
        isListeningForInteractShortcut = false;
        pressedInteractKeys.clear();
        clearTimeout(interactShortcutTimeout);
        overlayInteractShortcutBtn?.classList.remove("listening");

        if (currentInteractKeyHandler) {
          document.removeEventListener("keydown", currentInteractKeyHandler);
          currentInteractKeyHandler = null;
        }
      }

      async function restoreSavedInteractShortcutLabel() {
        await loadPreferencesCached();
        const prefs = getCachedPreferences();
        overlayInteractShortcutBtn.textContent =
          formatInteractShortcutLabel(prefs?.overlayInteractShortcut) ||
          formatInteractShortcutLabel(DEFAULT_OVERLAY_INTERACT_SHORTCUT);
      }
      window.refreshInteractShortcutLabel = () => {
        if (
          !overlayInteractShortcutBtn ||
          overlayInteractShortcutBtn.classList.contains("listening")
        )
          return;
        restoreSavedInteractShortcutLabel();
      };

      // ==== FOLDERS TAB ‚Äì UI & IPC ====
      (function initFoldersTab() {
        const listEl = document.getElementById("foldersList");
        const addBtn = document.getElementById("foldersAddBtn");
        const rescanBtn = document.getElementById("foldersRescanBtn");

        if (!listEl || !addBtn || !rescanBtn) return;

        async function invoke(channel, ...args) {
          if (window.api?.invoke) return window.api.invoke(channel, ...args);
          if (window.electron?.ipcRenderer?.invoke)
            return window.electron.ipcRenderer.invoke(channel, ...args);
          console.warn(
            tUi(
              "log.ipcInvokeBridgeMissing",
              "IPC invoke bridge not found for",
            ),
            channel,
          );
          return null;
        }

        function renderFoldersList(folders) {
          listEl.innerHTML = "";

          const arr = Array.isArray(folders) ? folders : [];
          if (arr.length === 0) {
            listEl.innerHTML = `<div style="padding:15px; color:#aaa;"><small>${tUi(
              "folders.empty",
              "No watched folders yet.",
            )}</small></div>`;
            return;
          }

          for (const f of arr) {
            const folderPath = typeof f === "string" ? f : f?.path;
            const blocked = typeof f === "object" && !!f?.blocked;
            const isDefault = typeof f === "object" && !!f?.isDefault;
            const exists = typeof f === "object" ? f?.exists !== false : true;

            const row = document.createElement("div");
            row.className = "wf-row";
            if (blocked) row.classList.add("wf-row--blocked");
            if (!exists) row.classList.add("wf-row--missing");
            row.setAttribute("role", "listitem");
            row.dataset.folder = folderPath;

            const pathEl = document.createElement("div");
            pathEl.className = "wf-path";
            pathEl.title = folderPath;
            if (blocked)
              pathEl.dataset.status = tUi("folders.statusIgnored", "Ignored");
            else if (!exists)
              pathEl.dataset.status = tUi("folders.statusMissing", "Missing");
            else delete pathEl.dataset.status;
            pathEl.textContent = folderPath;

            const actions = document.createElement("div");
            actions.className = "wf-actions";

            //BLOCK
            const btnBlock = document.createElement("button");
            btnBlock.className = blocked
              ? "icon-btn unblock"
              : "icon-btn block";
            btnBlock.title = blocked
              ? tUi("tooltip.folderResume", "Resume watching")
              : tUi("tooltip.folderIgnore", "Ignore this folder");
            btnBlock.setAttribute("aria-label", btnBlock.title);
            btnBlock.innerHTML = blocked
              ? faWithFallback("fa-solid fa-bell-slash", "üîï") // ignore
              : faWithFallback("fa-solid fa-bell", "üîî"); // active
            btnBlock.addEventListener("click", async () => {
              const channel = blocked ? "folders:unblock" : "folders:block";
              const res = await invoke(channel, folderPath);
              if (res?.ok) renderFoldersList(res.folders);
              else
                alert(
                  res?.error ||
                    tUi("alert.folderUpdateFailed", "Failed to update folder"),
                );
            });

            // EDIT (‚úé)
            const btnEdit = document.createElement("button");
            btnEdit.className = "icon-btn edit";
            btnEdit.title = tUi("tooltip.folderEdit", "Edit folder");
            btnEdit.setAttribute("aria-label", btnEdit.title);
            btnEdit.innerHTML = faWithFallback("fa-regular fa-pen-to-square", "‚úé");
            btnEdit.addEventListener("click", async () => {
              let next = null;
              if (typeof window.api?.selectFolder === "function") {
                next = await window.api.selectFolder();
              }
              if (!next || next === folderPath) return;
              const rem = await invoke("folders:remove", folderPath);
              if (!rem?.ok) {
                alert(
                  rem?.error ||
                    tUi(
                      "alert.folderReplaceRemoveFailed",
                      "Failed to replace folder (remove step).",
                    ),
                );
                return;
              }

              const add = await invoke("folders:add", next);
              if (!add?.ok) {
                alert(
                  add?.error ||
                    tUi(
                      "alert.folderReplaceAddFailed",
                      "Failed to replace folder (add step).",
                    ),
                );
                await invoke("folders:add", folderPath);
                return;
              }
              renderFoldersList(add.folders);
            });

            // REMOVE
            const btnRemove = document.createElement("button");
            btnRemove.className = "icon-btn remove";
            btnRemove.title = tUi("tooltip.folderRemove", "Remove folder");
            btnRemove.setAttribute("aria-label", btnRemove.title);
            btnRemove.innerHTML = faWithFallback("fa-regular fa-trash-can", "üóë");
            btnRemove.addEventListener("click", async () => {
              const res = await invoke("folders:remove", folderPath);
              if (res?.ok) renderFoldersList(res.folders);
              else
                alert(
                  resolveFolderError(
                    res,
                    "alert.folderRemoveFailed",
                    "Failed to remove folder",
                  ),
                );
            });
            if (isDefault) {
              btnRemove.style.display = "none";
              btnEdit.style.display = "none";
            }

            actions.append(btnEdit, btnRemove, btnBlock);
            row.append(pathEl, actions);
            listEl.appendChild(row);
          }
        }

        async function loadFolders() {
          try {
            const res = await invoke("folders:list");
            renderFoldersList(res?.folders || []);
          } catch (e) {
            console.warn(
              tUi("log.foldersLoadFailed", "Failed to load folders:"),
              e,
            );
            renderFoldersList([]);
          }
        }

        function resolveFolderError(res, fallbackKey, fallbackText) {
          if (res && res.errorCode) {
            return tUi(`alert.${res.errorCode}`, res?.error || fallbackText);
          }
          return res?.error || tUi(fallbackKey, fallbackText);
        }

        addBtn.addEventListener("click", async () => {
          try {
            const dir = await (window.api?.selectFolder?.() ||
              invoke("selectFolder"));
            if (!dir) return;
            const res = await invoke("folders:add", dir);
            if (res?.ok) renderFoldersList(res.folders || []);
            else
              alert(
                resolveFolderError(
                  res,
                  "alert.folderAddFailed",
                  "Failed to add folder",
                ),
              );
          } catch (e) {
            console.error(tUi("log.folderAddError", "Add folder error:"), e);
          }
        });

        rescanBtn.addEventListener("click", async () => {
          try {
            const res = await invoke("folders:rescan");
            if (res?.ok) {
              renderFoldersList(res.folders || []);
            } else {
              alert(
                resolveFolderError(
                  res,
                  "alert.watcherRestartFailed",
                  "Failed to restart watchers",
                ),
              );
            }
          } catch (e) {
            console.error(tUi("log.folderRescanError", "Rescan error:"), e);
          }
        });

        document
          .getElementById("settingsBtn")
          ?.addEventListener("click", () => {
            setTimeout(loadFolders, 50);
          });

        window.refreshFoldersList = loadFolders;
        loadFolders();
      })();

      document.addEventListener("mousedown", (event) => {
        if (isListeningForShortcut && event.target !== overlayShortcutBtn) {
          cleanupShortcutRecording();
          restoreSavedShortcutLabel();
        }
        if (
          isListeningForInteractShortcut &&
          event.target !== overlayInteractShortcutBtn
        ) {
          cleanupInteractShortcutRecording();
          restoreSavedInteractShortcutLabel();
        }
      });

      // ==== DASHBOARD / GAMES LIST ====
      function setBackgroundInert(on) {
        const keep = new Set([
          "dashboardOverlay",
          "appSettingsDontHide",
          "titlebar",
          "appConfirmModal",
          "bootOnboardingModal",
        ]);

        Array.from(document.body.children).forEach((el) => {
          if (!(el instanceof HTMLElement)) return;

          if (keep.has(el.id)) {
            el.removeAttribute("aria-hidden");
            el.inert = false;
            return;
          }

          if (on) {
            el.setAttribute("aria-hidden", "true");
            el.inert = true;
          } else {
            el.removeAttribute("aria-hidden");
            el.inert = false;
          }
        });
      }
      function focusDashboardSearch(selectAll = true) {
        const input = document.getElementById("dashboardSearchInput");
        if (!input) return;
        if (!window.__dashboardOpen) {
          window.openDashboard?.();
          setTimeout(() => focusDashboardSearch(selectAll), 0);
          return;
        }
        input.focus({ preventScroll: true });
        if (selectAll) input.select();
      }
      window.focusDashboardSearch = focusDashboardSearch;

      function refocusDashboard() {
        if (!window.__dashboardOpen) return;
        const dash = document.getElementById("dashboardOverlay");
        if (!dash) return;

        const search = document.getElementById("dashboardSearchInput");
        const grid = document.getElementById("dashboardGrid");
        const activeCard = dash.querySelector(".dash-card.active");
        const firstCard = dash.querySelector(".dash-card");

        const target = activeCard || firstCard || grid || search;

        requestAnimationFrame(() => {
          target?.focus?.({ preventScroll: true });
        });
      }

      (function () {
        const dashboard = document.getElementById("dashboardOverlay");
        const gridEl = document.getElementById("dashboardGrid");
        const btnToggle = document.getElementById("toggleDashboardBtn");
        const btnClose = document.getElementById("closeDashboard");
        const dashboardContextMenu = document.getElementById(
          "dashboardContextMenu",
        );
        let dashboardContextTarget = null;
        let dashboardMenuIndex = 0;
        window.__dashboardContextMenuOpen = false;
        window.__dashboardContextMenuIgnoreClick = false;
        if (window.__dashboardNeedsRebuild !== true) {
          window.__dashboardNeedsRebuild = false;
        }

        const fileUrl = (p) =>
          p ? `file:///${String(p).replace(/\\/g, "/")}` : "";
        const fallbackIcon = new URL(
          "./assets/achievements-logo.png",
          window.location.href,
        ).toString();

        const scheduleIdle =
          typeof window.requestIdleCallback === "function"
            ? window.requestIdleCallback
            : (cb) => setTimeout(cb, 16);

        const runWithConcurrency = async (items, limit, worker) => {
          const list = Array.isArray(items) ? items : [];
          const max = Math.max(
            1,
            Math.min(Number(limit) || 1, list.length || 1),
          );
          const results = new Array(list.length);
          let nextIndex = 0;

          const runOne = async () => {
            for (;;) {
              const idx = nextIndex++;
              if (idx >= list.length) return;
              try {
                const value = await worker(list[idx], idx);
                results[idx] = { status: "fulfilled", value };
              } catch (err) {
                results[idx] = { status: "rejected", reason: err };
              }
            }
          };

          const workers = Array.from({ length: max }, () => runOne());
          await Promise.all(workers);
          return results;
        };

        const runWithBatching = async (items, batchSize, limit, worker) => {
          const list = Array.isArray(items) ? items : [];
          const size = Math.max(1, Number(batchSize) || 1);
          const out = [];
          for (let i = 0; i < list.length; i += size) {
            const batch = list.slice(i, i + size);
            const batchResults = await runWithConcurrency(batch, limit, worker);
            out.push(...batchResults);
            if (i + size < list.length && DASH_DETAIL_BATCH_PAUSE_MS > 0) {
              await new Promise((resolve) =>
                setTimeout(resolve, DASH_DETAIL_BATCH_PAUSE_MS),
              );
            }
          }
          return out;
        };

        const DASH_PROGRESS_PREFIX = "dashboard:lastProgress:";
        const dashboardConfigCache = new Map();
        const dashboardImageCache = new Map();
        let dashboardLazyObserver = null;
        const IMG_CACHE_PREFIX = "dashboard:lastImage:";
        const DASH_DETAIL_CONCURRENCY = 3;
        const DASH_DETAIL_BATCH_SIZE = 24;
        const DASH_DETAIL_BATCH_PAUSE_MS = 25;
        const DASH_BOOT_IMG_BATCH = 10;
        const dashImgQueue = [];
        const dashImgQueued = new Set();
        let dashImgFlushScheduled = false;
        let detailJobsSeedReady = window.__bootManualSeedComplete === true;
        const detailJobsSeedWaiters = [];

        const resolveDetailJobsSeedWaiters = () => {
          while (detailJobsSeedWaiters.length) {
            const resolve = detailJobsSeedWaiters.shift();
            try {
              resolve?.();
            } catch {}
          }
        };

        window.__onBootManualSeedComplete = () => {
          if (detailJobsSeedReady) return;
          detailJobsSeedReady = true;
          resolveDetailJobsSeedWaiters();
        };

        const waitForDetailJobsSeedReady = async (timeoutMs = 20000) => {
          if (detailJobsSeedReady || window.__bootManualSeedComplete === true) {
            detailJobsSeedReady = true;
            return;
          }
          const ms = Math.max(0, Number(timeoutMs) || 0);
          await new Promise((resolve) => {
            let done = false;
            const finish = () => {
              if (done) return;
              done = true;
              if (timer) clearTimeout(timer);
              const idx = detailJobsSeedWaiters.indexOf(finish);
              if (idx >= 0) detailJobsSeedWaiters.splice(idx, 1);
              resolve();
            };
            const timer = setTimeout(finish, ms);
            detailJobsSeedWaiters.push(finish);
          });
          if (window.__bootManualSeedComplete === true) {
            detailJobsSeedReady = true;
          }
        };

        const isDashboardBooting = () =>
          document.body.classList.contains("booting") ||
          window.__bootDone !== true;

        const queueDashboardImageLoad = (img, src) => {
          if (!img || !src) return;
          img.dataset.src = src;
          if (!isDashboardBooting()) {
            img.src = src;
            return;
          }
          if (dashImgQueued.has(img)) return;
          dashImgQueued.add(img);
          dashImgQueue.push(img);
          if (!dashImgFlushScheduled) {
            dashImgFlushScheduled = true;
            requestAnimationFrame(flushDashboardImageQueue);
          }
        };

        const flushDashboardImageQueue = (force = false) => {
          dashImgFlushScheduled = false;
          let count = 0;
          while (count < DASH_BOOT_IMG_BATCH && dashImgQueue.length) {
            const img = dashImgQueue.shift();
            dashImgQueued.delete(img);
            const src = img?.dataset?.src;
            if (src) img.src = src;
            count += 1;
          }
          if (dashImgQueue.length && (force || isDashboardBooting())) {
            dashImgFlushScheduled = true;
            requestAnimationFrame(() => flushDashboardImageQueue(force));
          }
        };

        const drainDashboardImageQueue = () => {
          if (!dashImgQueue.length) return;
          if (dashImgFlushScheduled) return;
          dashImgFlushScheduled = true;
          requestAnimationFrame(() => flushDashboardImageQueue(true));
        };
        window.__drainDashboardImageQueue = drainDashboardImageQueue;

        const ensureLazyObserver = () => {
          if (dashboardLazyObserver) return dashboardLazyObserver;

          if ("IntersectionObserver" in window) {
            dashboardLazyObserver = new IntersectionObserver(
              (entries) => {
                for (const entry of entries) {
                  if (!entry.isIntersecting) continue;
                  const img = entry.target;
                  dashboardLazyObserver.unobserve(img);
                  const src = img.dataset.src;
                  if (src)
                    scheduleIdle(() => queueDashboardImageLoad(img, src));
                }
              },
              { rootMargin: "80px" },
            );
          } else {
            dashboardLazyObserver = {
              observe(img) {
                scheduleIdle(() => {
                  const src = img.dataset?.src;
                  if (src) queueDashboardImageLoad(img, src);
                });
              },
              unobserve() {},
            };
          }
          return dashboardLazyObserver;
        };

        async function getConfigCached(name) {
          if (dashboardConfigCache.has(name))
            return dashboardConfigCache.get(name);
          try {
            const cfg = await window.api.getConfigByName(name);
            dashboardConfigCache.set(name, cfg);
            return cfg;
          } catch {
            dashboardConfigCache.set(name, null);
            return null;
          }
        }

        const normalizeDashboardImagePlatform = (value) =>
          String(value || "")
            .trim()
            .toLowerCase();

        const makeDashboardImageCacheKey = (appid, platform) => {
          const id = String(appid || "").trim();
          if (!id) return "";
          return `${id}::${normalizeDashboardImagePlatform(platform)}`;
        };

        const clearDashboardImageCacheByAppId = (appid) => {
          const id = String(appid || "").trim();
          if (!id) return;
          const prefix = `${id}::`;
          for (const key of Array.from(dashboardImageCache.keys())) {
            if (key === id || key.startsWith(prefix)) {
              dashboardImageCache.delete(key);
            }
          }
        };

        const applyDashboardCardImage = (img, src) => {
          if (!img || !src) return;
          img.dataset.src = src;
          ensureLazyObserver().observe(img);
          if (!isDashboardBooting()) {
            img.src = src;
          }
        };

        async function refreshDashboardImageByAppId(
          appid,
          platformHint = null,
        ) {
          const id = String(appid || "").trim();
          if (!id || !gridEl) return;

          const cards = Array.from(
            gridEl.querySelectorAll(".dash-card"),
          ).filter((card) => String(card?.dataset?.appid || "").trim() === id);
          if (!cards.length) return;

          const cardsByPlatform = new Map();
          for (const card of cards) {
            const platform = normalizeDashboardImagePlatform(
              card?.dataset?.platform,
            );
            if (!cardsByPlatform.has(platform)) {
              cardsByPlatform.set(platform, []);
            }
            cardsByPlatform.get(platform).push(card);
          }
          const hintedPlatform = normalizeDashboardImagePlatform(platformHint);
          const targetPlatforms =
            hintedPlatform && cardsByPlatform.has(hintedPlatform)
              ? [hintedPlatform]
              : Array.from(cardsByPlatform.keys());

          for (const platform of targetPlatforms) {
            const platformCards = cardsByPlatform.get(platform) || [];
            if (!platformCards.length) continue;

            let imgSrc = null;
            try {
              const localPath = await window.api.checkLocalGameImage(
                id,
                platform || null,
              );
              if (localPath) imgSrc = fileUrl(localPath);
            } catch {
              imgSrc = null;
            }

            const cacheKey = makeDashboardImageCacheKey(id, platform);
            if (imgSrc) {
              dashboardImageCache.set(cacheKey, imgSrc);
              for (const card of platformCards) {
                const name = String(card?.dataset?.name || "").trim();
                if (name) localStorage.setItem(IMG_CACHE_PREFIX + name, imgSrc);
              }
            } else {
              dashboardImageCache.delete(cacheKey);
              for (const card of platformCards) {
                const name = String(card?.dataset?.name || "").trim();
                if (name) localStorage.removeItem(IMG_CACHE_PREFIX + name);
              }
              imgSrc = fallbackIcon;
            }

            for (const card of platformCards) {
              const img = card.querySelector(".dash-thumb");
              if (!img) continue;
              applyDashboardCardImage(img, imgSrc);
            }
          }
        }

        if (!window.__dashboardImageListenerAttached) {
          window.api.onImageUpdate(async (payload) => {
            const appid =
              typeof payload === "object" && payload?.appid
                ? String(payload.appid)
                : /^\d+$/.test(String(payload))
                  ? String(payload)
                  : null;
            if (!appid) return;
            const platformHint =
              typeof payload === "object" && payload?.platform
                ? String(payload.platform)
                : null;
            await refreshDashboardImageByAppId(appid, platformHint);
          });
          window.__dashboardImageListenerAttached = true;
        }

        async function handleDashboardBlacklistAction(
          configName,
          appid,
          removeMode,
        ) {
          if (!appid) {
            alert(
              tUi(
                "alert.missingAppIdConfig",
                "Missing AppID for this configuration.",
              ),
            );
            return;
          }
          logUiEvent("info", "ui:blacklist-dashboard:click", {
            configName,
            appid,
            remove: removeMode,
          });
          const confirmed = await safeConfirm({
            title: removeMode
              ? tUi("confirm.blacklistRemove.title", "Remove from blacklist")
              : tUi("confirm.blacklistIgnore.title", "Ignore game"),
            message: removeMode
              ? tUiFmt(
                  "confirm.blacklistRemove.message",
                  { name: configName },
                  `Remove ${configName} from blacklist?`,
                )
              : tUiFmt(
                  "confirm.blacklistIgnore.message",
                  { name: configName },
                  `Ignore ${configName} and stop tracking it?`,
                ),
          });
          logUiEvent("info", "ui:blacklist-dashboard:confirm", {
            configName,
            appid,
            remove: removeMode,
            confirmed,
          });
          if (!confirmed) return;

          await safeRefocus();

          logUiEvent("info", "ui:blacklist-dashboard:ipc-start", {
            configName,
            appid,
            remove: removeMode,
          });
          const response = await window.api.blacklistConfig({
            configName,
            appid,
            remove: removeMode,
          });
          logUiEvent(
            response?.success ? "info" : "warn",
            "ui:blacklist-dashboard:ipc-result",
            {
              configName,
              appid,
              remove: removeMode,
              success: response?.success === true,
              error: response?.error || null,
            },
          );
          if (!response?.success) {
            alert(
              response?.error ||
                tUi(
                  "alert.blacklistUpdateFailed",
                  "Failed to update blacklist",
                ),
            );
            return;
          }

          localStorage.removeItem(`${DASH_PROGRESS_PREFIX}${configName}`);
          localStorage.removeItem(`${IMG_CACHE_PREFIX}${configName}`);
          clearDashboardImageCacheByAppId(appid);
          if (Array.isArray(response.blacklist)) {
            blacklistState.appids = new Set(response.blacklist);
          } else {
            await syncBlacklistList();
          }

          if (typeof reloadConfigsDropdown === "function") {
            await reloadConfigsDropdown(true);
          }
          await buildDashboard();
        }

        let __dashNav = { index: 0, cols: 1 };
        let __gpLoopId = null;

        function getDashCards(onlyVisible = true) {
          const all = Array.from(gridEl.querySelectorAll(".dash-card"));
          if (!onlyVisible) return all;
          return all.filter(
            (c) =>
              c.offsetParent !== null && getComputedStyle(c).display !== "none",
          );
        }

        function computeGridCols() {
          // Count columns from computed grid-template-columns
          const s = window.getComputedStyle(gridEl);
          const cols = (s.gridTemplateColumns || "")
            .split(" ")
            .filter(Boolean).length;
          __dashNav.cols = Math.max(1, cols || 1);
          return __dashNav.cols;
        }

        function focusCardAt(idx) {
          const cards = getDashCards();
          if (!cards.length) return;
          const n = cards.length;
          __dashNav.index = ((idx % n) + n) % n; // wrap
          const el = cards[__dashNav.index];
          setActiveCard(el.getAttribute("data-name") || "");
          el.focus({ preventScroll: true });
          el.scrollIntoView({ block: "nearest", inline: "nearest" });
          cards.forEach((c) =>
            c.querySelector(".dash-play")?.classList.remove("force-show"),
          );
          el.querySelector(".dash-play")?.classList.add("force-show");
        }

        function moveFocus(delta) {
          focusCardAt(__dashNav.index + delta);
        }

        function focusFirstVisibleDashCard() {
          if (!window.__dashboardOpen) return null;
          const body = document.getElementById("dashboardBody");
          const grid = document.getElementById("dashboardGrid");
          if (!body || !grid) return null;
          const bodyRect = body.getBoundingClientRect();
          const cards = Array.from(grid.querySelectorAll(".dash-card"))
            .filter(
              (card) =>
                card.offsetParent !== null &&
                getComputedStyle(card).display !== "none",
            )
            .map((card) => ({ card, rect: card.getBoundingClientRect() }));
          if (!cards.length) return null;

          const within = (rect, strict = false) =>
            strict
              ? rect.top >= bodyRect.top + 1 &&
                rect.bottom <= bodyRect.bottom - 1
              : rect.bottom > bodyRect.top + 1 &&
                rect.top < bodyRect.bottom - 1;

          const fullyVisible = cards.filter(({ rect }) => within(rect, true));
          const usable = fullyVisible.length
            ? fullyVisible
            : cards.filter(({ rect }) => within(rect));
          if (!usable.length) return null;

          usable.sort((a, b) =>
            a.rect.top !== b.rect.top
              ? a.rect.top - b.rect.top
              : a.rect.left - b.rect.left,
          );
          const topEdge = usable[0].rect.top;
          const row = usable
            .filter(({ rect }) => Math.abs(rect.top - topEdge) <= 5)
            .sort((a, b) => a.rect.left - b.rect.left);

          const el = (row[0] || usable[0]).card;
          if (!el) return null;

          const name = el.getAttribute("data-name") || "";
          if (name) setActiveCard(name);
          try {
            const all = getDashCards(false);
            __dashNav.index = Math.max(0, all.indexOf(el));
          } catch {}

          el.focus({ preventScroll: true });
          return el;
        }
        window.focusFirstVisibleDashCard = focusFirstVisibleDashCard;

        async function openDashboard() {
          if (isSettingsOpen()) {
            return;
          }
          dashboard.classList.add("open");
          document.body.style.overflow = "hidden";
          window.__dashboardOpen = true;
          try {
            window.api?.setDashboardOpen?.(true);
          } catch {}
          setBackgroundInert(true);
          const needsBuild =
            window.__dashboardNeedsRebuild === true ||
            window.__dashboardReady !== true ||
            !gridEl?.children?.length;
          if (needsBuild) {
            await buildDashboard();
          }
          enableDashboardHoverSync();
          requestAnimationFrame(() => {
            try {
              refocusDashboard();
            } catch {}
            if (dashboardBody) dashboardBody.scrollTop = dashboardScrollTop;
          });
          startDashboardPoll();
          installBgScrollBlockers();
        }
        function closeDashboard() {
          if (isSettingsOpen()) {
            return;
          }
          if (dashboardBody) dashboardScrollTop = dashboardBody.scrollTop;
          dashboard.classList.remove("open");
          document.body.style.overflow = "";
          window.__dashboardOpen = false;
          try {
            window.api?.setDashboardOpen?.(false);
          } catch {}
          closeDashboardContextMenu();
          clearDashboardSearch();
          stopDashboardPoll();
          setBackgroundInert(false);
          removeBgScrollBlockers();
        }
        window.openDashboard = openDashboard;
        window.closeDashboard = closeDashboard;
        window.dashboardFocusCardAt = focusCardAt;

        let startupDashboardAutoOpenPending = false;
        let startupDashboardOpenTriggered = false;

        function shouldAutoOpenDashboardOnStartup() {
          return window.__dashboardShowOnStart === true;
        }

        function maybePrepareDashboardForStartup() {
          if (!shouldAutoOpenDashboardOnStartup()) {
            startupDashboardAutoOpenPending = false;
            startupDashboardOpenTriggered = false;
            return;
          }
          if (
            window.__uiConfigsReady !== true ||
            window.__uiPresetsReady !== true
          ) {
            return;
          }
          startupDashboardAutoOpenPending = true;
        }

        function maybeOpenDashboardAfterStartupPrepare() {
          if (!startupDashboardAutoOpenPending) return;
          if (!shouldAutoOpenDashboardOnStartup()) {
            startupDashboardAutoOpenPending = false;
            startupDashboardOpenTriggered = false;
            return;
          }
          if (window.__bootDone !== true) return;
          // Open dashboard only after boot overlay is gone.
          if (document.body.classList.contains("booting")) return;
          if (window.__dashboardOpen) {
            startupDashboardOpenTriggered = true;
            startupDashboardAutoOpenPending = false;
            return;
          }
          if (startupDashboardOpenTriggered) return;
          startupDashboardOpenTriggered = true;
          startupDashboardAutoOpenPending = false;
          setTimeout(() => {
            window.openDashboard?.();
          }, 0);
        }

        window.__prepareDashboardForStartup = maybePrepareDashboardForStartup;
        window.__maybeOpenStartupDashboard =
          maybeOpenDashboardAfterStartupPrepare;

        // polling to refresh card progress in near-real-time
        const DASH_POLL_DEFAULT_MS = 4000;
        const DASH_POLL_SLOW_MS = 12000;
        const DASH_POLL_BATCH_SIZE = 20;
        const DASH_POLL_YIELD_MS = 0;
        let __dashboardPollId = null;
        let __dashboardPollActive = false;
        let __dashboardPollPaused = false;
        let __dashboardPollInterval = DASH_POLL_DEFAULT_MS;
        let __dashboardPollSkipped = false;
        window.__notificationBusy = false;
        async function yieldDashboardPoll() {
          if (DASH_POLL_YIELD_MS > 0) {
            await new Promise((resolve) =>
              setTimeout(resolve, DASH_POLL_YIELD_MS),
            );
            return;
          }
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
        function startDashboardPoll() {
          if (__dashboardPollPaused) return;
          if (__dashboardPollId) return;
          __dashboardPollId = setInterval(async () => {
            if (__dashboardPollActive) return;
            __dashboardPollActive = true;
            try {
              if (!window.__dashboardOpen || window.__notificationBusy) {
                __dashboardPollSkipped = true;
                return;
              }
              let anyChange = false;
              const cards = Array.from(gridEl.querySelectorAll(".dash-card"));
              let processed = 0;
              for (const card of cards) {
                if (!window.__dashboardOpen || window.__notificationBusy) {
                  __dashboardPollSkipped = true;
                  break;
                }
                const cfgName = card.getAttribute("data-name");
                if (!cfgName) continue;
                try {
                  const { pct } = await computeCardProgress(cfgName);
                  const key = `dashboard:lastProgress:${cfgName}`;
                  const prev = JSON.parse(localStorage.getItem(key) || "null");
                  const prevPct =
                    prev && typeof prev.pct === "number" ? prev.pct : null;
                  if (prevPct === null || prevPct !== pct) {
                    await updateCardProgressUI(card, cfgName);
                    anyChange = true;
                  }
                } catch (e) {
                  // ignore per-card errors
                }
                processed += 1;
                if (processed % DASH_POLL_BATCH_SIZE === 0) {
                  await yieldDashboardPoll();
                }
              }
              if (anyChange) {
                try {
                  window.applyDashboardSortAndFilter?.();
                } catch (e) {}
              }
              // after a slow cycle, return to default cadence
              if (
                __dashboardPollInterval !== DASH_POLL_DEFAULT_MS &&
                !__dashboardPollPaused
              ) {
                stopDashboardPoll();
                __dashboardPollInterval = DASH_POLL_DEFAULT_MS;
                startDashboardPoll();
              }
            } catch (e) {
              console.error(
                tUi("log.dashboardPollError", "Dashboard poll error:"),
                e,
              );
            } finally {
              __dashboardPollActive = false;
            }
          }, __dashboardPollInterval);
        }
        function stopDashboardPoll() {
          if (!__dashboardPollId) return;
          clearInterval(__dashboardPollId);
          __dashboardPollId = null;
          __dashboardPollActive = false;
        }
        function pauseDashboardPoll() {
          __dashboardPollPaused = true;
          stopDashboardPoll();
        }
        function resumeDashboardPoll() {
          __dashboardPollPaused = false;
          if (window.__dashboardOpen) startDashboardPoll();
        }

        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            stopDashboardPoll?.();
          } else if (window.__dashboardOpen) {
            startDashboardPoll?.();
          }
        });

        function setActiveCard(name) {
          document.querySelectorAll(".dash-card").forEach((el) => {
            el.classList.toggle(
              "active",
              el.getAttribute("data-name") === name,
            );
          });
        }

        function getDashboardContextCard() {
          const focused = document.querySelector(
            "#dashboardGrid .dash-card:focus",
          );
          const active = document.querySelector(
            "#dashboardGrid .dash-card.active",
          );
          return (
            focused ||
            active ||
            document.querySelector("#dashboardGrid .dash-card")
          );
        }

        function getDashboardMenuItems() {
          if (!dashboardContextMenu) return [];
          return Array.from(
            dashboardContextMenu.querySelectorAll(".dash-menu-item"),
          ).filter((btn) => !btn.disabled && btn.offsetParent !== null);
        }

        function setMenuItemDisabled(btn, disabled) {
          if (!btn) return;
          btn.disabled = !!disabled;
          btn.setAttribute("aria-disabled", disabled ? "true" : "false");
          btn.classList.toggle("is-disabled", !!disabled);
        }

        function updateDashboardContextMenuLabels(target) {
          if (!dashboardContextMenu || !target) return;
          const ignoreBtn = dashboardContextMenu.querySelector(
            '.dash-menu-item[data-action="ignore"]',
          );
          const regenBtn = dashboardContextMenu.querySelector(
            '.dash-menu-item[data-action="regen"]',
          );
          const removeMode =
            blacklistState.showBlacklisted && target.blacklisted;
          if (ignoreBtn) {
            ignoreBtn.textContent = removeMode
              ? tUi("dashboardMenuRemoveBlacklist", "Remove from Blacklist")
              : tUi("dashboardMenuIgnore", "Ignore Game");
            ignoreBtn.title = ignoreBtn.textContent;
          }
          setMenuItemDisabled(ignoreBtn, !target.appid);
          setMenuItemDisabled(regenBtn, !target.appid);
        }

        function focusDashboardMenuItem(index) {
          const items = getDashboardMenuItems();
          if (!items.length) return;
          const max = items.length;
          dashboardMenuIndex = ((index % max) + max) % max;
          const item = items[dashboardMenuIndex];
          if (item && typeof item.focus === "function") {
            item.focus({ preventScroll: true });
          }
        }

        function moveDashboardMenuFocus(delta) {
          focusDashboardMenuItem(dashboardMenuIndex + delta);
        }

        async function activateDashboardMenuItem() {
          const items = getDashboardMenuItems();
          const item = items[dashboardMenuIndex];
          if (item && typeof item.click === "function") {
            item.click();
          }
        }

        function closeDashboardContextMenu() {
          if (!dashboardContextMenu) return;
          const targetEl = dashboardContextTarget?.el || null;
          dashboardContextMenu.classList.add("hidden");
          dashboardContextMenu.setAttribute("aria-hidden", "true");
          dashboardContextMenu.style.left = "";
          dashboardContextMenu.style.top = "";
          window.__dashboardContextMenuOpen = false;
          dashboardContextTarget = null;
          if (targetEl && window.__dashboardOpen) {
            try {
              targetEl.focus({ preventScroll: true });
            } catch {}
          }
        }
        window.closeDashboardContextMenu = closeDashboardContextMenu;

        function positionDashboardContextMenu(x, y) {
          if (!dashboardContextMenu) return;
          const pad = 8;
          dashboardContextMenu.style.left = "0px";
          dashboardContextMenu.style.top = "0px";
          const rect = dashboardContextMenu.getBoundingClientRect();
          const maxLeft = Math.max(pad, window.innerWidth - rect.width - pad);
          const maxTop = Math.max(pad, window.innerHeight - rect.height - pad);
          const left = Math.min(Math.max(pad, x), maxLeft);
          const top = Math.min(Math.max(pad, y), maxTop);
          dashboardContextMenu.style.left = `${Math.round(left)}px`;
          dashboardContextMenu.style.top = `${Math.round(top)}px`;
        }

        function openDashboardContextMenuForCard(card, pos) {
          if (!dashboardContextMenu || !card) return;
          const target = {
            name: card.dataset.name || "",
            displayName: card.dataset.display || card.dataset.name || "",
            appid: card.dataset.appid || "",
            platform: card.dataset.platform || "",
            blacklisted: card.dataset.blacklisted === "1",
            el: card,
          };
          if (!target.name) return;
          dashboardContextTarget = target;
          updateDashboardContextMenuLabels(target);
          if (!target.appid) {
            getConfigCached(target.name).then((cfg) => {
              if (!window.__dashboardContextMenuOpen) return;
              if (!cfg || !cfg.appid) return;
              if (dashboardContextTarget?.name !== target.name) return;
              dashboardContextTarget.appid = String(cfg.appid);
              dashboardContextTarget.platform = cfg.platform || "";
              dashboardContextTarget.blacklisted = isAppIdInBlacklist(
                String(cfg.appid),
              );
              updateDashboardContextMenuLabels(dashboardContextTarget);
            });
          }
          dashboardContextMenu.classList.remove("hidden");
          dashboardContextMenu.setAttribute("aria-hidden", "false");
          window.__dashboardContextMenuOpen = true;
          if (pos && typeof pos.x === "number" && typeof pos.y === "number") {
            positionDashboardContextMenu(pos.x, pos.y);
          } else {
            const rect = card.getBoundingClientRect();
            positionDashboardContextMenu(rect.right - 8, rect.top + 8);
          }
          dashboardMenuIndex = 0;
          focusDashboardMenuItem(0);
        }

        function openDashboardContextMenuFromFocus() {
          if (!window.__dashboardOpen) return;
          const card = getDashboardContextCard();
          if (!card) return;
          openDashboardContextMenuForCard(card);
        }
        window.openDashboardContextMenuFromFocus =
          openDashboardContextMenuFromFocus;
        window.moveDashboardContextMenuFocus = moveDashboardMenuFocus;
        window.activateDashboardContextMenu = activateDashboardMenuItem;

        function openOptionsPanel() {
          const container = document.getElementById("buttonContainer");
          const toggle = document.getElementById("toggleBtn");
          if (!container || !toggle) return;

          container.classList.remove("hidden");
          container.style.display = "flex";

          toggle.textContent = tUi("ui.toggle.hideOptions", "Hide Options");
        }

        async function updateDashboardCounts(items, softStats = null) {
          const gamesEl = document.getElementById("gamesTotal");
          const perfectEl = document.getElementById("perfectTotal");
          const list = Array.isArray(items) ? items : [];
          if (gamesEl) gamesEl.textContent = String(list.length);
          if (!perfectEl) return;

          const isPerfect = (p) => {
            const total = Number(p?.total) || 0;
            const unlocked = Number(p?.unlocked) || 0;
            return total > 0 && unlocked === total;
          };

          const normalizeProgress = (entry) => {
            if (!entry || typeof entry !== "object") return null;
            if (entry.progress && typeof entry.progress === "object") {
              return entry.progress;
            }
            if (
              Object.prototype.hasOwnProperty.call(entry, "total") ||
              Object.prototype.hasOwnProperty.call(entry, "unlocked")
            ) {
              return entry;
            }
            return null;
          };

          const stats = Array.isArray(softStats) ? softStats : [];
          const namesSeen = new Set();
          let perfectCount = 0;

          for (const stat of stats) {
            const name = String(stat?.name || "").trim();
            if (name) namesSeen.add(name);
            const p = normalizeProgress(stat);
            if (p && isPerfect(p)) perfectCount += 1;
          }

          const allCovered =
            namesSeen.size > 0 && namesSeen.size >= list.length;
          if (allCovered) {
            perfectEl.textContent = String(perfectCount);
            return;
          }

          const missing = list.filter((it) => {
            const name = String(it?.name || "").trim();
            return name && !namesSeen.has(name);
          });

          if (!missing.length) {
            perfectEl.textContent = String(perfectCount);
            return;
          }

          // Defer missing computation until detail jobs finish to avoid spikes.
          perfectEl.textContent = String(perfectCount);
          return;
        }

        function setupDashboardSearch(gridEl) {
          const input = document.getElementById("dashboardSearchInput");
          if (!input || !gridEl) return;

          const norm = (s) =>
            (s || "")
              .toString()
              .toLowerCase()
              .normalize("NFD")
              .replace(/\p{Diacritic}/gu, "");

          const getCards = () => getDashCards(true);

          const prepareCards = () => {
            getCards().forEach((c) => {
              if (!c.dataset._search) {
                const name =
                  c.getAttribute("data-display") ||
                  c.getAttribute("data-name") ||
                  "";
                const appid = c.getAttribute("data-appid") || "";
                c.dataset._search = norm(name + " " + appid);
              }
            });
          };

          const applyFilter = () => {
            prepareCards();
            const q = norm(input.value.trim());
            const all = getDashCards(false);
            const hideBlacklisted = !blacklistState.showBlacklisted;

            if (!q) {
              all.forEach((c) => {
                const blocked =
                  hideBlacklisted && c.dataset.blacklisted === "1";
                c.style.display = blocked ? "none" : "";
              });
            } else {
              all.forEach((c) => {
                const matches = c.dataset._search.includes(q);
                const blocked =
                  hideBlacklisted && c.dataset.blacklisted === "1";
                c.style.display = matches && !blocked ? "" : "none";
              });
            }
          };

          if (input._filterHandler)
            input.removeEventListener("input", input._filterHandler);

          let filterDebounce = null;
          let focusIdleTimer = null;

          input._filterHandler = () => {
            clearTimeout(filterDebounce);
            filterDebounce = setTimeout(applyFilter, 60);
          };
          input.addEventListener("input", input._filterHandler);

          input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              const v = getCards();
              if (v.length) {
                e.preventDefault();
                v[0].click();
              }
            } else if (e.key === "ArrowDown") {
              const v = getCards();
              if (v.length) {
                e.preventDefault();
                __dashNav.index = 0;
                focusCardAt(0);
                gridEl.focus();
              }
            } else if (e.key === "Escape") {
              if (input.value) {
                input.value = "";
                applyFilter();
              } else {
                try {
                  closeDashboard();
                } catch {}
              }
            }
          });

          input.resetSearch = () => {
            input.value = "";
            applyFilter();
          };

          prepareCards();
          applyFilter();
        }

        window.applyDashboardSortAndFilter = applyDashboardSortAndFilter;

        let __dashboardReadySent = false;
        function signalDashboardReady() {
          if (__dashboardReadySent) return;
          __dashboardReadySent = true;
          try {
            window.__dashboardReady = true;
          } catch {}
          try {
            window.__markUiDataReady?.();
          } catch {}
          try {
            window.api?.dashboardReady?.();
          } catch {}
          try {
            window.__maybeOpenStartupDashboard?.();
          } catch {}
        }

        function clearDashboardSearch() {
          const input = document.getElementById("dashboardSearchInput");
          if (!input) return;
          if (typeof input.resetSearch === "function") {
            input.resetSearch();
          } else {
            input.value = "";
            const hideBlacklisted = !blacklistState.showBlacklisted;
            document
              .querySelectorAll("#dashboardGrid .dash-card")
              .forEach((c) => {
                const blocked =
                  hideBlacklisted && c.dataset.blacklisted === "1";
                c.style.display = blocked ? "none" : "";
              });
          }
          input.blur();
        }
        window.clearDashboardSearch = clearDashboardSearch;

        let __dashboardBuildPromise = null;
        let __dashboardBuildRequested = false;
        async function buildDashboard() {
          __dashboardBuildRequested = true;
          if (__dashboardBuildPromise) return __dashboardBuildPromise;
          __dashboardBuildPromise = (async () => {
            while (__dashboardBuildRequested) {
              __dashboardBuildRequested = false;
              await buildDashboardOnce();
            }
            window.__dashboardNeedsRebuild = false;
          })().finally(() => {
            __dashboardBuildPromise = null;
          });
          return __dashboardBuildPromise;
        }

        async function buildDashboardOnce() {
          if (!gridEl || !window.api) return;
          try {
            await syncBlacklistList();

            // load configs and enrich with basic metadata
            let items = normalizeConfigList(await window.api.loadConfigs());
            cacheConfigMeta(items);
            if (!blacklistState.showBlacklisted) {
              items = items.filter((cfg) => !isAppIdInBlacklist(cfg.appid));
            }

            const quickCards = items.map((it) => {
              const key = DASH_PROGRESS_PREFIX + it.name;
              let stored = null;
              try {
                stored = JSON.parse(localStorage.getItem(key) || "null");
              } catch {
                stored = null;
              }
              const normalized = {
                pct: Number(stored?.pct) || 0,
                unlocked: Number(stored?.unlocked) || 0,
                total: Number(stored?.total) || 0,
                updated: Number(stored?.updated) || 0,
              };
              const imgCacheKey = IMG_CACHE_PREFIX + it.name;
              const cachedImg = localStorage.getItem(imgCacheKey);

              return {
                name: it.name,
                displayName: it.displayName || it.name,
                appid: it.appid || null,
                executable: it.executable || null,
                arguments: it.arguments || "",
                blacklisted: it.appid ? isAppIdInBlacklist(it.appid) : false,
                progress: normalized,
                img: cachedImg || fallbackIcon,
                hasCachedImg: Boolean(cachedImg),
              };
            });

            gridEl.innerHTML = "";
            const cardMeta = new Map();
            const shouldChunkDashboard = () =>
              document.body.classList.contains("booting") ||
              window.__bootDone !== true;
            const bootChunkMode = shouldChunkDashboard();

            const buildDashCard = (cardData, container) => {
              const card = document.createElement("div");
              card.className = "dash-card";
              card.tabIndex = 0;
              card.setAttribute("role", "button");
              card.setAttribute(
                "aria-label",
                `${cardData.displayName} ‚Äì ${cardData.progress.pct}% complete`,
              );
              card.dataset.name = cardData.name;
              card.dataset.display = cardData.displayName;
              card.dataset.pct = String(cardData.progress.pct);
              card.dataset.unlocked = String(cardData.progress.unlocked);
              card.dataset.total = String(cardData.progress.total);
              card.dataset.updated = String(cardData.progress.updated);
              card.dataset.blacklisted = cardData.blacklisted ? "1" : "0";
              if (cardData.appid) {
                card.dataset.appid = String(cardData.appid);
              }

              const pill = document.createElement("div");
              pill.className = "dash-progresspill";
              pill.textContent = tUiFmt(
                "dashboardCompletePct",
                { pct: cardData.progress.pct },
                `${cardData.progress.pct}% Complete`,
              );

              const img = document.createElement("img");
              img.className = "dash-thumb";
              img.loading = "lazy";
              img.decoding = "async";
              img.alt = cardData.displayName;
              img.src = bootChunkMode ? fallbackIcon : cardData.img;
              if (cardData.img) {
                img.dataset.src = cardData.img;
              }
              ensureLazyObserver().observe(img);

              const nameWrap = document.createElement("div");
              nameWrap.className = "dash-name";
              const title = document.createElement("div");
              title.className = "dash-title";
              title.title = cardData.displayName;
              title.textContent = cardData.displayName;
              const bar = document.createElement("div");
              bar.className = "dash-progressbar";
              const span = document.createElement("span");
              span.style.width = `${cardData.progress.pct}%`;
              bar.appendChild(span);

              nameWrap.appendChild(title);
              nameWrap.appendChild(bar);

              card.appendChild(pill);
              card.appendChild(img);
              card.appendChild(nameWrap);
              (container || gridEl).appendChild(card);

              return {
                element: card,
                pill,
                bar: span,
                img,
                data: { ...cardData },
              };
            };

            if (!bootChunkMode) {
              quickCards.forEach((cardData) => {
                const meta = buildDashCard(cardData);
                cardMeta.set(cardData.name, meta);
              });
            } else {
              const chunkSize = 20;
              for (let i = 0; i < quickCards.length; i += chunkSize) {
                const frag = document.createDocumentFragment();
                const max = Math.min(i + chunkSize, quickCards.length);
                for (let j = i; j < max; j += 1) {
                  const cardData = quickCards[j];
                  const meta = buildDashCard(cardData, frag);
                  cardMeta.set(cardData.name, meta);
                }
                gridEl.appendChild(frag);
                await new Promise(requestAnimationFrame);
              }
            }

            // image loading is handled by IntersectionObserver + boot queue

            setupDashboardSearch(gridEl);
            updateDashboardCounts(items, quickCards);
            updateSortIconsUI();
            applyDashboardSortAndFilter();

            (async () => {
              await waitForDetailJobsSeedReady(20000);
              const resolved = await runWithBatching(
                items,
                DASH_DETAIL_BATCH_SIZE,
                DASH_DETAIL_CONCURRENCY,
                async (it) => {
                  const meta = cardMeta.get(it.name);
                  if (!meta) return null;

                  const cfg = await getConfigCached(it.name);
                  const appid = cfg?.appid ? String(cfg.appid) : null;
                  if (appid) {
                    meta.element.dataset.appid = appid;
                    meta.data.appid = appid;
                  }
                  const platform = cfg?.platform || null;
                  const normalizedPlatform =
                    normalizeDashboardImagePlatform(platform);
                  const cardBlacklisted = appid && isAppIdInBlacklist(appid);
                  meta.element.dataset.blacklisted = cardBlacklisted
                    ? "1"
                    : "0";
                  meta.data.blacklisted = cardBlacklisted;
                  if (platform) {
                    meta.data.platform = platform;
                    meta.element.dataset.platform = platform;
                  }
                  const applyDashboardImg = (img, src) => {
                    if (!img || !src) return;
                    img.dataset.src = src;
                    ensureLazyObserver().observe(img);
                    if (!bootChunkMode) {
                      img.src = src;
                    }
                  };
                  let imgSrc = null;
                  if (appid) {
                    const dashboardCacheKey = makeDashboardImageCacheKey(
                      appid,
                      normalizedPlatform,
                    );
                    if (meta.data?.hasCachedImg && meta.data?.img) {
                      imgSrc = meta.data.img;
                      dashboardImageCache.set(dashboardCacheKey, imgSrc);
                    } else if (dashboardImageCache.has(dashboardCacheKey)) {
                      imgSrc = dashboardImageCache.get(dashboardCacheKey);
                    } else {
                      try {
                        const p = await window.api.checkLocalGameImage(
                          appid,
                          normalizedPlatform || null,
                        );
                        imgSrc = p ? fileUrl(p) : null;
                      } catch {
                        imgSrc = null;
                      }
                      if (imgSrc) {
                        dashboardImageCache.set(dashboardCacheKey, imgSrc);
                        localStorage.setItem(
                          IMG_CACHE_PREFIX + it.name,
                          imgSrc,
                        );
                      } else {
                        dashboardImageCache.delete(dashboardCacheKey);
                        localStorage.removeItem(IMG_CACHE_PREFIX + it.name);
                      }
                    }

                    if (imgSrc) {
                      applyDashboardImg(meta.img, imgSrc);
                      localStorage.setItem(IMG_CACHE_PREFIX + it.name, imgSrc);
                    } else {
                      applyDashboardImg(meta.img, fallbackIcon);
                    }
                    const cardImg = meta.img;
                    if (cardImg) {
                      cardImg.addEventListener("error", () => {
                        applyDashboardImg(cardImg, fallbackIcon);
                        localStorage.removeItem(IMG_CACHE_PREFIX + it.name);
                      });
                    }
                  }

                  const progress = await computeCardProgress(it.name);
                  localStorage.setItem(
                    DASH_PROGRESS_PREFIX + it.name,
                    JSON.stringify(progress),
                  );

                  meta.bar.style.width = `${progress.pct}%`;
                  meta.pill.textContent = tUiFmt(
                    "dashboardCompletePct",
                    { pct: progress.pct },
                    `${progress.pct}% Complete`,
                  );
                  meta.element.dataset.pct = String(progress.pct);
                  meta.element.dataset.unlocked = String(progress.unlocked);
                  meta.element.dataset.total = String(progress.total);
                  meta.element.dataset.updated = String(progress.updated || 0);
                  meta.data.progress = progress;

                  return meta.data;
                },
              );
              const ready = resolved
                .map((r) => (r.status === "fulfilled" ? r.value : null))
                .filter((it) => it && it.progress);
              if (ready.length) {
                updateDashboardCounts(items, ready);
                scheduleIdle(() => updateDashboardCounts(items, ready));
                applyDashboardSortAndFilter();
              }
              signalDashboardReady();
            })().catch(() => {
              signalDashboardReady();
            });

            (async function injectPlayButtons() {
              const cards = Array.from(gridEl.querySelectorAll(".dash-card"));
              const names = cards.map((c) => c.dataset.name).filter(Boolean);

              const chunkButtons = bootChunkMode && cards.length > 30;
              const processCard = (card, idx) => {
                const cfgName = names[idx];
                const meta = cardMeta.get(cfgName);
                const data = meta?.data || {};
                const exe = data.executable || null;
                const args = data.arguments || "";
                if (card.querySelector(".dash-play") || 
                        window.electron.platform() === "linux") return;

                const btn = document.createElement("button");
                btn.className = "dash-play";
                btn.setAttribute("aria-label", tUi("dashboard.play", "Play"));
                btn.title = exe
                  ? tUi("dashboard.play", "Play")
                  : tUi("dashboard.noExecutable", "No executable set");
                btn.innerHTML = faWithFallback("fas fa-play", "‚ñ∂");

                if (!exe) {
                  btn.classList.add("is-disabled");
                  btn.setAttribute("aria-disabled", "true");
                  btn.setAttribute("tabindex", "-1");
                }

                const swallowIfDisabled = (e) => {
                  if (btn.classList.contains("is-disabled")) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    return false;
                  }
                };
                [
                  "click",
                  "pointerdown",
                  "pointerup",
                  "mousedown",
                  "mouseup",
                ].forEach((t) =>
                  btn.addEventListener(t, swallowIfDisabled, true),
                );

                btn.addEventListener("click", async (ev) => {
                  ev.preventDefault();
                  ev.stopPropagation();
                  if (btn.classList.contains("is-disabled")) return;

                  try {
                    const preset =
                      document.getElementById("presetDropdown")?.value;
                    const position =
                      document.getElementById("positionDropdown")?.value;

                    await window.api.updateConfig({
                      configName: cfgName,
                      preset,
                      position,
                    });

                    const sel = document.getElementById("configList");
                    if (sel) {
                      sel.value = cfgName;
                      sel.dispatchEvent(new Event("change", { bubbles: true }));
                    }
                  } catch {}
                  closeDashboard?.();

                  const container = document.getElementById("buttonContainer");
                  const toggleBtn = document.getElementById("toggleBtn");
                  if (container) {
                    container.classList.remove("hidden");
                    container.style.display = "flex";
                  }
                  if (toggleBtn)
                    toggleBtn.textContent = tUi(
                      "ui.toggle.hideOptions",
                      "Hide Options",
                    );

                  if (exe) window.api.launchExecutable(exe, args);
                });

                const appidValue = data.appid ? String(data.appid) : null;
                const cardBlacklisted =
                  appidValue && isAppIdInBlacklist(appidValue);
                card.dataset.blacklisted = cardBlacklisted ? "1" : "0";

                const blockBtn = document.createElement("button");
                blockBtn.className = "dash-block";
                const removing =
                  blacklistState.showBlacklisted && cardBlacklisted;
                blockBtn.setAttribute(
                  "aria-label",
                  removing
                    ? tUi(
                        "dashboard.blacklistRemoveLabel",
                        "Remove from blacklist",
                      )
                    : tUi("dashboard.blacklistIgnoreLabel", "Ignore game"),
                );
                blockBtn.title = removing
                  ? tUi(
                      "dashboard.blacklistRemoveTitle",
                      "Remove this game from blacklist",
                    )
                  : tUi(
                      "dashboard.blacklistIgnoreTitle",
                      "Stop tracking this game",
                    );
                blockBtn.innerHTML = removing
                  ? faWithFallback("fa-solid fa-check", "‚úì")
                  : faWithFallback("fa-solid fa-ban", "‚õî");
                blockBtn.addEventListener("click", async (ev) => {
                  ev.preventDefault();
                  ev.stopPropagation();
                  try {
                    if (!appidValue) return;
                    const removeMode =
                      blacklistState.showBlacklisted && cardBlacklisted;
                    await handleDashboardBlacklistAction(
                      cfgName,
                      appidValue,
                      removeMode,
                    );
                  } catch (err) {
                    logUiError("ui:blacklist-dashboard-failed", err);
                    alert(
                      tUi(
                        "alert.blacklistUpdateFailedDetails",
                        "Failed to update blacklist. See logs for details.",
                      ),
                    );
                  }
                });

                card.appendChild(blockBtn);
                card.appendChild(btn);
              };

              if (!chunkButtons) {
                cards.forEach(processCard);
              } else {
                const chunkSize = 20;
                for (let i = 0; i < cards.length; i += chunkSize) {
                  const max = Math.min(i + chunkSize, cards.length);
                  for (let j = i; j < max; j += 1) {
                    processCard(cards[j], j);
                  }
                  await new Promise(requestAnimationFrame);
                }
              }
            })();
            computeGridCols();
            const cards = getDashCards();
          } finally {
            // no-op: loop in buildDashboard handles pending rebuilds
          }
        }

        if (dashboardContextMenu && !window.__dashboardContextMenuWired) {
          window.__dashboardContextMenuWired = true;
          window.__dashboardContextMenuIgnoreClick = false;

          dashboardContextMenu.addEventListener("click", async (e) => {
            const btn = e.target.closest(".dash-menu-item");
            if (!btn || btn.disabled) return;
            e.preventDefault();
            e.stopPropagation();
            const action = btn.dataset.action || "";
            const target = dashboardContextTarget;
            if (!target || !target.name) return;

            closeDashboardContextMenu();
            try {
              if (action === "edit") {
                await window.openEditConfigModalByName?.(target.name);
                return;
              }
              if (action === "delete") {
                await deleteConfigByName(target.name, target.displayName);
                return;
              }
              if (action === "ignore") {
                const cfg = await getConfigCached(target.name);
                const appid = target.appid || cfg?.appid || "";
                const isBlacklisted = appid
                  ? isAppIdInBlacklist(String(appid))
                  : false;
                const removeMode =
                  blacklistState.showBlacklisted && isBlacklisted;
                await handleDashboardBlacklistAction(
                  target.name,
                  String(appid || ""),
                  removeMode,
                );
                return;
              }
              if (action === "regen") {
                const cfg = await getConfigCached(target.name);
                const appid = target.appid || cfg?.appid || "";
                const platform = target.platform || cfg?.platform || "auto";
                if (!appid) {
                  showNotification(
                    tUi(
                      "alert.missingAppIdConfigShort",
                      "Missing AppID for this config.",
                    ),
                    "#f44336",
                  );
                  return;
                }
                pendingSchemaRefresh = {
                  appid: String(appid).trim(),
                  name: target.name,
                };
                const result = await window.api.regenerateSchema({
                  name: target.name,
                  appid,
                  platform,
                });
                showNotification(
                  result?.message || "Schema regeneration finished.",
                  result?.success ? "#4CAF50" : "#f44336",
                );
                if (result?.success && configList?.value === target.name) {
                  const lang =
                    document.getElementById("languageSelect")?.value ||
                    "english";
                  try {
                    await buildMainAchievementsTable(target.name, lang);
                  } catch (err) {
                    console.error(
                      tUi(
                        "log.refreshAchievementsFailed",
                        "Refresh achievements table failed:",
                      ),
                      err,
                    );
                  }
                }
              }
            } catch (err) {
              console.error(
                tUi(
                  "log.dashboardMenuActionFailed",
                  "Dashboard menu action failed:",
                ),
                err,
              );
            }
          });

          dashboardContextMenu.addEventListener("contextmenu", (e) => {
            e.preventDefault();
            e.stopPropagation();
          });

          document.addEventListener(
            "pointerdown",
            (e) => {
              if (!window.__dashboardContextMenuOpen) return;
              if (e.target.closest("#dashboardContextMenu")) return;
              window.__dashboardContextMenuIgnoreClick = true;
              closeDashboardContextMenu();
              setTimeout(() => {
                window.__dashboardContextMenuIgnoreClick = false;
              }, 0);
            },
            true,
          );

          gridEl.addEventListener("contextmenu", (e) => {
            if (!window.__dashboardOpen) return;
            const card = e.target.closest(".dash-card");
            if (!card) return;
            e.preventDefault();
            e.stopPropagation();
            openDashboardContextMenuForCard(card, {
              x: e.clientX,
              y: e.clientY,
            });
          });
        }
        try {
          window.buildDashboard = buildDashboard;
        } catch {}

        const dashboardSchemaCache = new Map();
        const dashboardSavedCache = new Map();

        async function getSchemaCached(cfgName) {
          if (dashboardSchemaCache.has(cfgName)) {
            return dashboardSchemaCache.get(cfgName);
          }
          const achData = await window.api.loadAchievementData(cfgName);
          const list = Array.isArray(achData?.achievements)
            ? achData.achievements
            : [];
          dashboardSchemaCache.set(cfgName, list);
          return list;
        }

        async function getSavedCached(cfgName) {
          if (dashboardSavedCache.has(cfgName)) {
            return dashboardSavedCache.get(cfgName);
          }
          const saved = await window.api.loadSavedAchievements(cfgName);
          const savedMap = saved?.achievements || {};
          dashboardSavedCache.set(cfgName, savedMap);
          return savedMap;
        }

        async function computeCardProgress(cfgName) {
          try {
            const [list, savedMap] = await Promise.all([
              getSchemaCached(cfgName),
              getSavedCached(cfgName),
            ]);
            if (!list.length)
              return { pct: 0, unlocked: 0, total: 0, updated: 0 };

            let unlocked = 0;
            let maxTs = 0;
            for (const a of list) {
              const s = savedMap[a.name];
              if (s?.earned) unlocked++;
              const t = Number(s?.earned_time || 0);
              if (t > 0) {
                const tsMs = String(t).length === 10 ? t * 1000 : t;
                if (tsMs > maxTs) maxTs = tsMs;
              }
            }
            return {
              pct: Math.round((unlocked / list.length) * 100),
              unlocked,
              total: list.length,
              updated: maxTs,
            };
          } catch {
            return { pct: 0, unlocked: 0, total: 0, updated: 0 };
          }
        }

        async function updateCardProgressUI(cardEl, cfgName) {
          const { pct, unlocked, total, updated } =
            await computeCardProgress(cfgName);
          const bar = cardEl.querySelector(".dash-progressbar > span");
          const pill = cardEl.querySelector(".dash-progresspill");
          if (bar) bar.style.width = pct + "%";
          if (pill) {
            pill.textContent = tUiFmt(
              "dashboardCompletePct",
              { pct },
              `${pct}% Complete`,
            );
            pill.title = total
              ? `Unlocked ${unlocked} / ${total}`
              : "No achievements found";
          }

          cardEl.dataset.pct = String(pct);
          cardEl.dataset.unlocked = String(unlocked);
          cardEl.dataset.total = String(total);
          cardEl.dataset.updated = String(updated || 0);

          const st =
            typeof getMultiSortState === "function"
              ? getMultiSortState()
              : null;
          if (st && (st.progress !== "off" || st.updated !== "off")) {
            applyDashboardSortAndFilter();
          }
        }

        try {
          window.updateCardProgressUI = updateCardProgressUI;
        } catch {}

        function clearDashboardSavedCache(cfgName) {
          if (!cfgName) return;
          dashboardSavedCache.delete(cfgName);
        }
        function clearDashboardSchemaCache(cfgName) {
          if (!cfgName) return;
          dashboardSchemaCache.delete(cfgName);
        }
        function clearDashboardCachesFor(cfgName) {
          if (!cfgName) return;
          clearDashboardSavedCache(cfgName);
          clearDashboardSchemaCache(cfgName);
        }
        try {
          window.__clearDashboardSavedCache = clearDashboardSavedCache;
          window.__clearDashboardSchemaCache = clearDashboardSchemaCache;
          window.__clearDashboardCachesFor = clearDashboardCachesFor;
        } catch {}

        setupDashboardSearch(gridEl);

        function selectConfigInDropdown(name) {
          const sel = document.getElementById("configList");
          if (!sel) return false;

          const opt = Array.from(sel.options).find(
            (o) => o.value === name || o.text.trim() === name,
          );
          if (opt) {
            sel.value = opt.value;
            sel.dispatchEvent(new Event("change", { bubbles: true }));
            return true;
          }
          return false;
        }
        function openCardFromDashboard(card) {
          if (!card) return;
          const safeName = card.getAttribute("data-name");

          if (typeof window.setActiveCard === "function") {
            window.setActiveCard(safeName);
          } else {
            document.querySelectorAll(".dash-card").forEach((el) => {
              el.classList.toggle(
                "active",
                el.getAttribute("data-name") === safeName,
              );
            });
          }

          const selectInDropdown =
            typeof window.selectConfigInDropdown === "function"
              ? window.selectConfigInDropdown
              : function (name) {
                  const sel = document.getElementById("configList");
                  if (!sel) return false;
                  const opt = Array.from(sel.options).find(
                    (o) => o.value === name || o.text.trim() === name,
                  );
                  if (opt) {
                    sel.value = opt.value;
                    sel.dispatchEvent(new Event("change", { bubbles: true }));
                    return true;
                  }
                  return false;
                };

          const ok = selectInDropdown(safeName);
          if (!ok && window.api?.updateConfig) {
            window.api.updateConfig({ configName: safeName });
          }

          const input = document.getElementById("dashboardSearchInput");
          if (input && typeof input.resetSearch === "function")
            input.resetSearch();

          const container = document.getElementById("buttonContainer");
          const toggle = document.getElementById("toggleBtn");
          if (container) {
            container.classList.remove("hidden");
            container.style.display = "flex";
          }
          if (toggle)
            toggle.textContent = tUi("ui.toggle.hideOptions", "Hide Options");

          closeDashboard();
        }
        window.openCardFromDashboard = openCardFromDashboard;
        window.setActiveCard = setActiveCard;
        window.selectConfigInDropdown = selectConfigInDropdown;
        gridEl.onclick = (e) => {
          if (
            window.__dashboardContextMenuOpen ||
            window.__dashboardContextMenuIgnoreClick
          ) {
            closeDashboardContextMenu();
            window.__dashboardContextMenuIgnoreClick = false;
            return;
          }
          const card = e.target.closest(".dash-card");
          if (!card) return;
          openCardFromDashboard(card);

          const safeName = card.getAttribute("data-name");
          setActiveCard(safeName);

          const ok = selectConfigInDropdown(safeName);
          if (!ok && window.api?.updateConfig) {
            window.api.updateConfig({ configName: safeName });
          }
          const input = document.getElementById("dashboardSearchInput");
          if (input && typeof input.resetSearch === "function") {
            input.resetSearch();
          }

          openOptionsPanel();
          closeDashboard();
        };

        // --- MULTI-SORT ---
        const SORT_KEYS = ["name", "progress", "updated"];
        const STORE = {
          name: "dashSort:name",
          progress: "dashSort:progress",
          updated: "dashSort:updated",
        };

        function getMultiSortState() {
          return {
            name: localStorage.getItem(STORE.name) || "asc",
            progress: localStorage.getItem(STORE.progress) || "off",
            updated: localStorage.getItem(STORE.updated) || "off",
          };
        }
        function cycle(v) {
          return v === "off" ? "asc" : v === "asc" ? "desc" : "off";
        }

        function setSort(mode) {
          const st = getMultiSortState();
          st[mode] = cycle(st[mode]);
          localStorage.setItem(STORE[mode], st[mode]);
          updateSortIconsUI(st);
          applyDashboardSortAndFilter();
        }
        window.__dashboardCycleSort = setSort;

        function updateSortIconsUI(st = getMultiSortState()) {
          const setBtn = (id, state, title) => {
            const btn = document.getElementById(id);
            if (!btn) return;
            btn.classList.toggle("active", state !== "off");
            const dirEl = btn.querySelector(".dir");
            if (dirEl)
              dirEl.textContent =
                state === "asc" ? "‚Üë" : state === "desc" ? "‚Üì" : "¬∑";
            if (title) btn.title = title;
          };
          setBtn(
            "sort-name",
            st.name,
            tUi("title.sort-name-cycle", "Sort by name (A-Z / Z-A / Off)"),
          );
          setBtn(
            "sort-progress",
            st.progress,
            tUi(
              "title.sort-progress-cycle",
              "Sort by progress (low-high / high-low / Off)",
            ),
          );
          setBtn(
            "sort-time",
            st.updated,
            tUi(
              "title.sort-time-cycle",
              "Sort by last updated (oldest-newest / newest-oldest / Off)",
            ),
          );
        }

        function applyDashboardSortAndFilter() {
          const grid = document.getElementById("dashboardGrid");
          if (!grid) return;
          const dashboardBody = document.getElementById("dashboardBody");
          const isCardVisibleInViewport = (card) => {
            if (!card) return false;
            if (
              card.offsetParent === null ||
              getComputedStyle(card).display === "none"
            ) {
              return false;
            }
            if (!dashboardBody) return true;
            const bodyRect = dashboardBody.getBoundingClientRect();
            const rect = card.getBoundingClientRect();
            return (
              rect.bottom > bodyRect.top + 1 && rect.top < bodyRect.bottom - 1
            );
          };

          const st = getMultiSortState();
          const focusedEl = grid.querySelector(".dash-card:focus");
          const activeEl = grid.querySelector(".dash-card.active");
          const keepEl = isCardVisibleInViewport(focusedEl)
            ? focusedEl
            : isCardVisibleInViewport(activeEl)
              ? activeEl
              : null;
          const keepName = keepEl?.dataset?.name || null;
          const cardStates = Array.from(
            grid.querySelectorAll(".dash-card"),
          ).map((card) => ({
            card,
            display: card.style.display,
          }));

          const pri = ["updated", "progress", "name"];
          const mult = (k) => (st[k] === "asc" ? 1 : st[k] === "desc" ? -1 : 0);

          const cmp = (a, b) => {
            const cardA = a.card;
            const cardB = b.card;
            for (const k of pri) {
              const m = mult(k);
              if (!m) continue;

              if (k === "updated") {
                const da = Number(cardA.dataset.updated || 0),
                  db = Number(cardB.dataset.updated || 0);
                if (da !== db) return (da - db) * m;
              } else if (k === "progress") {
                const pa = Number(cardA.dataset.pct || 0),
                  pb = Number(cardB.dataset.pct || 0);
                if (pa !== pb) return (pa - pb) * m;
              } else if (k === "name") {
                const na =
                  cardA.getAttribute("data-display") ||
                  cardA.getAttribute("data-name") ||
                  "";
                const nb =
                  cardB.getAttribute("data-display") ||
                  cardB.getAttribute("data-name") ||
                  "";
                const res = na.localeCompare(nb, undefined, {
                  sensitivity: "base",
                });
                if (res !== 0) return res * m;
              }
            }
            const na =
              cardA.getAttribute("data-display") ||
              cardA.getAttribute("data-name") ||
              "";
            const nb =
              cardB.getAttribute("data-display") ||
              cardB.getAttribute("data-name") ||
              "";
            return na.localeCompare(nb, undefined, { sensitivity: "base" });
          };

          cardStates.sort(cmp);
          const frag = document.createDocumentFragment();
          cardStates.forEach(({ card, display }) => {
            card.style.display = display;
            frag.appendChild(card);
          });
          grid.appendChild(frag);

          let restoredFocus = false;
          if (keepName) {
            const keepCard = grid.querySelector(
              `.dash-card[data-name="${CSS.escape(keepName)}"]`,
            );
            if (keepCard) {
              const keepVisible = isCardVisibleInViewport(keepCard);
              if (keepVisible) {
                setActiveCard(keepName);
                if (document.activeElement !== keepCard) {
                  keepCard.focus({ preventScroll: true });
                }
                try {
                  __dashNav.index = Math.max(
                    0,
                    getDashCards(false).indexOf(keepCard),
                  );
                } catch {}
                restoredFocus = true;
              }
            }
          }

          if (!restoredFocus) {
            window.focusFirstVisibleDashCard?.();
          }
        }

        window.applyDashboardSortAndFilter = applyDashboardSortAndFilter;

        (function () {
          document
            .getElementById("sort-name")
            ?.addEventListener("click", () => setSort("name"));
          document
            .getElementById("sort-progress")
            ?.addEventListener("click", () => setSort("progress"));
          document
            .getElementById("sort-time")
            ?.addEventListener("click", () => setSort("updated"));

          window.addEventListener("DOMContentLoaded", updateSortIconsUI);
        })();

        document.addEventListener("keydown", (e) => {
          if (window.__unifiedNavActive) return;
          if (e.key !== "Escape") return;
          if (window.__dashboardContextMenuOpen) {
            closeDashboardContextMenu();
            return;
          }
          const settingsOpen = !document
            .getElementById("settingsMenu")
            ?.classList.contains("hidden");
          if (settingsOpen) return;
          const onboardingOpen = !document
            .getElementById("bootOnboardingModal")
            ?.classList.contains("hidden");
          if (onboardingOpen) return;
          closeDashboard();
        });

        window.api?.on?.("auto-select-config", (safeName) =>
          setActiveCard(safeName),
        );
        window.api?.on?.("refresh-achievements-table", () => {});
        const bootLoadingEl = document.getElementById("bootLoading");
        let bootImageDrainTimer = null;
        const scheduleBootImageDrain = () => {
          if (bootImageDrainTimer) return;
          bootImageDrainTimer = setTimeout(() => {
            bootImageDrainTimer = null;
            const runDrain = () => {
              try {
                window.__drainDashboardImageQueue?.();
              } catch {}
            };
            if (typeof window.requestIdleCallback === "function") {
              window.requestIdleCallback(runDrain, { timeout: 1200 });
            } else {
              setTimeout(runDrain, 0);
            }
          }, 450);
        };
        const setBootLoading = (visible) => {
          if (!bootLoadingEl) return;
          document.body.classList.toggle("booting", !!visible);
          bootLoadingEl.classList.toggle("hidden", !visible);
          bootLoadingEl.setAttribute("aria-hidden", visible ? "false" : "true");
          if (visible) {
            if (bootImageDrainTimer) {
              clearTimeout(bootImageDrainTimer);
              bootImageDrainTimer = null;
            }
            return;
          }
          scheduleBootImageDrain();
        };
        setBootLoading(true);
        const bootTitleEl = document.querySelector(
          "#bootLoading .boot-loading-title",
        );
        const bootSubEl = document.querySelector(
          "#bootLoading .boot-loading-sub",
        );
        const refreshBootLoadingText = () => {
          if (bootTitleEl)
            bootTitleEl.textContent = tUi("boot.loading.title", "Booting‚Ä¶");
          if (bootSubEl)
            bootSubEl.textContent = tUi(
              "boot.loading.sub",
              "Preparing achievements cache",
            );
        };
        window.refreshBootLoadingText = refreshBootLoadingText;
        refreshBootLoadingText();
        let bootNoticeShown = false;
        window.__bootUiReady = false;
        window.__bootDone = false;
        window.__bootManualSeedComplete = false;
        window.__uiDataReady = false;
        window.__uiConfigsReady = false;
        window.__uiPresetsReady = false;
        if (window.__dashboardReady !== true) {
          window.__dashboardReady = false;
        }
        if (window.__dashboardShowOnStart === undefined) {
          window.__dashboardShowOnStart = null;
        }
        const bootOnboardingModal = document.getElementById(
          "bootOnboardingModal",
        );
        const bootOnboardingTitle = document.getElementById(
          "bootOnboardingTitle",
        );
        const bootOnboardingMessage = document.getElementById(
          "bootOnboardingMessage",
        );
        const bootOnboardingList =
          document.getElementById("bootOnboardingList");
        const bootOnboardingHint =
          document.getElementById("bootOnboardingHint");
        const bootOnboardingActions = document.getElementById(
          "bootOnboardingActions",
        );
        const bootOnboardingStartBtn = document.getElementById(
          "bootOnboardingStartBtn",
        );
        const bootOnboardingSkipBtn = document.getElementById(
          "bootOnboardingSkipBtn",
        );
        const bootOnboardingDone =
          document.getElementById("bootOnboardingDone");
        const bootOnboardingDoneMessage = document.getElementById(
          "bootOnboardingDoneMessage",
        );
        const bootOnboardingDoneOkBtn = document.getElementById(
          "bootOnboardingDoneOkBtn",
        );
        let bootOnboardingPromptActive = false;
        let bootOnboardingPromptDone = false;
        let bootOnboardingBusy = false;
        let bootOnboardingCandidates = [];
        let bootOnboardingLastFocus = null;
        const BOOT_ONBOARDING_SEARCH_STAGE_MIN_MS = 900;
        const BOOT_ONBOARDING_POST_RESULT_DELAY_MS = 280;
        const BOOT_ONBOARDING_EMPTY_STAGE_DELAY_MS = 750;
        const waitOnboardingDelay = (ms) =>
          ms > 0
            ? new Promise((resolve) => setTimeout(resolve, ms))
            : Promise.resolve();

        const setBootOnboardingModalVisible = (visible) => {
          if (!bootOnboardingModal) return;
          if (visible) {
            bootOnboardingLastFocus = document.activeElement;
            bootOnboardingModal.classList.remove("hidden");
            bootOnboardingModal.setAttribute("aria-hidden", "false");
            document.body.classList.add("modal-open");
            return;
          }
          bootOnboardingModal.classList.add("hidden");
          bootOnboardingModal.setAttribute("aria-hidden", "true");
          document.body.classList.remove("modal-open");
          if (
            bootOnboardingLastFocus &&
            typeof bootOnboardingLastFocus.focus === "function"
          ) {
            try {
              bootOnboardingLastFocus.focus({ preventScroll: true });
            } catch {}
          }
          bootOnboardingLastFocus = null;
        };

        const setBootOnboardingBusy = (busy) => {
          bootOnboardingBusy = busy === true;
          if (bootOnboardingStartBtn) bootOnboardingStartBtn.disabled = busy;
          if (bootOnboardingSkipBtn) bootOnboardingSkipBtn.disabled = busy;
        };

        const renderBootOnboardingSearchingState = () => {
          if (!bootOnboardingList) return;
          bootOnboardingList.innerHTML = "";
          const searching = document.createElement("div");
          searching.className = "boot-onboarding-hint";
          searching.textContent = tUi(
            "boot.onboarding.searching",
            "Searching folders‚Ä¶",
          );
          bootOnboardingList.appendChild(searching);
        };

        const onboardingSignalLabel = (id) => {
          const key = String(id || "").trim();
          if (!key) return "";
          const map = {
            "achievements-json": "achievements.json",
            "achievements-ini": "achievements.ini",
            "stats-bin": "stats.bin",
            "user-stats-ini": "user_stats.ini",
            "xenia-gpd": ".gpd",
            "rpcs3-trophy": "tropusr.dat/tropconf.sfm",
            "ps4-trophy": "trop.xml",
            "steam-official-bin": "UserGameStatsSchema_*.bin",
            "tenoke-ini": "tenoke.ini",
            "gog-info": "*.info",
          };
          return map[key] || key;
        };

        const renderBootOnboardingCandidates = (candidates) => {
          if (!bootOnboardingList) return;
          bootOnboardingList.innerHTML = "";
          const list = Array.isArray(candidates) ? candidates : [];
          if (!list.length) {
            const empty = document.createElement("div");
            empty.className = "boot-onboarding-hint";
            empty.textContent = tUi(
              "boot.onboarding.empty",
              "No folders with known achievement files were discovered.",
            );
            bootOnboardingList.appendChild(empty);
            return;
          }
          for (const candidate of list) {
            const pathValue = String(candidate?.path || "").trim();
            if (!pathValue) continue;
            const row = document.createElement("label");
            row.className = "boot-onboarding-row";
            row.setAttribute("role", "listitem");

            const checkbox = document.createElement("input");
            checkbox.type = "checkbox";
            checkbox.value = pathValue;
            checkbox.checked = candidate?.blocked !== true;

            const main = document.createElement("span");
            main.className = "boot-onboarding-row-main";

            const pathEl = document.createElement("span");
            pathEl.className = "boot-onboarding-path";
            pathEl.textContent = pathValue;

            const meta = document.createElement("span");
            meta.className = "boot-onboarding-meta";
            const signals = Array.isArray(candidate?.signals)
              ? candidate.signals.map(onboardingSignalLabel).filter(Boolean)
              : [];
            const tags = [];
            if (candidate?.recommended) {
              tags.push(
                `<span class="recommended">${tUi(
                  "boot.onboarding.recommended",
                  "Recommended",
                )}</span>`,
              );
            }
            if (candidate?.blocked) {
              tags.push(
                `<span class="muted">${tUi(
                  "boot.onboarding.muted",
                  "Muted currently",
                )}</span>`,
              );
            }
            if (signals.length) tags.push(signals.join(", "));
            meta.innerHTML = tags.join(" ‚Ä¢ ");

            main.append(pathEl, meta);
            row.append(checkbox, main);
            bootOnboardingList.appendChild(row);
          }
        };

        const getBootOnboardingSelectedPaths = () => {
          if (!bootOnboardingList) return [];
          const checked = Array.from(
            bootOnboardingList.querySelectorAll(
              'input[type="checkbox"]:checked',
            ),
          );
          return checked
            .map((input) => String(input?.value || "").trim())
            .filter(Boolean);
        };

        const showBootOnboardingCompletion = (messageText) => {
          if (bootOnboardingActions)
            bootOnboardingActions.classList.add("hidden");
          if (bootOnboardingDone) bootOnboardingDone.classList.remove("hidden");
          if (bootOnboardingDoneMessage) {
            bootOnboardingDoneMessage.textContent = messageText || "";
          }
          if (bootOnboardingHint) bootOnboardingHint.textContent = "";
          if (bootOnboardingDoneOkBtn) {
            setTimeout(() => bootOnboardingDoneOkBtn.focus(), 0);
          }
        };

        const finalizeBootOnboardingSkipAll = async (options = {}) => {
          const { showCompletion = true, closeModalOnSuccess = false } =
            options || {};
          setBootOnboardingBusy(true);
          let result = null;
          try {
            result = await window.api.skipBootOnboarding();
          } catch (err) {
            result = { ok: false, error: err?.message || String(err) };
          }
          if (!result?.ok) {
            if (bootOnboardingHint) {
              bootOnboardingHint.textContent =
                result?.error ||
                tUi("boot.onboarding.skipFailed", "Failed to skip onboarding.");
            }
            setBootOnboardingBusy(false);
            return result;
          }
          bootOnboardingPromptDone = true;
          if (showCompletion) {
            showBootOnboardingCompletion(
              tUi(
                "boot.onboarding.skippedDone",
                "Auto-config was skipped. Discovered folders were muted.",
              ),
            );
          } else if (closeModalOnSuccess) {
            setBootOnboardingModalVisible(false);
          }
          try {
            window.refreshFoldersList?.();
          } catch {}
          setBootOnboardingBusy(false);
          return result;
        };

        const runBootOnboardingFlow = async () => {
          if (bootOnboardingPromptActive || bootOnboardingPromptDone) return;
          if (!window.api?.getBootOnboardingState) {
            bootOnboardingPromptDone = true;
            return;
          }
          bootOnboardingPromptActive = true;
          let state = null;
          try {
            state = await window.api.getBootOnboardingState();
          } catch {}
          if (!state?.required) {
            bootOnboardingPromptDone = true;
            bootOnboardingPromptActive = false;
            return;
          }
          if (
            !bootOnboardingModal ||
            !bootOnboardingList ||
            !bootOnboardingStartBtn ||
            !bootOnboardingSkipBtn
          ) {
            try {
              await window.api.skipBootOnboarding?.();
            } catch {}
            bootOnboardingPromptDone = true;
            bootOnboardingPromptActive = false;
            return;
          }
          if (bootOnboardingTitle) {
            bootOnboardingTitle.textContent = tUi(
              "boot.onboarding.title",
              "Choose folders for Auto-Config",
            );
          }
          if (bootOnboardingMessage) {
            bootOnboardingMessage.textContent = tUi(
              "boot.onboarding.message",
              "Was found folders with achievement data. Select which folders should be scanned automatically.",
            );
          }
          if (bootOnboardingActions) {
            bootOnboardingActions.classList.remove("hidden");
          }
          if (bootOnboardingDone) bootOnboardingDone.classList.add("hidden");
          if (bootOnboardingStartBtn) {
            bootOnboardingStartBtn.textContent = tUi(
              "boot.onboarding.start",
              "Start Auto-Config",
            );
          }
          if (bootOnboardingSkipBtn) {
            bootOnboardingSkipBtn.textContent = tUi(
              "boot.onboarding.skip",
              "Skip and mute all",
            );
          }
          if (bootOnboardingDoneOkBtn) {
            bootOnboardingDoneOkBtn.textContent = tUi(
              "boot.onboarding.ok",
              "OK",
            );
          }
          if (bootOnboardingHint) {
            bootOnboardingHint.textContent = "";
          }
          setBootOnboardingModalVisible(true);
          setBootOnboardingBusy(true);
          renderBootOnboardingSearchingState();
          const discoveryStartedAt = Date.now();
          let discovery = null;
          try {
            discovery = await window.api.discoverBootOnboardingFolders?.();
          } catch (err) {
            discovery = { ok: false, candidates: [], error: err?.message };
          }
          const discoveryElapsedMs = Date.now() - discoveryStartedAt;
          if (discoveryElapsedMs < BOOT_ONBOARDING_SEARCH_STAGE_MIN_MS) {
            await waitOnboardingDelay(
              BOOT_ONBOARDING_SEARCH_STAGE_MIN_MS - discoveryElapsedMs,
            );
          }
          if (bootOnboardingPromptDone) {
            bootOnboardingPromptActive = false;
            return;
          }
          bootOnboardingCandidates = Array.isArray(discovery?.candidates)
            ? discovery.candidates
            : [];
          renderBootOnboardingCandidates(bootOnboardingCandidates);
          if (bootOnboardingHint) {
            if (!discovery?.ok) {
              bootOnboardingHint.textContent = tUi(
                "boot.onboarding.searchFailed",
                "Folder search failed. You can skip and continue.",
              );
            } else if (!bootOnboardingCandidates.length) {
              bootOnboardingHint.textContent = tUi(
                "boot.onboarding.noCandidates",
                "No candidate folders found. Use Skip and mute all to continue.",
              );
              await waitOnboardingDelay(BOOT_ONBOARDING_EMPTY_STAGE_DELAY_MS);
            } else {
              const count = bootOnboardingCandidates.length;
              bootOnboardingHint.textContent = tUiFmt(
                "boot.onboarding.foundCount",
                { count: String(count) },
                `Found ${count} folder(s).`,
              );
              await waitOnboardingDelay(BOOT_ONBOARDING_POST_RESULT_DELAY_MS);
            }
          }
          setBootOnboardingBusy(false);
          if (bootOnboardingStartBtn) {
            bootOnboardingStartBtn.disabled =
              bootOnboardingBusy || bootOnboardingCandidates.length === 0;
          }
          if (bootOnboardingSkipBtn) {
            bootOnboardingSkipBtn.disabled = bootOnboardingBusy;
          }
          setTimeout(() => {
            if (bootOnboardingCandidates.length === 0) {
              bootOnboardingSkipBtn?.focus();
            } else {
              bootOnboardingStartBtn?.focus();
            }
          }, 0);
        };

        const maybeStartBootOnboarding = () => {
          if (bootOnboardingPromptDone || bootOnboardingPromptActive) return;
          if (document.body.classList.contains("booting")) return;
          runBootOnboardingFlow().catch(() => {
            bootOnboardingPromptActive = false;
          });
        };

        const maybeHideBootLoading = () => {
          if (bootNoticeShown) return;
          if (!window.__uiDataReady) return;
          bootNoticeShown = true;
          setBootLoading(false);
          try {
            window.api?.bootOverlayHidden?.();
          } catch {}
          maybeStartBootOnboarding();
          window.__maybeOpenStartupDashboard?.();
        };
        window.__maybeHideBootLoading = maybeHideBootLoading;
        window.__markUiDataReady = () => {
          if (window.__uiDataReady) return;
          const dashPref = window.__dashboardShowOnStart;
          if (dashPref === null) return;
          if (!window.__uiConfigsReady || !window.__uiPresetsReady) return;
          if (window.__bootDone !== true) return;
          window.__prepareDashboardForStartup?.();
          window.__uiDataReady = true;
          maybeHideBootLoading();
        };
        window.api
          ?.getBootStatus?.()
          .then((status) => {
            if (status?.uiReady) {
              window.__bootUiReady = true;
            }
            if (status?.bootDone) {
              window.__bootDone = true;
            }
            if (status?.bootManualSeedComplete) {
              window.__bootManualSeedComplete = true;
              window.__onBootManualSeedComplete?.();
            }
            window.__prepareDashboardForStartup?.();
            window.__markUiDataReady?.();
            maybeHideBootLoading();
            maybeStartBootOnboarding();
          })
          .catch(() => {});
        window.api?.on?.("boot:ui-ready", () => {
          window.__bootUiReady = true;
          maybeStartBootOnboarding();
        });
        window.api?.on?.("boot:complete", () => {
          window.__bootDone = true;
          showNotification(
            tUi("notify.bootComplete", "Boot Complete!"),
            "#4CAF50",
          );
          window.__prepareDashboardForStartup?.();
          window.__markUiDataReady?.();
          maybeStartBootOnboarding();
        });
        window.api?.on?.("boot:onboarding:show", () => {
          maybeStartBootOnboarding();
        });
        window.api?.on?.("boot:onboarding:done", () => {
          bootOnboardingPromptDone = true;
          bootOnboardingPromptActive = false;
        });
        window.api?.on?.("boot:onboarding:attention", (payload = {}) => {
          if (bootOnboardingPromptDone) return;
          maybeStartBootOnboarding();
          const waitedMs = Math.max(0, Number(payload?.waitedMs || 0) || 0);
          const waitedSec = Math.max(1, Math.round(waitedMs / 1000));
          const hintText = tUiFmt(
            "boot.onboarding.attention",
            { seconds: String(waitedSec) },
            `Startup is waiting for your folder selection (${waitedSec}s).`,
          );
          if (
            bootOnboardingModal &&
            !bootOnboardingModal.classList.contains("hidden") &&
            bootOnboardingHint &&
            !bootOnboardingBusy
          ) {
            bootOnboardingHint.textContent = hintText;
            return;
          }
          if (
            bootOnboardingModal &&
            bootOnboardingPromptActive &&
            bootOnboardingModal.classList.contains("hidden")
          ) {
            setBootOnboardingModalVisible(true);
            if (bootOnboardingHint && !bootOnboardingBusy) {
              bootOnboardingHint.textContent = hintText;
            }
          }
        });
        window.api?.on?.("boot:onboarding:error", (payload = {}) => {
          const message =
            payload?.message ||
            tUi("boot.onboarding.error", "Boot onboarding error.");
          if (
            bootOnboardingModal &&
            !bootOnboardingModal.classList.contains("hidden") &&
            bootOnboardingHint
          ) {
            bootOnboardingHint.textContent = message;
          }
          showNotification(message, "#ff9800");
        });
        if (bootOnboardingStartBtn) {
          bootOnboardingStartBtn.addEventListener("click", async () => {
            if (bootOnboardingBusy) return;
            setBootOnboardingBusy(true);
            const selectedPaths = getBootOnboardingSelectedPaths();
            let result = null;
            try {
              result =
                await window.api.applyBootOnboardingSelection(selectedPaths);
            } catch (err) {
              result = { ok: false, error: err?.message || String(err) };
            }
            if (!result?.ok) {
              if (bootOnboardingHint) {
                bootOnboardingHint.textContent =
                  result?.error ||
                  tUi(
                    "boot.onboarding.applyFailed",
                    "Failed to apply folder selection.",
                  );
              }
              setBootOnboardingBusy(false);
              return;
            }
            const message =
              selectedPaths.length > 0
                ? tUiFmt(
                    "boot.onboarding.startedWithCount",
                    { count: String(selectedPaths.length) },
                    `Auto-Config started in background for ${selectedPaths.length} folder(s). Games will appear after config creation.`,
                  )
                : tUi(
                    "boot.onboarding.startedMuted",
                    "No folders selected. All discovered folders were muted for auto-config.",
                  );
            bootOnboardingPromptDone = true;
            showBootOnboardingCompletion(message);
            try {
              window.refreshFoldersList?.();
            } catch {}
            setBootOnboardingBusy(false);
          });
        }
        if (bootOnboardingSkipBtn) {
          bootOnboardingSkipBtn.addEventListener("click", async () => {
            if (bootOnboardingBusy) return;
            await finalizeBootOnboardingSkipAll({
              showCompletion: true,
              closeModalOnSuccess: false,
            });
          });
        }
        if (bootOnboardingDoneOkBtn) {
          bootOnboardingDoneOkBtn.addEventListener("click", () => {
            setBootOnboardingModalVisible(false);
          });
        }
        if (bootOnboardingList) {
          bootOnboardingList.addEventListener("keydown", (event) => {
            if (
              !bootOnboardingModal ||
              bootOnboardingModal.classList.contains("hidden")
            ) {
              return;
            }
            const scrollable =
              bootOnboardingList.scrollHeight >
              bootOnboardingList.clientHeight + 2;
            if (!scrollable) return;
            if (event.key === "PageDown") {
              event.preventDefault();
              event.stopPropagation();
              bootOnboardingList.scrollTop += Math.max(
                120,
                Math.round(bootOnboardingList.clientHeight * 0.9),
              );
              return;
            }
            if (event.key === "PageUp") {
              event.preventDefault();
              event.stopPropagation();
              bootOnboardingList.scrollTop -= Math.max(
                120,
                Math.round(bootOnboardingList.clientHeight * 0.9),
              );
              return;
            }
            if (event.key === "Home") {
              event.preventDefault();
              event.stopPropagation();
              bootOnboardingList.scrollTop = 0;
              return;
            }
            if (event.key === "End") {
              event.preventDefault();
              event.stopPropagation();
              bootOnboardingList.scrollTop = bootOnboardingList.scrollHeight;
            }
          });
        }
        document.addEventListener("keydown", (event) => {
          if (
            !bootOnboardingModal ||
            bootOnboardingModal.classList.contains("hidden")
          ) {
            return;
          }
          if (event.key === "Escape") {
            event.preventDefault();
            event.stopPropagation();
          }
        });
        window.api?.on?.("boot:manual-seed-complete", () => {
          window.__bootManualSeedComplete = true;
          window.__onBootManualSeedComplete?.();
        });
        window.api?.on?.("dashboard:poll-pause", (state) => {
          if (state) {
            pauseDashboardPoll();
          } else {
            __dashboardPollInterval = DASH_POLL_SLOW_MS;
            resumeDashboardPoll();
          }
        });
        window.api?.on?.("show-notification", (_data) => {
          window.__notificationBusy = true;
          setTimeout(() => {
            window.__notificationBusy = false;
            if (__dashboardPollSkipped && window.__dashboardOpen) {
              __dashboardPollSkipped = false;
              stopDashboardPoll();
              startDashboardPoll();
            }
          }, 1200);
        });
        window.api?.on?.("achievements:file-updated", (payload) => {
          const cfg = payload?.configName;
          if (cfg) {
            dashboardSavedCache.delete(cfg);
          }
        });
        window.api?.on?.("configs:changed", () => {
          dashboardSchemaCache.clear();
          dashboardSavedCache.clear();
        });
      })();

      // Zoom model:
      // - __userZoom: preference from UI dropdown.
      // - __effectiveZoom: webContents zoom (userZoom / display scale).
      let __userZoom = 1;
      let __effectiveZoom = 1;
      // Extra size boost only for fullscreen + 200% zoom (requested behavior).
      const DASH_FULLSCREEN_ZOOM200_THRESHOLD = 1.99;
      const DASH_FULLSCREEN_ZOOM200_BOOST = 1.3;
      const ZOOM_LOG_EPS = 0.001;
      let __lastZoomLog = null;
      let __isMaximized = false;
      let __displayWorkArea = null;

      const refreshDisplayWorkArea = async () => {
        if (!window.api?.getDisplayWorkArea) return;
        try {
          const metrics = await window.api.getDisplayWorkArea();
          if (
            metrics &&
            typeof metrics.width === "number" &&
            typeof metrics.height === "number"
          ) {
            __displayWorkArea = metrics;
          }
        } catch {}
      };

      const getViewportDimensions = () => {
        const viewport = {
          width:
            document.documentElement?.clientWidth || window.innerWidth || 0,
          height:
            document.documentElement?.clientHeight || window.innerHeight || 0,
        };

        if (
          __displayWorkArea &&
          typeof __displayWorkArea.width === "number" &&
          typeof __displayWorkArea.height === "number"
        ) {
          const zoom = Math.max(__effectiveZoom || 1, 0.01);
          viewport.width = Math.min(
            viewport.width,
            __displayWorkArea.width / zoom,
          );
          viewport.height = Math.min(
            viewport.height,
            __displayWorkArea.height / zoom,
          );
        } else if (window.visualViewport) {
          viewport.width = Math.min(
            viewport.width,
            window.visualViewport.width,
          );
          viewport.height = Math.min(
            viewport.height,
            window.visualViewport.height,
          );
        }

        return viewport;
      };
      function throttle(fn, wait = 100) {
        let timeout = null;
        let last = 0;
        const invoke = (...args) => {
          last = performance.now();
          timeout = null;
          fn(...args);
        };
        return (...args) => {
          const elapsed = performance.now() - last;
          if (elapsed >= wait) {
            if (timeout) clearTimeout(timeout);
            invoke(...args);
            return;
          }
          if (timeout) clearTimeout(timeout);
          timeout = setTimeout(() => invoke(...args), wait - elapsed);
        };
      }
      function computeDashSize() {
        const { width: vw, height: vh } = getViewportDimensions();
        const baseW = Math.min(
          __isMaximized ? 1600 : 1400,
          Math.max(860, (__isMaximized ? 0.995 : 0.98) * vw),
        );
        const baseH = Math.min(
          __isMaximized ? 1180 : 1080,
          Math.max(560, (__isMaximized ? 0.97 : 0.92) * vh),
        );

        let factor = 1;
        const zoom = Math.max(__userZoom || 1, 0.01);
        if (Math.abs(zoom - 1) > 0.001) {
          factor = 1 / zoom;
          if (zoom <= 0.75) {
            factor *= 0.9;
          } else if (zoom == 1.25) {
            factor *= 1.3;
          } else if (zoom >= 1.25) {
            factor *= 1.5;
          }
        }
        if (__isMaximized && __userZoom >= DASH_FULLSCREEN_ZOOM200_THRESHOLD) {
          factor *= DASH_FULLSCREEN_ZOOM200_BOOST;
        }

        return {
          width: Math.round(baseW * factor),
          height: Math.round(baseH * factor),
        };
      }

      function applyDashSize() {
        const panel = document.getElementById("dashboardPanel");
        if (!panel) return;

        const applyDashSizeThrottled = throttle(applyDashSize, 120);
        const { width: vw, height: vh } = getViewportDimensions();

        const baseW = __isMaximized
          ? vw
          : Math.min(1200, Math.max(820, 0.94 * vw));
        const baseH = __isMaximized
          ? vh
          : Math.min(980, Math.max(520, 0.86 * vh));
        let factor = 1;
        const zoom = Math.max(__userZoom || 1, 0.01);
        if (Math.abs(zoom - 1) > 0.001) {
          factor = 1 / zoom;
          if (zoom <= 0.75) {
            factor *= 0.9;
          } else if (zoom == 1.25) {
            factor *= 1.3;
          } else if (zoom >= 1.25) {
            factor *= 1.5;
          }
        }
        if (__isMaximized && __userZoom >= DASH_FULLSCREEN_ZOOM200_THRESHOLD) {
          factor *= DASH_FULLSCREEN_ZOOM200_BOOST;
        }

        const padX = __isMaximized
          ? Math.max(3, vw * 0.02)
          : Math.max(12, vw * 0.02);
        const padY = __isMaximized
          ? Math.max(85, vh * 0.04)
          : Math.max(12, vh * 0.02);

        const availableW = Math.max(0, vw - padX);
        const availableH = Math.max(0, vh - padY);

        let width = Math.min(Math.round(baseW * factor), availableW);
        let height = Math.min(Math.round(baseH * factor), availableH);

        if ((__userZoom || 1) >= DASH_FULLSCREEN_ZOOM200_THRESHOLD) {
          const maxNormalWidth = __isMaximized
            ? availableW
            : Math.max(660, Math.min(880, availableW - 60));
          const maxNormalHeight = __isMaximized
            ? availableH
            : Math.max(740, Math.min(900, availableH - 80));
          width = Math.min(width, maxNormalWidth);
          height = Math.min(height, maxNormalHeight);
        }

        panel.style.width = `${width}px`;
        panel.style.height = `${height}px`;
      }
      const applyDashSizeThrottled = throttle(applyDashSize, 120);
      (window.electron?.ipcRenderer?.on || window.api?.on)?.(
        "configs:changed",
        async () => {
          try {
            const cfgs = await window.api.loadConfigs();
            const normalizedCfgs = normalizeConfigList(cfgs);
            rememberCoverNamesFromList(normalizedCfgs);
            if (typeof renderConfigs === "function")
              renderConfigs(normalizedCfgs);
            if (typeof reloadConfigsDropdown === "function")
              await reloadConfigsDropdown(true);
            if (window.__dashboardOpen) {
              await buildDashboard();
            } else {
              window.__dashboardNeedsRebuild = true;
            }
          } catch (e) {
            console.warn(
              tUi(
                "log.refreshConfigsOnChangedFailed",
                "Failed to refresh configs on configs:changed:",
              ),
              e,
            );
          }
        },
      );

      window.api?.on?.("zoom-factor-changed", (z) => {
        const payload = z || {};
        const userZoom =
          Number(payload.userZoom ?? (typeof z === "number" ? z : NaN)) || 1;
        const effectiveZoom =
          Number(payload.effectiveZoom ?? (typeof z === "number" ? z : NaN)) ||
          1;
        __userZoom = userZoom;
        __effectiveZoom = effectiveZoom;
        document.body.dataset.zoom = String(Math.round(__userZoom * 100));
        document.body.dataset.effectiveZoom = String(
          Math.round(__effectiveZoom * 100),
        );
        const scaleFactor =
          __effectiveZoom > 0 ? __userZoom / __effectiveZoom : 1;
        const next = {
          userZoom: __userZoom,
          effectiveZoom: __effectiveZoom,
          scaleFactor,
        };
        const shouldLog =
          !__lastZoomLog ||
          Math.abs(__lastZoomLog.userZoom - next.userZoom) > ZOOM_LOG_EPS ||
          Math.abs(__lastZoomLog.effectiveZoom - next.effectiveZoom) >
            ZOOM_LOG_EPS ||
          Math.abs(__lastZoomLog.scaleFactor - next.scaleFactor) > ZOOM_LOG_EPS;
        if (shouldLog) {
          __lastZoomLog = next;
          console.info("zoom:ui", next);
        }
        refreshDisplayWorkArea();
        applyDashSize();
        applyDashSizeThrottled();
        try {
          __updateAchStatsResponsive?.();
        } catch {}
      });

      window.electron?.ipcRenderer?.on?.("window-state-change", (isMax) => {
        __isMaximized = !!isMax;
        document.body.classList.toggle("window-maximized", __isMaximized);
        refreshDisplayWorkArea();
        applyDashSize();
        applyDashSizeThrottled();
      });

      window.electron?.ipcRenderer?.on?.(
        "window-fullscreen-change",
        (isFullscreen) => {
          __isMaximized = !!isFullscreen;
          document.body.classList.toggle("window-maximized", __isMaximized);
          refreshDisplayWorkArea();
          applyDashSize();
          applyDashSizeThrottled();
        },
      );

      const zoomDd = document.getElementById("app-zoom-dropdown");
      if (zoomDd) {
        zoomDd.addEventListener("change", (e) => {
          const z = parseFloat(e.target.value) || 1;
          __userZoom = z;
          document.body.dataset.zoom = String(
            Math.round((__userZoom || 1) * 100),
          );
          document.body.dataset.effectiveZoom = String(
            Math.round((__userZoom || 1) * 100),
          );
          applyDashSize();
          applyDashSizeThrottled();
          window.api.setZoom(z);
        });
      }

      window.addEventListener("resize", () => {
        refreshDisplayWorkArea();
        applyDashSizeThrottled();
        try {
          __updateAchStatsResponsive?.();
        } catch {}
      });
      refreshDisplayWorkArea().then(applyDashSize);
      const dashboard = document.getElementById("dashboardOverlay");
      const dashboardBody = document.getElementById("dashboardBody");
      let dashboardScrollTop = 0;

      (function hookDashOpen() {
        const dashboard = document.getElementById("dashboardOverlay");
        const gridEl = document.getElementById("dashboardGrid");
        const btnToggle = document.getElementById("toggleDashboardBtn");
        const btnClose = document.getElementById("closeDashboard");
        if (!btnToggle || !dashboard) return;

        if (window.__dashHandlersBound) return;
        window.__dashHandlersBound = true;

        const onOpen = (e) => {
          e.preventDefault();
          window.openDashboard?.();
        };
        const onClose = (e) => {
          e.preventDefault();
          window.closeDashboard?.();
        };

        btnToggle.addEventListener("click", onOpen);
        btnClose?.addEventListener("click", onClose);
        dashboard.addEventListener("click", (e) => {
          if (e.target === dashboard) onClose(e);
        });

        window.addEventListener("DOMContentLoaded", async () => {
          try {
            await loadPreferencesCached();
            const prefs = getCachedPreferences();
            __userZoom = Number(prefs?.windowZoomFactor || 1) || 1;
            __effectiveZoom = __userZoom;
          } catch {}
          applyDashSize();
          applyDashSizeThrottled();
          try {
            __updateAchStatsResponsive?.();
          } catch {}
        });
      })();
      // === achStats: responsive width guard (robust) ===
      (function makeAchStatsResponsive() {
        const stats = document.getElementById("achStats");
        if (!stats) return;
        const leftTop = document.getElementById("toggleDashboardBtn");
        const leftBot = document.getElementById("toggleBtn");
        const playBtn = document.getElementById("playBtn");

        function getFrame() {
          const vw =
            window.innerWidth || document.documentElement.clientWidth || 0;
          const frameW = Math.min(1100, Math.max(0, vw - 80));
          const frameLeft = (vw - frameW) / 2;
          return { left: frameLeft, right: frameLeft + frameW, width: frameW };
        }

        let bootGatingActive = true;
        let bootUpdateDone = false;
        let bootCompleteHandled = false;

        const isBootingNow = () =>
          document.body.classList.contains("booting") ||
          window.__bootUiReady === false;

        const allowBootUpdate = () => {
          if (!bootGatingActive) return true;
          if (bootUpdateDone) return false;
          bootUpdateDone = true;
          return true;
        };

        const runPostBootUpdates = () => {
          if (bootCompleteHandled) return;
          bootCompleteHandled = true;
          bootGatingActive = false;
          bootUpdateDone = false;
          requestAnimationFrame(() => {
            update();
            setTimeout(update, 100);
          });
        };

        function update() {
          if (!allowBootUpdate()) return;
          try {
            // Keep same behavior in both windowed + maximized; we only restrict to avoid overlap
            const frame = getFrame();
            const center = frame.left + frame.width / 2;
            const l1 = leftTop?.getBoundingClientRect?.();
            const l2 = leftBot?.getBoundingClientRect?.();
            const p = playBtn?.getBoundingClientRect?.();

            // Safe margins so we never touch buttons
            const safety = 60;
            const leftBound = Math.max(
              frame.left,
              Math.max(l1?.right || frame.left, l2?.right || frame.left) +
                safety,
            );
            const rightBound = Math.min(
              frame.right,
              p?.left != null ? p.left - safety : frame.right,
            );

            // Width symmetrical around center so a centered bar never intrudes into button zones
            const halfLeft = Math.max(0, center - leftBound);
            const halfRight = Math.max(0, rightBound - center);
            let maxWidthPx = Math.floor(2 * Math.min(halfLeft, halfRight));

            // Fallbacks to avoid collapsing at boot (layout not ready yet)
            if (!isFinite(maxWidthPx) || maxWidthPx <= 0) {
              maxWidthPx = Math.floor(frame.width * 0.5); // 50% of frame as safe default
            }
            // Clamp to frame width just in case
            maxWidthPx = Math.max(160, Math.min(maxWidthPx, frame.width));
            stats.style.maxWidth = `${maxWidthPx}px`;
          } catch {
            // In case of any transient failure, keep a safe default
            const frame = getFrame();
            stats.style.maxWidth = `${Math.floor(frame.width * 0.5)}px`;
          }
        }

        // Expose and schedule safely so first layout has happened
        window.__updateAchStatsResponsive = update;

        if (isBootingNow()) {
          requestAnimationFrame(() => update());
        } else {
          requestAnimationFrame(() => {
            update();
            setTimeout(update, 60);
          });
          window.addEventListener("load", () => setTimeout(update, 0), {
            once: true,
          });
        }

        window.api?.on?.("boot:complete", runPostBootUpdates);
        window.api
          ?.getBootStatus?.()
          .then((status) => {
            if (status?.bootDone) {
              runPostBootUpdates();
            }
          })
          .catch(() => {});
      })();

      function sanitizeConfigName(raw) {
        const s = String(raw || "")
          .replace(/[\\/\\:*?"<>|]/g, "")
          .replace(/\s+/g, " ")
          .trim()
          .replace(/[. ]+$/, "");
        const base = s || "config";
        return /^(con|prn|aux|nul|com[1-9]|lpt[1-9])$/i.test(base)
          ? `_${base}`
          : base;
      }

      const pendingFileUpdateRetry = new Map();
      async function handleAchievementsFileUpdated(payload, isRetry = false) {
        try {
          const { appid, configName } = payload || {};
          const cfg =
            configName || document.getElementById("configList")?.value;
          const selectedConfigRaw =
            document.getElementById("configList")?.value || "";
          const selectedConfig = sanitizeConfigName(selectedConfigRaw);
          const cfgSanitized = sanitizeConfigName(cfg);
          const sameAsActive =
            selectedConfig && cfgSanitized && selectedConfig === cfgSanitized;
          const autoSelectMatch =
            __watcherAutoSelect &&
            cfgSanitized &&
            __watcherAutoSelect === cfgSanitized;
          __watcherAutoSelect = null;
          if (!cfg) return;

          const [achData, saved] = await Promise.all([
            window.api.loadAchievementData(cfg),
            window.api.loadSavedAchievements(cfg),
          ]);

          const list = Array.isArray(achData?.achievements)
            ? achData.achievements
            : [];
          const savedMap = saved?.achievements || {};
          if (cfg) {
            window.__clearDashboardSavedCache?.(cfg);
          }

          if (list.length && Object.keys(savedMap).length === 0) {
            const attempts = pendingFileUpdateRetry.get(cfg) || 0;
            if (!isRetry && attempts < 3) {
              pendingFileUpdateRetry.set(cfg, attempts + 1);
              setTimeout(() => {
                handleAchievementsFileUpdated(payload, true);
              }, 350);
            }
            return;
          }
          if (cfg) pendingFileUpdateRetry.delete(cfg);

          let unlocked = 0;
          for (const a of list) if (savedMap?.[a.name]?.earned) unlocked++;

          const K = `achPrevUnlocked:${cfg}`;
          const prev = Number(localStorage.getItem(K) || 0);

          const namesKey = `${K}:names`;
          const prevNames = JSON.parse(localStorage.getItem(namesKey) || "[]");
          if (unlocked > prev) {
            const shouldNotify = !sameAsActive || autoSelectMatch;
            await loadPreferencesCached();
            const prefs = getCachedPreferences() || {};
            const preset =
              prefs.preset ||
              document.getElementById("presetDropdown")?.value ||
              "default";
            const position =
              prefs.position ||
              document.getElementById("positionDropdown")?.value ||
              "center-bottom";
            const sound =
              prefs.sound ||
              document.getElementById("soundSelect")?.value ||
              "mute";
            const scale = parseFloat(
              prefs.notificationScale ||
                document.getElementById("scaleSlider")?.value ||
                1,
            );
            const lang = prefs.language || window.currentLang || "english";
            const newlyEarned = list.filter((achievement) => {
              const state = savedMap?.[achievement.name];
              return state?.earned && !prevNames.includes(achievement.name);
            });
            for (const achievement of newlyEarned) {
              const displayName = getSafeLocalizedText(
                achievement.displayName,
                lang,
              );
              const description = getSafeLocalizedText(
                achievement.description,
                lang,
              );
              const icon =
                achievement.icon ||
                achievement.icon_gray ||
                achievement.icongray ||
                "";
              const iconGray =
                achievement.icon_gray || achievement.icongray || "";
              // notification sent by watcher (main process)
              // if (shouldNotify) {
              //   window.api.queueAchievementNotification({
              //     displayName,
              //     description,
              //     icon,
              //     icon_gray: iconGray,
              //     config_path: achData.config_path,
              //     preset,
              //     position,
              //     sound,
              //     scale,
              //   });
              // }
              if (shouldNotify && !prefs?.disableProgress) {
                const state = savedMap[achievement.name];
                if (
                  Number.isFinite(state?.progress) &&
                  Number.isFinite(state?.max_progress) &&
                  state.max_progress > 0
                ) {
                  window.api.queueProgressNotification({
                    displayName,
                    icon,
                    progress: state.progress,
                    max_progress: state.max_progress,
                    config_path: achData.config_path,
                    configName: cfg,
                  });
                }
              }
            }

            if (newlyEarned.length) {
              localStorage.setItem(
                namesKey,
                JSON.stringify([
                  ...new Set([...prevNames, ...newlyEarned.map((a) => a.name)]),
                ]),
              );
              await window.loadLocalCover?.(String(appid));
            }
          }
          localStorage.setItem(K, String(unlocked));
          if (
            window.__dashboardOpen &&
            typeof window.updateCardProgressUI === "function"
          ) {
            const card = document.querySelector(
              `.dash-card[data-name="${CSS.escape(cfg)}"]`,
            );
            if (card) {
              try {
                await window.updateCardProgressUI(card, cfg);
              } catch {}
            } else if (typeof buildDashboard === "function") {
              try {
                await buildDashboard();
              } catch {}
            }
          }
        } catch (e) {
          console.warn(
            tUi(
              "log.achievementsFileUpdatedFailed",
              "achievements:file-updated handler failed:",
            ),
            e,
          );
        }
      }
      window.api?.on?.(
        "achievements:file-updated",
        handleAchievementsFileUpdated,
      );

      // GLOBAL NAV MANAGER (keyboard + gamepad)

      //Dashboard Navigation
      if (!window.dashboardArrow) {
        (function () {
          function visibleCards() {
            const grid = document.getElementById("dashboardGrid");
            if (!grid) return [];
            return Array.from(grid.querySelectorAll(".dash-card")).filter(
              (el) =>
                el.offsetParent !== null &&
                getComputedStyle(el).display !== "none",
            );
          }
          function gridCols() {
            const grid = document.getElementById("dashboardGrid");
            if (!grid) return 1;
            const tpl = getComputedStyle(grid).gridTemplateColumns || "";
            const cols = tpl.split(" ").filter(Boolean).length;
            return Math.max(cols || 1, 1);
          }
          window.dashboardArrow = function (evtOrKey) {
            const key = typeof evtOrKey === "string" ? evtOrKey : evtOrKey?.key;
            const cards = visibleCards();
            if (!cards.length) return;

            const active =
              document.querySelector("#dashboardGrid .dash-card.active") ||
              document.querySelector("#dashboardGrid .dash-card:focus") ||
              cards[0];
            let idx = Math.max(0, cards.indexOf(active));
            const cols = gridCols();

            switch (key) {
              case "ArrowLeft":
                idx -= 1;
                break;
              case "ArrowRight":
                idx += 1;
                break;
              case "ArrowUp":
                idx -= cols;
                break;
              case "ArrowDown":
                idx += cols;
                break;
              case "Home":
                idx = 0;
                break;
              case "End":
                idx = cards.length - 1;
                break;
              default:
                return;
            }
            window.dashboardFocusCardAt?.(idx);
          };
        })();
      }

      (function () {
        if (window.__unifiedNavActive) return;
        window.__unifiedNavActive = true;
        window.__unifiedGpActive = true;

        // ---- Options
        const DEADZONE = 0.4;
        const REPEAT_MS = 160;

        // ---- Utils
        const $ = (sel) => document.querySelector(sel);
        const byId = (id) => document.getElementById(id);
        const isHidden = (el) =>
          !el ||
          el.classList.contains("hidden") ||
          getComputedStyle(el).display === "none" ||
          getComputedStyle(el).visibility === "hidden";
        const isVisible = (el) => el && !isHidden(el);
        const isTypingTarget = (el) =>
          el &&
          (el.isContentEditable ||
            el.tagName === "INPUT" ||
            el.tagName === "TEXTAREA" ||
            el.tagName === "SELECT");

        // ---- RS scroll helpers ----

        window.__lastScrollSource = { src: null, t: 0 };
        function markScrollSource(src) {
          window.__lastScrollSource = { src, t: performance.now() };
        }
        function wasRSRecently(ms = 220) {
          const s = window.__lastScrollSource;
          return s && s.src === "rs" && performance.now() - s.t < ms;
        }
        const RS_DEADZONE = 0.5;
        const RS_BASE_SPEED = 1.5;
        const RS_ACCEL = 0.8;
        const RS_REPEAT_MS = 400;
        let __lastRS = 0;
        function canRepeatRS() {
          return performance.now() - __lastRS > RS_REPEAT_MS;
        }
        function tickRepeatRS() {
          __lastRS = performance.now();
        }

        function rsAxisToDelta(v) {
          const a = Math.abs(v);
          if (a < RS_DEADZONE) return 0;
          const t = (a - RS_DEADZONE) / (1 - RS_DEADZONE);
          const speed = RS_BASE_SPEED * (1 + t * t * RS_ACCEL);
          return Math.sign(v) * speed;
        }

        function canScroll(el, axis = "y") {
          if (!el) return false;
          if (
            el === document.scrollingElement ||
            el === document.documentElement ||
            el === document.body
          ) {
            return axis === "y"
              ? el.scrollHeight > el.clientHeight + 1
              : el.scrollWidth > el.clientWidth + 1;
          }
          const cs = getComputedStyle(el);
          const overflow = axis === "y" ? cs.overflowY : cs.overflowX;
          const canOverflow =
            overflow === "auto" ||
            overflow === "scroll" ||
            overflow === "overlay";
          return (
            canOverflow &&
            (axis === "y"
              ? el.scrollHeight > el.clientHeight + 1
              : el.scrollWidth > el.clientWidth + 1)
          );
        }

        function resolveScrollTarget({ axis = "y", overlay, focused }) {
          const candidates = [];

          const focusContainer = focused?.closest(
            ".tab-content, .settings-tabs-content, [data-scroll-container='1'], #dashboardBody, .modal-content",
          );
          if (focusContainer) candidates.push(focusContainer);

          if (overlay === "settings") {
            candidates.push(
              document.querySelector(".settings-tabs-content") ||
                document.querySelector(".settings-content"),
            );
          } else if (overlay === "dashboard") {
            candidates.push(document.getElementById("dashboardBody"));
          } else if (overlay === "onboarding") {
            const modal = document
              .getElementById("bootOnboardingModal")
              ?.querySelector(".modal-content");
            if (modal) candidates.push(modal);
          } else if (overlay === "config") {
            const modal = document
              .getElementById("configModal")
              ?.querySelector(".modal-content");
            if (modal) candidates.push(modal);
          } else {
            const main = document.getElementById("mainScroll");
            if (main) candidates.push(main);
            candidates.push(
              document.querySelector(
                "[data-scroll-container='1'], .scroll-container",
              ),
            );
            candidates.push(document.scrollingElement);
            candidates.push(document.documentElement);
            candidates.push(document.body);
          }

          return (
            candidates.filter(Boolean).find((el) => canScroll(el, axis)) || null
          );
        }

        function scrollByPage(direction) {
          const overlay =
            (typeof getActiveOverlaySafe === "function" &&
              getActiveOverlaySafe()) ||
            "main";
          const target = resolveScrollTarget({
            axis: "y",
            overlay,
            focused: document.activeElement,
          });
          if (!target) return;

          const step =
            target === document.body ||
            target === document.documentElement ||
            target === document.scrollingElement
              ? window.innerHeight
              : target.clientHeight;
          const delta = direction === "down" ? step : -step;

          if (
            target === document.body ||
            target === document.documentElement ||
            target === document.scrollingElement
          ) {
            window.scrollBy({ top: delta, behavior: "auto" });
          } else {
            target.scrollTop += delta;
          }
          markScrollSource("kb");
          if (overlay === "dashboard") {
            window.focusFirstVisibleDashCard?.();
          }
        }

        function findScrollableFrom(start, axis = "y") {
          let el = start;
          if (
            el &&
            el.tagName === "SELECT" &&
            el.getAttribute("data-sel-open") === "1"
          ) {
            return el;
          }
          while (el && el !== document.documentElement) {
            if (canScroll(el, axis)) return el;
            el = el.parentElement || el.parentNode;
          }
          return null;
        }

        function wheelOn(el, dx, dy) {
          if (!el) return;
          const evt = new WheelEvent("wheel", {
            deltaX: dx,
            deltaY: dy,
            bubbles: true,
            cancelable: true,
          });
          const notPrevented =
            el.dispatchEvent(evt) !== false && !evt.defaultPrevented;
          if (notPrevented) {
            if (Math.abs(dy) > 0 && canScroll(el, "y")) el.scrollTop += dy;
            if (Math.abs(dx) > 0 && canScroll(el, "x")) el.scrollLeft += dx;
          }
        }

        function rightStickScroll(dy, dx) {
          markScrollSource("rs");

          const overlay =
            (typeof getActiveOverlaySafe === "function" &&
              getActiveOverlaySafe()) ||
            "main";
          const focused = document.activeElement;
          if (
            focused &&
            focused.tagName === "SELECT" &&
            isSelectOpen?.(focused)
          ) {
            const mag = Math.abs(dy);
            if (mag < RS_DEADZONE) return;
            const step = mag > 0.75 ? 5 : 1;
            const sign = dy > 0 ? +1 : -1;
            moveSelectBy(focused, sign * step);
            return;
          }

          const axis = Math.abs(dy) >= Math.abs(dx) ? "y" : "x";

          const target = resolveScrollTarget({ axis, overlay, focused });
          if (!target) return;

          const amount = (axis === "y" ? dy : dx) * 20;
          if (axis === "y") target.scrollTop += amount;
          else target.scrollLeft += amount;

          if (
            axis === "y" &&
            window.__dashboardOpen &&
            target.id === "dashboardBody"
          ) {
            cancelAnimationFrame(window.__dashFocusRAF || 0);
            window.__dashFocusRAF = requestAnimationFrame(() => {
              if (!wasRSRecently()) return;

              const hoverCard = document.querySelector(
                "#dashboardGrid .dash-card:hover",
              );
              if (hoverCard) return;

              const active = document.activeElement?.closest?.(".dash-card");
              if (active) {
                const bodyRect = target.getBoundingClientRect();
                const r = active.getBoundingClientRect();
                const stillVisible =
                  r.bottom > bodyRect.top + 1 && r.top < bodyRect.bottom - 1;
                if (stillVisible) return;
              }

              window.focusFirstVisibleDashCard?.();
            });
          }
        }

        //Keyboard Scroll
        document.getElementById("dashboardBody")?.addEventListener(
          "scroll",
          () => {
            if (!wasRSRecently()) return;
            if (!window.__dashboardOpen) return;
            cancelAnimationFrame(window.__dashFocusRAF || 0);
            window.__dashFocusRAF = requestAnimationFrame(() => {
              window.focusFirstVisibleDashCard?.();
            });
          },
          { passive: true },
        );

        (function installScrollSourceMarkers() {
          const db = document.getElementById("dashboardBody");
          if (!db || db.__sourceMarkersInstalled) return;
          db.__sourceMarkersInstalled = true;

          db.addEventListener("wheel", () => markScrollSource("mouse"), {
            passive: true,
            capture: true,
          });
          db.addEventListener("touchmove", () => markScrollSource("touch"), {
            passive: true,
            capture: true,
          });
        })();

        // === Select dropdown behavior (Main Window) ===
        const SELECT_OPEN_ATTR = "data-sel-open";

        function isSelectEl(el) {
          return el && el.tagName === "SELECT";
        }
        function isSelectOpen(el) {
          return el && el.getAttribute(SELECT_OPEN_ATTR) === "1";
        }

        function placeholderIndex(select) {
          const opts = Array.from(select.options || []);
          let idx = opts.findIndex(
            (o) =>
              o.disabled ||
              o.value === "" ||
              /^select$/i.test((o.text || "").trim()),
          );
          if (idx < 0) idx = 0;
          return idx;
        }
        function isSkippableOption(opt) {
          if (!opt) return true;
          const txt = (opt.text || "").trim();
          return opt.disabled || opt.value === "" || /^select$/i.test(txt);
        }

        function nextSelectableIndex(select, fromIndex, dir) {
          const { options } = select;
          let i = fromIndex;

          if (isSkippableOption(options[i])) {
            i = dir > 0 ? -1 : options.length;
          }
          for (let step = 0; step < options.length; step++) {
            i += dir;
            if (i < 0 || i >= options.length) break;
            if (!isSkippableOption(options[i])) return i;
          }
          return fromIndex;
        }

        function moveSelectBy(select, steps) {
          if (!select || select.tagName !== "SELECT" || !Number.isFinite(steps))
            return;
          const dir = Math.sign(steps);
          let todo = Math.abs(steps);
          let idx = select.selectedIndex;

          while (todo-- > 0) {
            const ni = nextSelectableIndex(select, idx, dir);
            if (ni === idx) break;
            idx = ni;
          }
          if (idx !== select.selectedIndex) {
            select.selectedIndex = idx;
            const opt = select.options[idx];
            if (opt) opt.scrollIntoView({ block: "nearest" });
          }
        }

        function openSelectList(select) {
          if (!isSelectEl(select) || isSelectOpen(select)) return;
          select.setAttribute(SELECT_OPEN_ATTR, "1");
          select.dataset.prevIndex = String(select.selectedIndex);
          const size = Math.max(2, Math.min(8, select.options.length || 2));
          select.classList.add("sel-open");
          select.setAttribute("size", String(size));
          select.focus({ preventScroll: true });
          const i = Math.max(0, select.selectedIndex);
          if (select.options[i])
            select.options[i].scrollIntoView({ block: "nearest" });
        }
        function closeSelectList(select, confirm) {
          if (!isSelectEl(select) || !isSelectOpen(select)) return;

          const prevIdxRaw = select.dataset.prevIndex;
          const prevIdx = Number.isFinite(+prevIdxRaw) ? +prevIdxRaw : -1;

          if (!confirm) {
            const fallback = placeholderIndex(select);
            const target = prevIdx >= 0 ? prevIdx : fallback;
            select.selectedIndex = Math.max(
              0,
              Math.min(select.options.length - 1, target),
            );
          }

          select.classList.remove("sel-open");
          select.removeAttribute("size");
          select.removeAttribute(SELECT_OPEN_ATTR);

          const changed =
            prevIdx >= 0 ? select.selectedIndex !== prevIdx : true;
          if (changed) {
            select.dispatchEvent(new Event("change", { bubbles: true }));
          }

          delete select.dataset.prevIndex;
          select.focus({ preventScroll: true });
        }

        window.__openMainSelectList = openSelectList;
        window.__closeMainSelectList = closeSelectList;

        function handleOpenSelectKey(e, select) {
          const key = e.key;
          if (key === "ArrowDown" || key === "ArrowUp") {
            e.preventDefault();
            e.stopPropagation();
            const dir = key === "ArrowDown" ? +1 : -1;
            let i = select.selectedIndex;
            i = Math.max(0, Math.min(select.options.length - 1, i + dir));
            select.selectedIndex = i;
            const opt = select.options[i];
            if (opt) opt.scrollIntoView({ block: "nearest" });
            return;
          }
          if (key === "Enter") {
            e.preventDefault();
            e.stopPropagation();
            closeSelectList(select, /*confirm*/ true);
            return;
          }
          if (key === "Escape" || key === "Backspace") {
            e.preventDefault();
            e.stopPropagation();
            closeSelectList(select, /*confirm*/ false);
            return;
          }

          if (key === "ArrowLeft" || key === "ArrowRight") {
            e.preventDefault();
            e.stopPropagation();
          }
        }

        function getActiveOverlaySafe() {
          if (typeof window.getActiveOverlay === "function") {
            try {
              return window.getActiveOverlay();
            } catch {
              /* fallback */
            }
          }
          const settings = byId("settingsMenu");
          const dashboard = byId("dashboardOverlay");
          const config = byId("configModal");
          const onboarding = byId("bootOnboardingModal");
          const confirm = byId("appConfirmModal");
          if (onboarding && !onboarding.classList.contains("hidden"))
            return "onboarding";
          if (confirm && !confirm.classList.contains("hidden"))
            return "confirm";
          if (settings && !settings.classList.contains("hidden"))
            return "settings";
          if (dashboard && dashboard.classList.contains("open"))
            return "dashboard";
          if (config && !config.classList.contains("hidden")) return "config";
          return "main";
        }

        window.focusablesIn = function focusablesIn(root) {
          if (!root) return [];
          const nodes = root.querySelectorAll(
            'button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])',
          );
          return Array.from(nodes).filter((el) => {
            if (el.disabled) return false;
            if (el.closest("[hidden]")) return false;
            const st = getComputedStyle(el);
            if (st.visibility === "hidden" || st.display === "none")
              return false;
            if (
              el.offsetWidth + el.offsetHeight + el.getClientRects().length ===
              0
            )
              return false;
            return true;
          });
        };

        function moveFocus(root, delta) {
          if (!root) return;
          const list = window.focusablesIn(root);
          if (!list.length) return;
          let idx = list.indexOf(document.activeElement);
          if (idx === -1) idx = delta > 0 ? -1 : 0;
          const next = list[(idx + delta + list.length) % list.length];
          next?.focus({ preventScroll: true });
          next?.scrollIntoView?.({ block: "nearest", inline: "nearest" });
        }

        // ---------- Settings navigation  ----------
        const __swallowScrollWhenSettings = (e) => {
          const open = !document
            .getElementById("settingsMenu")
            ?.classList.contains("hidden");
          if (!open) return;
          if (!e.target.closest(".settings-content")) {
            e.preventDefault();
            e.stopPropagation();
          }
        };

        document.addEventListener("wheel", __swallowScrollWhenSettings, {
          passive: false,
          capture: true,
        });
        document.addEventListener("touchmove", __swallowScrollWhenSettings, {
          passive: false,
          capture: true,
        });
        let __settingsMode = null; // 'tabs' | 'section'

        function activeSettingsTabBtn() {
          return $(".settings-tab.active") || $(".settings-tab");
        }
        function activeSettingsPanel() {
          const btn = activeSettingsTabBtn();
          const id = btn?.getAttribute("data-tab");
          if (id === "shortcuts") ensureShortcutsTabContent();
          return id ? byId(id + "Tab") : null;
        }
        function ensureShortcutsTabContent() {
          const tab = document.getElementById("shortcutsTab");
          if (!tab || tab.dataset.ready === "1") return;
          const tpl = document.getElementById("shortcutsTabTemplate");
          if (!tpl) return;
          tab.appendChild(tpl.content.cloneNode(true));
          tab.dataset.ready = "1";
        }
        window.ensureShortcutsTabContent = ensureShortcutsTabContent;
        function focusFirstInActiveSection() {
          const content = activeSettingsPanel() || $(".settings-content");
          const list = window
            .focusablesIn(content)
            .filter((el) => !el.closest(".settings-tabs"))
            .filter((el) => !el.classList.contains("settings-close-button"));
          (list[0] || content)?.focus({ preventScroll: true });
        }

        window.settingsEnterTabsMode = function () {
          __settingsMode = "tabs";
          window.__settingsMode = "tabs";
          const activeTab = document.querySelector(".settings-tab.active");
          if (activeTab) {
            activeTab.focus({ preventScroll: true });
          }
        };
        window.settingsEnterSectionMode = function () {
          __settingsMode = "section";
          window.__settingsMode = "section";
          const activePanel = activeSettingsPanel();
          if (activePanel) {
            const firstFocusable = window
              .focusablesIn(activePanel)
              .filter((el) => !el.closest(".settings-tabs"))
              .filter(
                (el) => !el.classList.contains("settings-close-button"),
              )[0];
            (firstFocusable || activePanel)?.focus({ preventScroll: true });
          }
        };
        window.settingsTabsSelect = function () {
          const t = document.activeElement;
          if (t?.classList?.contains("settings-tab")) {
            t.click();
            setTimeout(() => window.settingsEnterSectionMode(), 0);
          }
        };
        window.settingsSectionFocusMove = function (delta) {
          const content = activeSettingsPanel() || $(".settings-content");
          const list = window
            .focusablesIn(content)
            .filter((el) => !el.closest(".settings-tabs"))
            .filter((el) => !el.classList.contains("settings-close-button"));
          if (!list.length) return;
          const cur = document.activeElement;
          let idx = list.findIndex(
            (el) => el === cur || (cur && el.contains(cur)),
          );
          if (idx === -1) idx = delta > 0 ? -1 : 0;
          const next = list[(idx + delta + list.length) % list.length];
          next?.focus({ preventScroll: true });
          next?.scrollIntoView?.({ block: "nearest", inline: "nearest" });
        };

        function settingsAdjust(dir) {
          const el = document.activeElement;
          if (!el) return;
          if (el.tagName === "INPUT" && el.type === "checkbox") {
            el.checked = dir > 0;
            el.dispatchEvent(new Event("change", { bubbles: true }));
          } else if (el.tagName === "INPUT" && el.type === "range") {
            const step = parseFloat(el.step || "1") || 1;
            const min = parseFloat(el.min || "0") || 0;
            const max = parseFloat(el.max || "100") || 100;
            const next = Math.max(
              min,
              Math.min(max, Number(el.value) + step * dir),
            );
            el.value = String(next);
            el.dispatchEvent(new Event("input", { bubbles: true }));
          } else if (el.tagName === "SELECT") {
            const i = Math.min(
              el.options.length - 1,
              Math.max(0, el.selectedIndex + dir),
            );
            if (i !== el.selectedIndex) {
              el.selectedIndex = i;
              el.dispatchEvent(new Event("change", { bubbles: true }));
            }
          }
        }

        function settingsTabsFocusMove(delta) {
          const tabs = Array.from(document.querySelectorAll(".settings-tab"));
          if (!tabs.length) return;
          const focused = document.activeElement;
          let idx = tabs.indexOf(focused);
          if (idx < 0) idx = tabs.indexOf($(".settings-tab.active"));
          idx = (idx + delta + tabs.length) % tabs.length;
          tabs[idx]?.focus({ preventScroll: true });
        }
        function settingsTabsCycle(delta) {
          const tabs = Array.from(document.querySelectorAll(".settings-tab"));
          const active = $(".settings-tab.active");
          if (!tabs.length || !active) return;
          let i = tabs.indexOf(active);
          i = (i + delta + tabs.length) % tabs.length;
          tabs[i]?.click();
        }
        function settingsSectionActivate() {
          const el = document.activeElement;
          if (!el) return;
          if (el.tagName === "BUTTON") el.click();
          else if (el.tagName === "INPUT" && el.type === "checkbox") {
            el.checked = !el.checked;
            el.dispatchEvent(new Event("change", { bubbles: true }));
          } else if (el.tagName === "SELECT") el.click();
        }

        // ---- Actions
        const A = {
          UP: "UP",
          DOWN: "DOWN",
          LEFT: "LEFT",
          RIGHT: "RIGHT",
          HOME: "HOME",
          END: "END",
          CONFIRM: "CONFIRM",
          BACK: "BACK",
          SETTINGS: "SETTINGS",
          DASHBOARD: "DASHBOARD",
          OPTIONS: "OPTIONS",
          CONFIG: "CONFIG",
          PLAY: "PLAY",
          MENU: "MENU",
          SEARCH: "SEARCH",
        };

        // ---- Command helpers
        function toggleSettings() {
          const settingsMenu = byId("settingsMenu");
          if (!settingsMenu) return;
          const open = settingsMenu.classList.contains("hidden") === false;
          if (open) {
            window.closeSettingsModal?.() || byId("closeSettingsBtn")?.click();
          } else {
            window.openSettingsModal?.() || byId("settingsBtn")?.click();
          }
        }
        function toggleDashboard() {
          if (window.__dashboardOpen) window.closeDashboard?.();
          else window.openDashboard?.();
        }
        function backOrClose() {
          const overlay = getActiveOverlaySafe();
          if (overlay === "onboarding") {
            return;
          }
          if (overlay === "settings") {
            const mode = (window.__settingsMode ?? __settingsMode) || "tabs";
            if (mode === "section") {
              window.settingsEnterTabsMode?.();
              return;
            }
            window.closeSettingsModal?.();
            return;
          }
          if (overlay === "dashboard") {
            window.closeDashboard?.();
            return;
          }
          if (overlay === "config") {
            byId("closeConfigModal")?.click();
            return;
          }
          const backBtn = byId("backButton");
          if (isVisible(backBtn)) {
            backBtn.click();
            return;
          }
          const configList = byId("configList");
          if (configList && configList.value) {
            configList.value = "";
            configList.dispatchEvent(new Event("change", { bubbles: true }));
          }
        }
        function openConfig() {
          byId("createNewConfigBtn")?.click();
        }
        function toggleOptions() {
          byId("toggleBtn")?.click();
        }
        function tryPlay() {
          if (window.__dashboardOpen) {
            const active =
              document.querySelector(".dash-card.active") ||
              document.querySelector(".dash-card");
            const btn = active?.querySelector?.(".dash-play:not(.is-disabled)");
            if (btn) {
              btn.click();
              return;
            }
            active?.click();
            return;
          }
          const btn = byId("playBtn");
          if (isVisible(btn)) btn.click();
        }
        function dashboardEnter() {
          const active =
            document.querySelector(".dash-card.active") ||
            document.querySelector(".dash-card");
          if (active) openCardFromDashboard(active); // A/Cross open CONFIG
        }
        function dashArrow(key) {
          if (typeof window.dashboardArrow === "function") {
            window.dashboardArrow({
              key,
              preventDefault() {},
              stopPropagation() {},
            });
          }
        }
        function settingsStep(delta) {
          const content = document.querySelector(".settings-content");
          if (content) moveFocus(content, delta);
        }
        function settingsTabCycle(dir) {
          const tabs = Array.from(document.querySelectorAll(".settings-tab"));
          const active = document.querySelector(".settings-tab.active");
          if (!tabs.length || !active) return;
          let i = tabs.indexOf(active);
          i = (i + dir + tabs.length) % tabs.length;
          tabs[i]?.click();
        }
        function adjustSelectOrRangeHoriz(dir) {
          const t = document.activeElement;
          if (!t) return;
          if (t.tagName === "SELECT") {
            t.selectedIndex = Math.min(
              t.options.length - 1,
              Math.max(0, t.selectedIndex + dir),
            );
            t.dispatchEvent(new Event("change"));
          } else if (t.type === "range") {
            const step = parseFloat(t.step || "1") || 1;
            const min = parseFloat(t.min || "0") || 0;
            const max = parseFloat(t.max || "100") || 100;
            const next = Math.max(
              min,
              Math.min(max, Number(t.value) + step * dir),
            );
            t.value = String(next);
            t.dispatchEvent(new Event("input"));
          }
        }

        // ---- Action router
        function route(action) {
          const overlay = getActiveOverlaySafe();
          //Main Window

          function isSkippableOption(opt) {
            if (!opt) return true;
            const txt = (opt.text || "").trim();
            return opt.disabled || opt.value === "" || /^select$/i.test(txt);
          }

          function nextSelectableIndex(select, fromIndex, dir) {
            const { options } = select;
            let i = fromIndex;

            if (isSkippableOption(options[i])) {
              i = dir > 0 ? -1 : options.length;
            }

            for (let step = 0; step < options.length; step++) {
              i += dir;
              if (i < 0 || i >= options.length) break;
              if (!isSkippableOption(options[i])) return i;
            }
            return fromIndex;
          }

          const focused = document.activeElement;
          if (overlay === "dashboard" && window.__dashboardContextMenuOpen) {
            if (action === A.BACK || action === A.MENU) {
              window.closeDashboardContextMenu?.();
              return;
            }
            if (action === A.CONFIRM) {
              window.activateDashboardContextMenu?.();
              return;
            }
            if (action === A.UP || action === A.LEFT) {
              window.moveDashboardContextMenuFocus?.(-1);
              return;
            }
            if (action === A.DOWN || action === A.RIGHT) {
              window.moveDashboardContextMenuFocus?.(1);
              return;
            }
          }
          if (overlay === "onboarding") {
            const onboardingModal = document.getElementById(
              "bootOnboardingModal",
            );
            if (action === A.BACK) {
              return;
            }
            if (action === A.CONFIRM) {
              const active = document.activeElement;
              if (active && typeof active.click === "function") {
                active.click();
                return;
              }
              const startBtn = document.getElementById(
                "bootOnboardingStartBtn",
              );
              startBtn?.click();
              return;
            }
            if (
              action === A.LEFT ||
              action === A.RIGHT ||
              action === A.UP ||
              action === A.DOWN
            ) {
              moveFocus(
                onboardingModal,
                action === A.LEFT || action === A.UP ? -1 : 1,
              );
              return;
            }
            return;
          }
          if (overlay === "confirm") {
            if (action === A.BACK) {
              closeAppConfirm(false);
              return;
            }
            if (action === A.CONFIRM) {
              const ok = document.getElementById("appConfirmOkBtn");
              const cancel = document.getElementById("appConfirmCancelBtn");
              const active = document.activeElement;
              if (active === cancel) {
                closeAppConfirm(false);
                return;
              }
              if (active === ok) {
                closeAppConfirm(true);
                return;
              }
              if (
                active &&
                confirmModal &&
                confirmModal.contains(active) &&
                typeof active.click === "function"
              ) {
                active.click();
                return;
              }
              closeAppConfirm(true);
              return;
            }
            if (
              action === A.LEFT ||
              action === A.RIGHT ||
              action === A.UP ||
              action === A.DOWN
            ) {
              const ok = document.getElementById("appConfirmOkBtn");
              const cancel = document.getElementById("appConfirmCancelBtn");
              const active = document.activeElement;
              if (active === ok && cancel) {
                cancel.focus({ preventScroll: true });
              } else if (ok) {
                ok.focus({ preventScroll: true });
              }
              return;
            }
          }
          if (
            focused &&
            focused.tagName === "SELECT" &&
            (action === A.LEFT || action === A.RIGHT)
          ) {
            const dir = action === A.LEFT ? -1 : +1;
            const nextIndex = nextSelectableIndex(
              focused,
              focused.selectedIndex,
              dir,
            );
            if (nextIndex !== focused.selectedIndex) {
              focused.selectedIndex = nextIndex;
              focused.dispatchEvent(new Event("change", { bubbles: true }));
            }
            return;
          }

          // --- Controller-friendly SELECT handling (works in Main + Settings) ---
          if (focused && focused.tagName === "SELECT") {
            if (isSelectOpen && isSelectOpen(focused)) {
              if (action === A.UP || action === A.DOWN) {
                const dir = action === A.DOWN ? +1 : -1;
                let i = focused.selectedIndex;
                i = Math.max(0, Math.min(focused.options.length - 1, i + dir));
                if (i !== focused.selectedIndex) {
                  focused.selectedIndex = i;
                  const opt = focused.options[i];
                  if (opt) opt.scrollIntoView({ block: "nearest" });
                }
                return;
              }
              if (action === A.CONFIRM) {
                closeSelectList(focused, /*confirm*/ true);
                return;
              }
              if (action === A.BACK) {
                closeSelectList(focused, /*confirm*/ false);
                return;
              }
              if (action === A.LEFT || action === A.RIGHT) {
                return;
              }
            } else {
              if (action === A.CONFIRM) {
                openSelectList(focused, { preferNative: false });
                return;
              }
            }
          }

          // --- Global
          if (action === A.BACK) return backOrClose();
          if (action === A.SETTINGS) return toggleSettings();
          if (action === A.DASHBOARD) return toggleDashboard();
          if (action === A.OPTIONS) return toggleOptions();
          if (action === A.CONFIG) return openConfig();
          if (action === A.PLAY) return tryPlay();
          if (action === A.SEARCH) {
            if (overlay === "dashboard") {
              window.focusDashboardSearch?.(true);
              return;
            }
            if (overlay === "main") {
              window.focusAchievementsSearch?.(true);
              return;
            }
            return;
          }
          if (action === A.MENU) {
            if (overlay === "dashboard") {
              return window.openDashboardContextMenuFromFocus?.();
            }
            return;
          }

          if (overlay === "settings") {
            const mode = (window.__settingsMode ?? __settingsMode) || "tabs";

            if (mode === "tabs") {
              if (action === A.DOWN) {
                settingsTabsFocusMove(+1);
                return;
              }
              if (action === A.UP) {
                settingsTabsFocusMove(-1);
                return;
              }
              if (action === A.CONFIRM) {
                settingsTabsSelect();
                return;
              }
              if (action === A.BACK) {
                window.closeSettingsModal?.();
                return;
              }
              return;
            }

            if (mode === "section") {
              if (action === A.DOWN) {
                settingsSectionFocusMove(+1);
                return;
              }
              if (action === A.UP) {
                settingsSectionFocusMove(-1);
                return;
              }
              if (action === A.LEFT) {
                settingsAdjust(-1);
                return;
              }
              if (action === A.RIGHT) {
                settingsAdjust(+1);
                return;
              }
              if (action === A.BACK) {
                settingsEnterTabsMode();
                return;
              }
              if (action === A.CONFIRM) {
                settingsSectionActivate();
                return;
              }
              return;
            }
          }

          if (overlay === "dashboard") {
            const markKb = () => markScrollSource("kb");
            if (action === A.UP) {
              markKb();
              return dashArrow("ArrowUp");
            }
            if (action === A.DOWN) {
              markKb();
              return dashArrow("ArrowDown");
            }
            if (action === A.LEFT) {
              markKb();
              return dashArrow("ArrowLeft");
            }
            if (action === A.RIGHT) {
              markKb();
              return dashArrow("ArrowRight");
            }
            if (action === A.HOME) {
              markKb();
              return dashArrow("Home");
            }
            if (action === A.END) {
              markKb();
              return dashArrow("End");
            }
            if (action === A.CONFIRM) return dashboardEnter();
            return;
          }

          // main / config
          if (action === A.CONFIRM) {
            const f = document.activeElement;
            if (f && typeof f.click === "function") f.click();
            return;
          }
          if (action === A.UP || action === A.DOWN) {
            const container = byId("buttonContainer");
            if (container && isVisible(container))
              moveFocus(container, action === A.UP ? -1 : +1);
          }
          // LEFT/RIGHT
        }

        // ---- Keyboard
        function onKeyDown(e) {
          if (isTypingTarget(e.target) && e.key === "Backspace") {
            return;
          }
          const special =
            ["F1", "F2", "F3", "Escape", "Backspace"].includes(e.key) ||
            (e.ctrlKey &&
              ["o", "O", "d", "D", "n", "N", "Enter"].includes(e.key)) ||
            (e.key === "Enter" && (e.ctrlKey || e.shiftKey)) ||
            e.key.toLowerCase() === "p";
          const recording = byId("overlay-shortcut-btn")?.classList?.contains(
            "listening",
          );
          const overlayNow = getActiveOverlaySafe();
          const allowSettingsNavKey =
            overlayNow === "settings" &&
            [
              "ArrowUp",
              "ArrowDown",
              "ArrowLeft",
              "ArrowRight",
              "Home",
              "End",
              "Enter",
              " ",
              "PageUp",
              "PageDown",
            ].includes(e.key);
          const allowArrowsOnClosedSelectInMain =
            overlayNow === "main" &&
            e.target?.tagName === "SELECT" &&
            !isSelectOpen(e.target) &&
            (e.key === "ArrowUp" || e.key === "ArrowDown");

          if (
            isTypingTarget(e.target) &&
            !special &&
            !allowSettingsNavKey &&
            !allowArrowsOnClosedSelectInMain
          ) {
            return;
          }
          if (recording && !special) return;

          if (overlayNow === "dashboard" && window.__dashboardContextMenuOpen) {
            if (["ArrowUp", "ArrowLeft"].includes(e.key)) {
              e.preventDefault();
              return route(A.UP);
            }
            if (["ArrowDown", "ArrowRight"].includes(e.key)) {
              e.preventDefault();
              return route(A.DOWN);
            }
            if (e.key === "Enter" || e.key === " ") {
              e.preventDefault();
              return route(A.CONFIRM);
            }
            if (e.key === "Escape" || e.key === "Backspace") {
              e.preventDefault();
              return route(A.BACK);
            }
          }

          // --- Select dropdown open/close (Main) ---
          try {
            const overlayCtx = getActiveOverlaySafe && getActiveOverlaySafe();
            //const mode = (window.__settingsMode ?? __settingsMode) || null;
            const t = e.target;
            const inMain = overlayCtx === "main";
            const inSettings = overlayCtx === "settings";
            //const inSettingsSection = overlayCtx === "settings" && mode === "section";
            if ((inMain || inSettings) && isSelectEl && isSelectEl(t)) {
              if (isSelectOpen && isSelectOpen(t)) {
                handleOpenSelectKey(e, t);
                return;
              }
              if (e.key === "Enter") {
                e.preventDefault();
                e.stopPropagation();
                openSelectList(t);
                return;
              }
            }
          } catch {}

          // Global first
          if (e.key === "Escape") {
            e.preventDefault();
            return route(A.BACK);
          }
          if (e.key === "Backspace") {
            if (isTypingTarget(e.target)) return;
            e.preventDefault();
            return route(A.BACK);
          }
          if (e.key === "F1" || (e.ctrlKey && ["o", "O"].includes(e.key))) {
            e.preventDefault();
            return route(A.SETTINGS);
          }
          if (e.key === "F2" || (e.ctrlKey && ["d", "D"].includes(e.key))) {
            e.preventDefault();
            return route(A.DASHBOARD);
          }
          if (e.key === "F3") {
            e.preventDefault();
            return route(A.OPTIONS);
          }
          if (
            overlayNow === "dashboard" &&
            (e.key === "ContextMenu" || (e.shiftKey && e.key === "F10"))
          ) {
            e.preventDefault();
            return route(A.MENU);
          }
          if (
            !isTypingTarget(e.target) &&
            (e.key.toLowerCase() === "p" ||
              (e.key === "Enter" && (e.ctrlKey || e.shiftKey)))
          ) {
            e.preventDefault();
            return route(A.PLAY);
          }
          if (e.ctrlKey && (e.key === "f" || e.key === "F")) {
            e.preventDefault();
            return route(A.SEARCH);
          }
          if (e.key === "PageUp" || e.key === "PageDown") {
            e.preventDefault();
            scrollByPage(e.key === "PageDown" ? "down" : "up");
            return;
          }

          if (
            overlayNow === "dashboard" &&
            e.altKey &&
            !e.ctrlKey &&
            !e.metaKey &&
            !e.shiftKey
          ) {
            if (e.key === "1") {
              e.preventDefault();
              window.__dashboardCycleSort?.("name");
              return;
            }
            if (e.key === "2") {
              e.preventDefault();
              window.__dashboardCycleSort?.("progress");
              return;
            }
            if (e.key === "3") {
              e.preventDefault();
              window.__dashboardCycleSort?.("updated");
              return;
            }
          }
          // Navigation
          const navKeys = {
            ArrowUp: A.UP,
            ArrowDown: A.DOWN,
            ArrowLeft: A.LEFT,
            ArrowRight: A.RIGHT,
            Home: A.HOME,
            End: A.END,
            Enter: A.CONFIRM,
            " ": A.CONFIRM,
          };
          if (e.key in navKeys) {
            e.preventDefault();
            route(navKeys[e.key]);
          }
          const overlay = getActiveOverlaySafe();
          if (
            overlay === "settings" &&
            [
              "ArrowUp",
              "ArrowDown",
              "ArrowLeft",
              "ArrowRight",
              "Home",
              "End",
            ].includes(e.key)
          ) {
            e.preventDefault();
            return;
          }
        }

        // ---- Gamepad
        let last = { ts: 0, buttons: {} };
        function edge(name, pressed) {
          const prev = !!last.buttons[name];
          last.buttons[name] = !!pressed;
          return !!pressed && !prev;
        }
        function canRepeat() {
          return performance.now() - last.ts > REPEAT_MS;
        }
        function tickRepeat() {
          last.ts = performance.now();
        }

        function gpLoop() {
          const pads = navigator.getGamepads
            ? Array.from(navigator.getGamepads()).filter(Boolean)
            : [];
          const pad = pads[0];
          const recording = byId("overlay-shortcut-btn")?.classList?.contains(
            "listening",
          );
          const windowActive =
            typeof document.hasFocus === "function"
              ? document.hasFocus()
              : document.visibilityState !== "hidden";
          const isVisible = document.visibilityState !== "hidden";

          if (!windowActive || !isVisible) {
            requestAnimationFrame(gpLoop);
            return;
          }

          if (pad && !recording) {
            const Abtn = !!pad.buttons?.[0]?.pressed; // A / Cross
            const Bbtn = !!pad.buttons?.[1]?.pressed; // B / Circle
            const Xbtn = !!pad.buttons?.[2]?.pressed; // X / Square
            const Ybtn = !!pad.buttons?.[3]?.pressed; // Y / Triangle
            const LB = !!pad.buttons?.[4]?.pressed; // L1 / LB
            const RB = !!pad.buttons?.[5]?.pressed; // R1 / RB
            const SEL = !!pad.buttons?.[8]?.pressed; // Select / Back
            const START = !!pad.buttons?.[9]?.pressed; // Start / Options
            const U = !!pad.buttons?.[12]?.pressed; // D-pad
            const D = !!pad.buttons?.[13]?.pressed;
            const L = !!pad.buttons?.[14]?.pressed;
            const R = !!pad.buttons?.[15]?.pressed;
            const TPbtn = !!pad.buttons?.[17]?.pressed; //Touchopad button
            const XBbtn = !!pad.buttons?.[16]?.pressed; //Guide/Xbox button
            const lx = pad.axes?.[0] || 0;
            const ly = pad.axes?.[1] || 0;
            const rx = pad.axes?.[2] || 0; // Right Stick X
            const ry = pad.axes?.[3] || 0; // Right Stick Y

            const rsDy = rsAxisToDelta(ry);
            const rsDx = rsAxisToDelta(rx);
            if (rsDy !== 0 || rsDx !== 0) {
              rightStickScroll(rsDy, rsDx);
            }
            // Right Stick -> scroll/select
            if (
              (Math.abs(rx) > RS_DEADZONE || Math.abs(ry) > RS_DEADZONE) &&
              canRepeatRS()
            ) {
              rightStickScroll(ry, rx);
              tickRepeatRS();
            }
            // Global shortcuts
            const overlay = getActiveOverlaySafe?.() || "main";
            if (edge("SEL", SEL)) route(A.SETTINGS);
            if (edge("TPbtn", TPbtn)) route(A.DASHBOARD);
            if (edge("GUIDE", XBbtn)) route(A.DASHBOARD);
            if (edge("B", Bbtn)) route(A.BACK);
            if (edge("X", Xbtn)) {
              if (overlay === "main") {
                route(A.OPTIONS);
              } else if (overlay === "dashboard") {
                route(A.SEARCH);
              }
            }
            if (edge("Y", Ybtn)) {
              if (overlay === "dashboard") {
                route(A.MENU);
              }
            }
            if (edge("START", START)) route(A.PLAY);
            if (overlay === "dashboard") {
              if (edge("LB", LB)) window.__dashboardCycleSort?.("updated");
              if (edge("RB", RB)) window.__dashboardCycleSort?.("progress");
              if (edge("LS", pad.buttons?.[10]?.pressed)) {
                window.__dashboardCycleSort?.("name");
              }
            } else {
              if (edge("LB", LB)) settingsTabCycle(-1); // LB = tab
              if (edge("RB", RB)) settingsTabCycle(+1);
            }

            // D-pad + stick repeat
            if (canRepeat()) {
              if (U || ly < -DEADZONE) {
                route(A.UP);
                tickRepeat();
              } else if (D || ly > DEADZONE) {
                route(A.DOWN);
                tickRepeat();
              } else if (L || lx < -DEADZONE) {
                route(A.LEFT);
                tickRepeat();
              } else if (R || lx > DEADZONE) {
                route(A.RIGHT);
                tickRepeat();
              }
            }
            if (edge("A", Abtn)) route(A.CONFIRM);
          }

          requestAnimationFrame(gpLoop);
        }

        // ---- Init / Destroy
        function init() {
          if (window.__globalKeyHandler) {
            document.removeEventListener(
              "keydown",
              window.__globalKeyHandler,
              true,
            );
          }
          document.addEventListener("keydown", onKeyDown, {
            capture: false,
            passive: false,
          });
          window.__globalKeyHandler = onKeyDown;
          requestAnimationFrame(gpLoop);
        }

        function destroy() {
          document.removeEventListener("keydown", onKeyDown, {
            capture: false,
          });
          window.__unifiedNavActive = false;
        }
        window.UnifiedNav = { destroy };
        init();
      })();
    </script>
  </body>
</html>
