<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<link rel="stylesheet" href="style.css">
<script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<title>Achievements</title>
<style>
html, body {
user-select: none;
overflow-y: auto;
overflow-x: hidden;
height: 100vh;
}
body::-webkit-scrollbar {
display: none;
}
button,
input,
textarea,
select {
-webkit-app-region: no-drag;
}
table {
width: 90%;
border-collapse: collapse;
}
table, th, td {
margin-top: 20px;
border: 1px solid black;
}

.displayName {			
padding-left: 15px;
}
.description {
padding-left: 25px;
}
.image {
padding-top: 5px;
text-align: center;
}
img {
width: 100px;
height: auto;
align-self: center;
}
#config-list {
margin-top: 10px;
margin-bottom: 20px; 
}
button {
margin-top: 10px; 
margin-bottom: 20px;
}
label {
margin-top: 10px; 
margin-bottom: 20px; 
}
.status {
text-align: center;
vertical-align: middle;
font-size: 14px;
}
.locked { color: red; font-weight: bold; }
.unlocked { color: green; font-weight: bold; }

.progress-bar { height: 5px; background-color: #44475a; border-radius: 3px; overflow: hidden; margin-top: 4px; width: 50%; }
.progress-fill { height: 100%; background-color: #50fa7b; border-radius: 3px; transition: width 0.3s ease; }
.achievement-progress { font-size: 0.85em; color: #888; }

</style>
</head>

<!-- Image script -->
<script>
window.addEventListener('DOMContentLoaded', () => {
  const embedRoot   = document.getElementById('embeddedGameImage');
  const imgWrap     = document.getElementById('embeddedImageContainer');
  const imgEl       = document.getElementById('embeddedGameImageImg');
  const fallbackBox = document.getElementById('embeddedFallbackPrompt');
  const fallbackIcon = new URL('./assets/achievements-logo.png', window.location.href).toString();

  if (!embedRoot || !imgWrap || !imgEl) return;

  // --- fallback logo ---
  function showFallbackLogo() {
    imgEl.onload = null;
    imgEl.onerror = null;
    imgEl.src = fallbackIcon;
    imgWrap.style.display = 'flex';
    if (fallbackBox) fallbackBox.style.display = 'none';
  }
  window.__showFallbackLogo = showFallbackLogo;
  showFallbackLogo();

  // --- UI helpers ---
  function setVisible(hasImage) {
    if (hasImage) {
      if (fallbackBox) fallbackBox.style.display = 'none';
      imgWrap.style.display = 'flex';
    } else {
      imgWrap.style.display = 'flex';
      if (fallbackBox) fallbackBox.style.display = 'none';
    }
  }

  function fileUrl(p) {
    return `file:///${encodeURI(String(p).replace(/\\/g,'/'))}`;
  }

  function setImg(src) {
    return new Promise((resolve, reject) => {
      imgEl.onload  = () => resolve();
      imgEl.onerror = () => reject(new Error('image load failed'));
      const isFile = src.startsWith('file://');
      const finalSrc = isFile ? src : `${src}${src.includes('?') ? '&' : '?'}v=${Date.now()}`;
      imgEl.src = finalSrc;
    });
  }

  async function setImgFromLocal(localPath) {
    const url = fileUrl(localPath);
    await setImg(url);
  }

  // --- CDN download (jpg -> png) ---
  async function downloadAndSave(targetAppId, url) {
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP ' + res.status);
    const blob = await res.blob();
    const buf  = new Uint8Array(await blob.arrayBuffer());
    await window.api.saveGameImage(String(targetAppId), buf);
  }

  async function downloadFromCdnAndCache(appid) {
    const JPG = `https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/${appid}/library_600x900.jpg`;
    const PNG = `https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/${appid}/portrait.png`;
    try { await downloadAndSave(appid, JPG); return true; }
    catch {}
    try { await downloadAndSave(appid, PNG); return true; }
    catch {}
    return false;
  }

  // --- loader: local -> (fallback) -> CDN -> local ---
  async function loadLocalCover(appid) {
    if (!appid) { showFallbackLogo(); return; }

    try {
      const localPath = await window.api.checkLocalGameImage(String(appid));

      if (localPath) {
        try {
          await setImgFromLocal(localPath);
          setVisible(true);
          return;
        } catch {         
          showFallbackLogo();
          return;
        }
      }      
      showFallbackLogo();

      const ok = await downloadFromCdnAndCache(String(appid));
      if (!ok) return;

      const newLocal = await window.api.checkLocalGameImage(String(appid));
      if (newLocal) {
        try { await setImgFromLocal(newLocal); setVisible(true); }
        catch { showFallbackLogo(); }
      } else {
        showFallbackLogo();
      }
    } catch {
      showFallbackLogo();
    }
  }
  window.__applyEmbeddedGameImageForAppId = async function (appid) {
    if (!appid) { showFallbackLogo(); return; }
    try { await loadLocalCover(String(appid)); }
    catch { showFallbackLogo(); }
  };

  // ‚úé prompt
  window.showAltAppIdPrompt = function () {
    if (fallbackBox) fallbackBox.style.display = 'flex';
    imgWrap.style.display = 'none';
    const input = document.getElementById('altAppId');
    if (input) { input.focus(); input.select(); }
  };

  window.cancelFallback = function () {
    if (fallbackBox) fallbackBox.style.display = 'none';
    imgWrap.style.display = 'flex';
  };

  // alt AppID
  window.downloadFromAlternativeAppId = async function () {
    const input = document.getElementById('altAppId');
    const alt = (input?.value || '').trim();
    if (!/^\d+$/.test(alt)) { alert('Please enter a valid AppID'); return; }

    const selectedConfig = document.getElementById('configList')?.value;
    const currentConfig = selectedConfig ? await window.api.getConfigByName(selectedConfig) : null;
    const currentAppId = currentConfig?.appid || alt;

    let ok = false;
    try {
      await downloadAndSave(String(currentAppId),
        `https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/${alt}/library_600x900.jpg`);
      ok = true;
    } catch {
      try {
        await downloadAndSave(String(currentAppId),
          `https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/${alt}/portrait.png`);
        ok = true;
      } catch {}
    }

    if (ok) {
      const newLocal = await window.api.checkLocalGameImage(String(currentAppId));
      if (newLocal) {
        try { await setImgFromLocal(newLocal); } catch {}
        if (fallbackBox) fallbackBox.style.display = 'none';
        imgWrap.style.display = 'flex';
      }
    }
  };

  // update main
  if (!window.__imageListenerAttached) {
    window.api?.on?.('update-image', async (payload) => {
      const appid = (typeof payload === 'object' && payload?.appid)
        ? String(payload.appid)
        : (/^\d+$/.test(String(payload)) ? String(payload) : null);
      if (appid) await loadLocalCover(appid);
      else showFallbackLogo();
    });
    window.__imageListenerAttached = true;
  }
});
</script>





<body>
<!-- Modern Titlebar -->
<div class="titlebar">
  <div class="titlebar-logo">
    <img id="appIcon" alt="App Icon">
    <span class="titlebar-title">Achievements</span>
  </div>
  <div class="titlebar-controls">
    <button id="settingsBtn" class="titlebar-button">
      <i class="fas fa-cog"></i>
    </button>
    <button id="minimizeBtn" class="titlebar-button">
      <i class="fas fa-minus"></i>
    </button>
    <button id="maximizeBtn" class="titlebar-button">
      <i class="far fa-square"></i>
    </button>
    <button id="closeBtn" class="titlebar-button close">
      <i class="fas fa-times"></i>
    </button>
  </div>
</div>

<!-- Settings Menu Panel -->
<div id="settingsMenu" class="settings-menu hidden">
  <div class="settings-content" tabindex="-1">
    <button class="settings-close-button" id="closeSettingsBtn">&times;</button>
    
    <div class="settings-tabs">
      <h3 style="margin: 0 0 15px 10px; color: var(--dracula-purple);">Settings</h3>
      <button class="settings-tab active" data-tab="general">General</button>
      <button class="settings-tab" data-tab="notification">Notification</button>
    </div>
    
    <div class="settings-tabs-content">
      <div id="generalTab" class="tab-content active">
        <div style="padding: 0 5px;">
          <div class="settings-section">
            <h4>App Scale</h4>
            <div class="settings-control">			
              <label for="app-zoom-dropdown">Zoom Level:</label>
              <select id="app-zoom-dropdown">
                <option value="0.75">75%</option>
                <option value="1" selected>100%</option>
                <option value="1.25">125%</option>
                <option value="1.5">150%</option>
                <option value="2">200%</option>
              </select>
            </div>
          </div>
          <div class="settings-section" style=" margin-bottom: 5px;">
            <h4>Overlay Shortcut</h4>
            <div class="settings-control">
              <label for="overlay-shortcut-btn">Shortcut Key:</label>
              <button id="overlay-shortcut-btn" type="button">Set Shortcut</button>
            </div>
          </div>
			<div class="settings-section">
			  <h4>Startup</h4>
			  <div class="checkbox-control">
				<input type="checkbox" id="settings-startInTrayCheckbox" />
				<label for="settings-startInTrayCheckbox">Start in tray</label>
			  </div>
			</div>		
			<div class="settings-section" style="margin-bottom: 5px;">
			  <h4>Achievements Screenshots</h4>
			  <div class="settings-control">
				<div class="input-with-button">
				<label for="settings-screenshotFolder">Save to folder:</label>	
				  <input type="text" id="settings-screenshotFolder" placeholder="Choose a folder" readonly />
				  <button type="button" id="settings-selectScreenshotFolder" aria-label="Choose folder">üìÇ</button>
				</div>				
			  </div>
			  <div class="checkbox-control" style="margin-top: -10px;">
				<input type="checkbox" id="settings-disableScreenshotCheckbox" />
				<label for="settings-disableScreenshotCheckbox">Disable Screenshot</label>
			  </div>
			</div>			
        </div>
      </div>
      
      <div id="notificationTab" class="tab-content">
        <div style="padding: 0 5px;">
          <div class="settings-section">
            <h4>Achievement Testing</h4>
            <button id="settings-testAchievementBtn" class="settings-test-button" style="width: 100%; margin: 10px 0; padding: 10px;">Test Achievement</button>
            
            <div class="checkbox-control">
              <input type="checkbox" id="settings-disableProgressCheckbox" />
              <label for="settings-disableProgressCheckbox">Disable Progress Report</label>
            </div>

            <div class="checkbox-control">
              <input type="checkbox" id="settings-disablePlaytimeCheckbox" />
              <label for="settings-disablePlaytimeCheckbox">Disable Playtime</label>
            </div>
			
            <div class="settings-slider">
              <label for="settings-scaleSlider">Achievement Scale: <span id="settings-scaleValue">1.0</span></label>
              <div class="slider-control">
                <input type="range" id="settings-scaleSlider"
                  min="0.01" max="2.0" step="0.01" value="1.0" />
                <span class="value" id="settings-scaleValueDisplay">100%</span>
              </div>
            </div>
            
            <div class="settings-control">
              <label for="settings-positionDropdown">Achievement Position:</label>
              <select id="settings-positionDropdown">
                <option value="center-bottom">Center Bottom</option>
                <option value="center-top">Center Top</option>
                <option value="top-right">Top Right</option>
                <option value="bottom-right">Bottom Right</option>
                <option value="top-left">Top Left</option>
                <option value="bottom-left">Bottom Left</option>
              </select>
            </div>
            
            <div class="settings-control">
              <label for="settings-presetDropdown">Achievement Presets:</label>
              <select id="settings-presetDropdown"></select>
            </div>
            
            <div class="settings-control">
              <label for="settings-soundSelect">Achievement Sound:</label>
              <select id="settings-soundSelect"></select>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="top-bar">
  <div id="left-controls" style="margin-left: 10px; position: relative; display: flex; flex-direction: column; align-items: flex-start; gap: 10px;">
    <!-- Remove the zoom dropdown from here since it's now in the settings menu -->
  </div>
</div>

<div class="container">
  <div id="left-controls" style="position: relative; display: flex; flex-direction: column; align-items: flex-start; gap: 10px;">
    <!-- Shortcut input button removed -->
  </div>
<!-- Toggle Settings Button -->
<div style="margin-bottom: 10px; position: relative; display: flex; align-items: center; gap: 10px;">
<button id="toggleBtn">Show Options</button>

<!-- Progres bar -->
<div id="achStats" style="
display: none;
position: absolute;
left: 50%;
transform: translateX(-50%);
text-align: center;
width: 320px;
z-index: 10;
margin-top: -30px;
">
<label id="achStatsText" style="color: white; font-weight: bold;">Progress: 0 / 0</label>
<div style="width: 100%; background: #ccc; border-radius: 8px; height: 12px; margin-top: -10px; position: relative;">
<div id="achStatsBar" style="width: 0%; height: 100%; background: #4caf50; border-radius: 8px; transition: width 0.3s;"></div>
<span id="achStatsPercent" style="
position: absolute;
right: 5px;
top: -22px;
font-size: 12px;
color: white;
font-weight: bold;
">0%</span>
</div>
</div>

<button id="playBtn" style="margin-left: auto;"><i class="fas fa-play"></i> Play</button>
</div>

<!-- Toggleable Settings Container -->
<div id="buttonContainer" class="hidden config-container" style="display: none; justify-content: space-between; gap: 15px;">

<!-- Left Side: Create Config and Select Config -->
<div class="left-config" style="flex: 1; min-width: 300px; display: flex; flex-direction: column; gap: 5px;">
<div>
<div style="display: flex; gap: 20px;">
  <button id="createNewConfigBtn" style="flex: 1; padding: 10px;">
    Create New Config <span id="arrowIcon">‚ñº</span>
  </button>
  
  <button id="generateConfigsBtn" style="flex: 1; padding: 10px;">
    Generate Auto-Configs
  </button>
</div>



<div id="configModal" class="modal hidden">
<div class="modal-content">
<span class="close-button" id="closeConfigModal">&times;</span>
<h2 id="configFormTitle" style="margin-top: 0;">Config Form</h2>

<div id="new-config-form" style="display: flex; flex-direction: column; gap: 14px; margin-top: -10px;">
<div style="display: flex; gap: 20px;">
<!-- Right -->
<div style="flex: 1; display: flex; flex-direction: column;">
<label for="configName">Config Name:</label>
<input type="text" id="configName" placeholder="Enter Config Name *">

<label for="appid">AppID:</label>
<input type="text" id="appid" placeholder="Enter AppID *">

<label for="configPath">Config path:</label>
<div class="input-with-button">
<input type="text" id="configPath" placeholder="Select config folder path *">
<button type="button" id="selectConfigFolder">üìÇ</button>
</div>

<label for="savePath">Save path:</label>
<div class="input-with-button">
<input type="text" id="savePath" placeholder="Select save folder path *">
<button type="button" id="selectSaveFolder">üìÇ</button>
</div>
</div>

<!-- Left -->
<div style="flex: 1; display: flex; flex-direction: column; ">
<label for="executablePath">Executable (optional):</label>
<div class="input-with-button">
<input type="text" id="executablePath" placeholder="Path to executable">
<button type="button" id="selectExecutable">üìÇ</button>
</div>

<label for="exeArgs">Arguments (optional):</label>
<input type="text" id="exeArgs" placeholder="Optional arguments">

<label for="processName">Process name (optional):</label>
<input type="text" id="processName" placeholder="Optional ‚Äì real .exe name">
</div>
</div>

<!-- Buton Save -->
<div style="display: flex; justify-content: center; margin-top: 5px;">
<button id="saveBtn" style="background-color: #4CAF50; color: white; border: none; padding: 10px 24px; border-radius: 6px; font-weight: bold; width: auto;">
Save Config
</button>
</div>
</div>
</div>
</div>

</div>

<div class="config-controls clean">
  <label for="configList" class="field-label">Select Config:</label>
  <select id="configList" class="field-input">
    <option value="" disabled selected>Select</option>
  </select>

  <button id="deleteConfigBtn" style="display:none; margin-top: 25px;">Delete</button>

  <div class="button-row">
	<button id="editConfigBtn" style="display:none;">Edit Config</button>
    <button id="backButton" class="hidden">Back</button>    
  </div>

  <div class="language-controls">
    <label for="languageSelect" class="field-label">Select Language:</label>
    <select id="languageSelect" class="field-input">
      <option value="english">English</option>
      <option value="german">Deutsch</option>
      <option value="french">Fran√ßais</option>
      <option value="italian">Italiano</option>
      <option value="koreana">ÌïúÍµ≠Ïñ¥ (Korean)</option>
      <option value="spanish">Espa√±ol</option>
      <option value="schinese">ÁÆÄ‰Ωì‰∏≠Êñá (Chinese - Simplified)</option>
      <option value="tchinese">ÁπÅÈ´î‰∏≠Êñá (Chinese - Traditional)</option>
      <option value="russian">–†—É—Å—Å–∫–∏–π</option>
      <option value="japanese">Êó•Êú¨Ë™û</option>
      <option value="polish">Polski</option>
      <option value="brazilian">Portugu√™s (Brasil)</option>
      <option value="LATAM">Espa√±ol (Latinoam√©rica)</option>
    </select>
  </div>
</div>

</div>

<!-- Right Side: Test Achievement + Dropdowns -->
<!--div class="settings-container" style="flex: 1; min-width: 300px; display: flex; flex-direction: column; gap: 5px;">
  <!-- Content removed as it's now in the settings modal -->
<!--/div-->
<!-- Right Side: Game Image (embedded) -->
<div class="settings-container" style="flex:1; min-width:300px; display:flex; flex-direction:column; gap:5px;">
  <div id="embeddedGameImage" class="game-image-embed">
    <div id="embeddedImageContainer">
      <img id="embeddedGameImageImg" src="" alt="Game Cover">
      <button id="edit-btn" type="button" onclick="showAltAppIdPrompt()">‚úé</button>
    </div>

    <div id="embeddedFallbackPrompt" style="display:none; flex-direction:column; align-items:center; padding:20px; color:white;">
      <p>‚ö†Ô∏è Does the game have a different Steam AppID on Steam?</p>
      <input type="text" id="altAppId" placeholder="Enter alternative AppID" style="padding:5px; font-size:16px; width:200px;">
      <div style="margin-top: 10px;">
        <button type="button" onclick="downloadFromAlternativeAppId()">‚úÖ Try Alternative</button>
        <button type="button" onclick="cancelFallback()" style="margin-left:5px;">‚úñ Cancel</button>
      </div>
    </div>
  </div>
</div>
</div>
</div>

<div class="scroll-container">
<table class="achievements">
<thead><tr></tr></thead>
<tbody id="achievementsTableBody"></tbody>
</table>
<div style="height: 50px;"></div>
</div>

<!-- Hidden elements to maintain compatibility with existing code -->
<div style="display: none;">
  <button id="testAchievementBtn">Test Achievement</button>
  <input type="checkbox" id="disableProgressCheckbox" />
  <input type="range" id="scaleSlider" min="0.01" max="2.0" step="0.01" value="1.0" />
  <span id="scaleValue">1.0</span>
  <select id="positionDropdown">
    <option value="center-bottom">Center Bottom</option>
    <option value="center-top">Center Top</option>
    <option value="top-right">Top Right</option>
    <option value="bottom-right">Bottom Right</option>
    <option value="top-left">Top Left</option>
    <option value="bottom-left">Bottom Left</option>
  </select>
  <select id="presetDropdown"></select>
  <select id="soundSelect"></select>
</div>

<script>

  window.addEventListener('DOMContentLoaded', () => {
    const iconParam = new URLSearchParams(location.search).get('icon');
    if (!iconParam) return;
    const url = decodeURIComponent(iconParam);
    const el = document.getElementById('appIcon');
    if (el) el.src = url;
  });

//Achievements Images
async function resolveAchievementIcon(imgEl, cfgPath, rel) {
  try {
    const url = await window.api.resolveIconUrl(cfgPath, rel);
    imgEl.onerror = null;          
    imgEl.src = url;               
  } catch {
    imgEl.src = 'https://cdn-icons-png.flaticon.com/512/11455/11455431.png';
  }
}

async function buildMainAchievementsTable(selectedConfig, lang = 'english') {
  if (!selectedConfig) return;

  const achievementsDataObj = await window.api.loadAchievementData(selectedConfig);
  const savedAchievementsObj = await window.api.loadSavedAchievements(selectedConfig);

  const tableBody = document.getElementById('achievementsTableBody');
  if (!tableBody) return;
  tableBody.innerHTML = '';

  if (achievementsDataObj?.error || !Array.isArray(achievementsDataObj?.achievements)) return;

  // Sort after name
  const seen = new Set();
  const unique = [];
  for (const a of achievementsDataObj.achievements) {
    if (!a?.name || seen.has(a.name)) continue;
    seen.add(a.name);
    unique.push(a);
  }

  // unlocked first
  const isUnlocked = (name) => !!(savedAchievementsObj?.achievements?.[name]?.earned);
  unique.sort((a, b) => (isUnlocked(b.name) ? 1 : 0) - (isUnlocked(a.name) ? 1 : 0));

  function tsToLocal(ts) {
    if (!ts) return "N/A";
    const d = new Date((String(ts).length === 10 ? ts * 1000 : Number(ts)));
    return isNaN(d) ? "N/A" : d.toLocaleString();
  }

  for (const achievement of unique) {
    const displayName = getSafeLocalizedText(achievement.displayName, lang);
    const description = getSafeLocalizedText(achievement.description, lang);
    const iconGray = achievement.icon_gray || achievement.icongray;
    const icon = achievement.icon || iconGray;

    const saved = savedAchievementsObj?.achievements?.[achievement.name];
    const imgRel = saved?.earned ? icon : iconGray;
    const imagePath = `file:///${(`${achievementsDataObj.config_path}\\${imgRel}`).replace(/\\/g, '/')}`;

    const statusHTML = saved?.earned
      ? `<span class="unlocked">Unlocked</span>`
      : `<span class="locked">Locked</span>`;

    const earnedTimeText = saved?.earned_time ? `<br>${tsToLocal(saved.earned_time)}` : '';

    let progressText = '';
    if (typeof saved?.progress === 'number' && typeof saved?.max_progress === 'number') {
      const pct = Math.min(100, Math.round((saved.progress / saved.max_progress) * 100));
      progressText = `
        <div class="achievement-progress">
          Progress: ${saved.progress} / ${saved.max_progress}
          <div class="progress-bar">
            <div class="progress-fill" style="width:${pct}%"></div>
          </div>
        </div>`;
    }

    const row = document.createElement('tr');
	row.innerHTML = `
	  <td class="image">
		<img class="ach-icon" alt="Icon" />
	  </td>
	  <td class="displayName">
		<strong>${displayName}</strong><br>
		<span class="description"><em>${description}</em>${progressText}</span>
	  </td>
	  <td class="status">${statusHTML} ${earnedTimeText}</td>
	`;
	tableBody.appendChild(row);
	const imgEl = row.querySelector('img.ach-icon');
	resolveAchievementIcon(imgEl, achievementsDataObj.config_path, imgRel);
}	
	
  // Main Progress Bar
  updateAchievementStats(unique.map(a => ({ ...a, earned: isUnlocked(a.name) })));
  const achStats = document.getElementById('achStats');
  if (achStats) achStats.style.display = 'block';
}

window.api.on('refresh-achievements-table', async (configName) => {
  const cfg  = configName || document.getElementById('configList').value;
  if (!cfg) return;
  const lang = document.getElementById('languageSelect').value || 'english';
  await buildMainAchievementsTable(cfg, lang);
});

const notificationQueue = [];
let isNotificationActive = false;

function showNotification(message, backgroundColor = '#4CAF50') {
notificationQueue.push({ message, backgroundColor });
if (!isNotificationActive) {
processNextNotification();
}
}

function processNextNotification() {
if (notificationQueue.length === 0) {
isNotificationActive = false;
return;
}

document.getElementById('disableProgressCheckbox').addEventListener('change', async (e) => {
const isChecked = e.target.checked;
window.api.disableProgress(isChecked);
await window.api.savePreferences({ disableProgress: isChecked });
});

isNotificationActive = true;
const { message, backgroundColor } = notificationQueue.shift();

const notif = document.createElement('div');
notif.textContent = message;
notif.style.position = 'fixed';
notif.style.top = '100px';
notif.style.left = '50%';
notif.style.transform = 'translateX(-50%)';
notif.style.backgroundColor = backgroundColor;
notif.style.color = 'white';
notif.style.padding = '10px 20px';
notif.style.borderRadius = '5px';
notif.style.boxShadow = '0px 2px 8px rgba(0,0,0,0.3)';
notif.style.zIndex = 9999;
notif.style.fontWeight = 'bold';
notif.style.fontFamily = 'sans-serif';
notif.style.opacity = '0';
notif.style.transition = 'opacity 0.3s ease';
notif.style.pointerEvents = 'none';
notif.style.userSelect = 'none';
document.body.appendChild(notif);
requestAnimationFrame(() => notif.style.opacity = '1');

setTimeout(() => {
notif.style.opacity = '0';
setTimeout(() => {
notif.remove();
processNextNotification();
}, 300); 
}, 4000); 
}

window.api.onNotify(({ message, color }) => {
showNotification(message, color || '#4CAF50');
});

window.addEventListener('DOMContentLoaded', () => {
const originalLog = console.log;
const originalWarn = console.warn;
const originalError = console.error;
const originalAlert = window.alert;

console.log = function (...args) {
originalWarn.apply(console, args);
showNotification(args.join(' '), '#4CAF50');
};

console.warn = function (...args) {
originalWarn.apply(console, args);
showNotification(args.join(' '), '#ff9800');
};

console.error = function (...args) {
originalError.apply(console, args);
showNotification(args.join(' '), '#f44336');
};

window.alert = function (message) {
showNotification(message, '#2196f3');
};
});

const scaleSlider = document.getElementById('scaleSlider');
const scaleValue = document.getElementById('scaleValue');

function updateScaleLabel() {
const value = parseFloat(scaleSlider.value);
scaleValue.textContent = `${Math.round(value * 100)}%`;
scaleSlider.style.background = `linear-gradient(to right, #007bff 0%, #007bff ${value * 100}%, #ccc ${value * 100}%, #ccc 100%)`;
}
scaleSlider.addEventListener('input', () => {
updateScaleLabel();
window.api.savePreferences({ notificationScale: scaleSlider.value });
});
updateScaleLabel();


window.addEventListener('DOMContentLoaded', () => {
const minimizeBtn = document.getElementById('minimizeBtn');
const maximizeBtn = document.getElementById('maximizeBtn');
const closeBtn = document.getElementById('closeBtn');

document.getElementById('closeConfigModal').addEventListener('click', () => {
document.getElementById('configModal').classList.add('hidden');
resetConfigForm();
});
});

let editingConfigName = null;

function resetConfigForm() {
const form = document.getElementById('new-config-form');
const button = document.getElementById('createNewConfigBtn');
document.getElementById('configName').value = '';
document.getElementById('appid').value = '';
document.getElementById('configPath').value = '';
document.getElementById('savePath').value = '';
document.getElementById('executablePath').value = '';
document.getElementById('exeArgs').value = '';
document.getElementById('processName').value = '';

editingConfigName = null;

if (!form.classList.contains('hidden')) {
form.classList.add('hidden');
}

button.innerHTML = 'Create New Config <span id="arrowIcon">‚ñº</span>';
document.getElementById('configFormTitle').textContent = 'Create New Config';
}

document.getElementById('createNewConfigBtn').addEventListener('click', () => {
resetConfigForm();
document.getElementById('configModal').classList.remove('hidden');
document.getElementById('new-config-form').classList.remove('hidden');
document.getElementById('configFormTitle').textContent = 'Create New Config';
});

document.getElementById('editConfigBtn').addEventListener('click', async () => {
const configName = document.getElementById('configList').value;
if (!configName) return;

try {
const currentConfig = await window.api.getConfigByName(configName);

if (!currentConfig) {
alert('Config not found!');
return;
}

document.getElementById('configName').value = currentConfig.name;
document.getElementById('appid').value = currentConfig.appid;
document.getElementById('configPath').value = currentConfig.config_path;
document.getElementById('savePath').value = currentConfig.save_path;
document.getElementById('executablePath').value = currentConfig.executable || '';
document.getElementById('exeArgs').value = currentConfig.arguments || '';
document.getElementById('processName').value = currentConfig.process_name || '';

editingConfigName = currentConfig.name;
const form = document.getElementById('new-config-form');
if (form.style.display !== 'block') {
document.getElementById('configModal').classList.remove('hidden');

}
const button = document.getElementById('createNewConfigBtn');

form.classList.remove('hidden');
button.innerHTML = 'Editing... <span id="arrowIcon" class="rotate-up">‚ñ≤</span>';
document.getElementById('configFormTitle').textContent = 'Edit Config';

} catch (err) {
console.error('Edit error:', err);
alert('Something went wrong loading the config.');
}
});

document.getElementById('selectConfigFolder').addEventListener('click', async () => {
const selectedPath = await window.api.selectFolder();
if (selectedPath) {
document.getElementById('configPath').value = selectedPath;
}
});

document.getElementById('selectSaveFolder').addEventListener('click', async () => {
const selectedPath = await window.api.selectFolder();
if (selectedPath) {
document.getElementById('savePath').value = selectedPath;
}
});

document.getElementById('saveBtn').addEventListener('click', async () => {
const configName = document.getElementById('configName').value;
const appid = document.getElementById('appid').value;
const configPath = document.getElementById('configPath').value;
const savePath = document.getElementById('savePath').value;
const executable = document.getElementById('executablePath').value;
const arguments = document.getElementById('exeArgs').value;		 
const processName = document.getElementById('processName').value;

if (!configName || !appid || !configPath || !savePath) {
const notif = document.createElement('div');
notif.textContent = 'All fields are mandatory!';
notif.style.position = 'fixed';
notif.style.top = '100px';
notif.style.left = '50%';
notif.style.transform = 'translateX(-50%)';
notif.style.backgroundColor = '#f44336';
notif.style.color = 'white';
notif.style.padding = '10px 20px';
notif.style.borderRadius = '5px';
notif.style.boxShadow = '0px 2px 8px rgba(0,0,0,0.3)';
notif.style.zIndex = 9999;
notif.style.fontWeight = 'bold';
notif.style.fontFamily = 'sans-serif';

document.body.appendChild(notif);
setTimeout(() => notif.remove(), 3000);
return;
}

const config = {
name: configName,
appid: appid,
config_path: configPath,
save_path: savePath,
executable: executable || null,
arguments: arguments || '',
process_name: processName || ''
};

const result = editingConfigName && editingConfigName !== configName
? await window.api.renameAndSaveConfig(editingConfigName, config)
: await window.api.saveConfig(config);

showNotification(result.message, result.success ? '#4CAF50' : '#f44336');

if (result.success) {
editingConfigName = null;
document.getElementById('createNewConfigBtn').innerText = 'Create New Config';
localStorage.setItem('configSavedMessage', result.message);
localStorage.setItem('configSavedSuccess', result.success ? 'true' : 'false');

window.location.reload();
}

});


document.getElementById("toggleBtn").addEventListener("click", function () {
let container = document.getElementById("buttonContainer");
if (container.classList.contains("hidden")) {
container.classList.remove("hidden");
  container.style.display = "flex";
this.textContent = "Hide Options";
} else {
container.classList.add("hidden");
  container.style.display = "none";
this.textContent = "Show Options";
}
});

document.getElementById('selectExecutable').addEventListener('click', async () => {
const selectedExe = await window.api.selectExecutable();
if (selectedExe) {
document.getElementById('executablePath').value = selectedExe;
}
});

document.getElementById('playBtn').addEventListener('click', async () => {
const config = await window.api.getConfigByName(configList.value);
if (config && config.executable) {
const args = config.arguments || '';
await window.api.launchExecutable(config.executable, args);
}
});




document.getElementById('languageSelect').addEventListener('change', async (e) => {
const selectedLang = e.target.value;

await window.api.savePreferences({ language: selectedLang });

const configName = document.getElementById('configList').value;
window.api.refreshUILanguage({ language: selectedLang, configName });

  if (configName) {
    await buildMainAchievementsTable(configName, selectedLang);
  }

localStorage.setItem('preferredLanguage', selectedLang);
});

const savedLang = localStorage.getItem('preferredLanguage') || 'english';
document.getElementById('languageSelect').value = savedLang;
function getLocalizedText(obj, lang = 'english') {
if (!obj) return '';
if (typeof obj === 'string') return obj;
return obj[lang] || obj['english'] || '';
}


const presetDropdown = document.getElementById('presetDropdown');
const positionDropdown = document.getElementById('positionDropdown');
const configList = document.getElementById('configList');

function updateMainConfig() {
const selectedConfig = configList.value;
const preset = presetDropdown.value;
const position = positionDropdown.value;

if (selectedConfig) {
window.api.updateConfig({
configName: selectedConfig,
preset: preset,
position: position
});
}
}


presetDropdown.addEventListener('change', updateMainConfig);

positionDropdown.addEventListener('change', updateMainConfig);

configList.addEventListener('change', updateMainConfig);

function getSafeLocalizedText(input, lang = 'english') {
if (!input) return 'Hidden';
if (typeof input === 'string') return input.trim() || 'Hidden';
if (typeof input === 'object') {
return input[lang] || input.english || 
Object.values(input).find(v => typeof v === 'string' && v.trim() !== '') || 
'Hidden';
}
return 'Hidden';
}

window.addEventListener('DOMContentLoaded', async () => {
const configs = await window.api.loadConfigs();
const configList = document.getElementById('configList');
configs.forEach(config => {
const option = document.createElement('option');
option.value = config;
option.textContent = config;
configList.appendChild(option);
});

function formatTimestamp(timestamp) {
if (!timestamp) return "N/A";
const date = new Date(timestamp * 1000);
return date.toLocaleString();
}

configList.addEventListener('change', async () => {
const selectedConfig = configList.value;

if (selectedConfig) {
window.api.updateConfig({
configName: selectedConfig,
preset: presetDropdown.value,
position: positionDropdown.value
});
}



const achievementsDataObj = await window.api.loadAchievementData(selectedConfig);
const savedAchievementsObj = await window.api.loadSavedAchievements(selectedConfig);
const currentConfig = await window.api.getConfigByName(selectedConfig);
if (currentConfig && currentConfig.appid) {
}
if (currentConfig?.appid) {
  await window.__applyEmbeddedGameImageForAppId(currentConfig.appid);
} else {
  window.__showFallbackLogo?.();
}
const playBtn = document.getElementById('playBtn');
playBtn.style.display = currentConfig?.executable ? 'inline-block' : 'none';

const tableBody = document.querySelector('#achievementsTableBody');
if (tableBody) {
tableBody.innerHTML = '';
} else {
console.error('tableBody could not be found.');
return;
}

if (achievementsDataObj.error) {
alert(achievementsDataObj.error);
return;
}

if (!Array.isArray(achievementsDataObj.achievements)) {
console.error('Data syntax incorrect');
return;
}

const lang = document.getElementById('languageSelect').value;
await buildMainAchievementsTable(selectedConfig, lang);


updateAchievementStats(achievementsDataObj.achievements.map(a => {
const saved = savedAchievementsObj?.achievements?.[a.name];
return {
...a,
earned: saved?.earned || false
};
document.getElementById('achStats').style.display = 'block';

}));
});
});

window.addEventListener('DOMContentLoaded', async () => {
try {
const presetsData = await window.api.loadPresets();
const presetDropdown = document.getElementById('presetDropdown');
presetDropdown.innerHTML = '';

// Create category for presets that support scaling above 100%
const highScalingGroup = document.createElement('optgroup');
highScalingGroup.label = "‚≠ê Supports 200% Scaling";

// Create category for regular presets
const regularGroup = document.createElement('optgroup');
regularGroup.label = "Standard Presets (100% Max)";

// Check if we have the new structured format or old format
if (presetsData.isStructured) {
  // Handle new structured format with separate folders
  
  // Add scalable presets
  presetsData.scalable.forEach(preset => {
    const option = document.createElement('option');
    option.value = preset;
    option.textContent = preset;
    highScalingGroup.appendChild(option);
  });
  
  // Add non-scalable presets
  presetsData.nonScalable.forEach(preset => {
    const option = document.createElement('option');
    option.value = preset;
    option.textContent = preset;
    regularGroup.appendChild(option);
  });
} else {
  // Handle old format for backwards compatibility
  presetsData.forEach(preset => {
    const option = document.createElement('option');
    option.value = preset;
    option.textContent = preset;
    
    // Add presets to their appropriate groups using the old logic
    if (preset === 'Modern' || preset === 'xqjan' || preset === 'Neon Future') {
      highScalingGroup.appendChild(option);
    } else {
      regularGroup.appendChild(option);
    }
  });
}

// Add groups to dropdown with enhanced scaling options first
presetDropdown.appendChild(highScalingGroup);
presetDropdown.appendChild(regularGroup);

} catch (error) {
console.error('Error loading presets:', error);
}
});


document.addEventListener('DOMContentLoaded', function () {
const testButton = document.getElementById('testAchievementBtn');
const configList = document.getElementById('configList');
const presetDropdown = document.getElementById('presetDropdown');
const positionDropdown = document.getElementById('positionDropdown');

let position = positionDropdown.value;

positionDropdown.addEventListener('change', function() {
position = positionDropdown.value;
});

testButton.addEventListener('click', async function() {
  const preset = presetDropdown.value || 'default';
  const position = positionDropdown.value;
  const sound = document.getElementById('soundSelect').value;
  const scale = parseFloat(document.getElementById('scaleSlider').value);
  
  window.api.showTestNotification({
    preset,
    position,
    sound,
    scale
  });
});

});
document.addEventListener('DOMContentLoaded', async function () {
async function loadConfigs() {
try {
const configs = await window.api.loadConfigs();
const configList = document.getElementById('configList');
configList.innerHTML = '<option value="" disabled selected>Select</option>';
configs.forEach(config => {
const option = document.createElement('option');
option.value = config;
option.textContent = config;
configList.appendChild(option);
});
} catch (error) {
console.error('Config Load Error:', error);
}
}
configList.addEventListener('change', function () {
deleteConfigBtn.style.display = configList.value ? 'inline-block' : 'none';
});

deleteConfigBtn.addEventListener('click', async function () {
const selectedConfig = configList.value;
if (!selectedConfig) return;

const confirmDelete = confirm(`Do you want to delete: ${selectedConfig}?`);
if (!confirmDelete) return;

try {
const response = await window.api.deleteConfig(selectedConfig);
if (response.success) {
await loadConfigs();
const configList = document.getElementById('configList');
configList.value = '';
document.getElementById('backButton').style.display = 'none';

const selectOption = configList.querySelector('option[value=""]');
if (selectOption) {
selectOption.selected = true;
selectOption.disabled = true;
}

document.getElementById('deleteConfigBtn').style.display = 'none';
document.getElementById('editConfigBtn').style.display = 'none';
document.getElementById('playBtn').style.display = 'none';
resetConfigForm();

const tableBody = document.getElementById('achievementsTableBody');
if (tableBody) tableBody.innerHTML = '';

window.api.updateConfig({ configName: null, preset: null, position: null });
window.api.toggleOverlay(null);
window.api.onLoadOverlayData(null);
window.__showFallbackLogo?.();
} else {
console.error('Error on delete:', response.error);
}
} catch (error) {
console.error('Error on delete:', error);
}
});
});


window.api.onAchievementsMissing((configName) => {
showNotification(`‚ö†Ô∏è achievements.json not found in config: ${configName} config path` , '#f44336');
});

backButton.addEventListener('click', () => {
configList.value = '';
backButton.classList.add('hidden');
deleteConfigBtn.style.display = 'none';
document.getElementById('achStats').style.display = 'none';
window.__showFallbackLogo?.();
});

document.getElementById('backButton').addEventListener('click', () => {
const configList = document.getElementById('configList');
configList.value = '';
document.getElementById('backButton').style.display = 'none';

const selectOption = configList.querySelector('option[value=""]');
if (selectOption) {
selectOption.selected = true;
selectOption.disabled = true;
}

document.getElementById('deleteConfigBtn').style.display = 'none';
document.getElementById('editConfigBtn').style.display = 'none';
document.getElementById('playBtn').style.display = 'none';
resetConfigForm();

const tableBody = document.getElementById('achievementsTableBody');
if (tableBody) tableBody.innerHTML = '';

window.api.updateConfig({ configName: null, preset: null, position: null });
window.api.toggleOverlay(null);
window.api.onLoadOverlayData(null);
});

window.api.onToggleOverlayShortcut(() => {
  const selectedConfig = document.getElementById('configList').value;
  if (!selectedConfig) {
    alert('Select a config!');
    return;
  }
  window.api.toggleOverlay(selectedConfig);
});


configList.addEventListener('change', () => {
if (configList.value) {
backButton.classList.remove('hidden');
backButton.style.display = 'inline-block';
deleteConfigBtn.style.display = 'inline-block';
editConfigBtn.style.display = 'inline-block';
resetConfigForm();
}
});
window.onload = async () => {
const soundSelect = document.getElementById('soundSelect');

try {
const sounds = await window.api.getSounds();
const muteOption = document.createElement('option');
muteOption.value = 'mute';
muteOption.textContent = 'üîá Mute';
soundSelect.appendChild(muteOption);
sounds.forEach(sound => {
const option = document.createElement('option');
option.value = sound;
option.textContent = sound;
soundSelect.appendChild(option);
});
const prefs = await window.api.loadPreferences();
if (prefs && prefs.sound && soundSelect.querySelector(`option[value="${prefs.sound}"]`)) {
soundSelect.value = prefs.sound;
}
if (prefs.disableProgress !== undefined) {
  document.getElementById('disableProgressCheckbox').checked = prefs.disableProgress;
}
if (prefs.disablePlaytime !== undefined) {
  const cb = document.getElementById('settings-disablePlaytimeCheckbox');
  if (cb) cb.checked = !!prefs.disablePlaytime;
}
} catch (err) {
console.error("Sound Load Error:", err);
}
};


window.api.onPlaySound(async (soundName) => {
if (soundName && soundName !== 'mute') {
await playCustomSound(soundName);
}
});


function playSelectedSound() {
const soundSelect = document.getElementById('soundSelect');
const selectedSound = soundSelect?.value;

if (!selectedSound || selectedSound === 'mute') return;

const audio = new Audio(`sounds/${selectedSound}`);
audio.play().catch(err => {
console.error("‚ö†Ô∏è Sound play error:", err);
});
}

async function playCustomSound(fileName) {
if (!fileName || fileName === 'mute') return;

try {
const fullPath = await window.api.getSoundFullPath(fileName);
const audio = new Audio(fullPath);
audio.play().catch(err => {
console.error("‚ö†Ô∏è Custom sound play error:", err);
});
} catch (err) {
console.error("‚ùå Failed to load sound path:", err);
}
}


async function loadPreferences() {
  const prefs = await window.api.loadPreferences();

  if (prefs.position) document.getElementById('positionDropdown').value = prefs.position;
  if (prefs.preset) document.getElementById('presetDropdown').value = prefs.preset;
  if (prefs.sound) document.getElementById('soundSelect').value = prefs.sound;
  if (prefs.notificationScale) {
    const scaleSlider = document.getElementById('scaleSlider');
    scaleSlider.value = prefs.notificationScale;
    updateScaleLabel();
  }
  if (prefs.disableProgress !== undefined) {
    const cb = document.getElementById('disableProgressCheckbox');
    if (cb) cb.checked = prefs.disableProgress;
  }
  if (prefs.disablePlaytime !== undefined) {
  const cb = document.getElementById('settings-disablePlaytimeCheckbox');
  if (cb) cb.checked = prefs.disablePlaytime;
  }
  
if (prefs.windowZoomFactor) {
  const zoomDropdown = document.getElementById('app-zoom-dropdown');
  if (zoomDropdown) {
    zoomDropdown.value = prefs.windowZoomFactor.toString();
    window.api.setZoom(prefs.windowZoomFactor);
  }
}
if (prefs.overlayShortcut) {
  document.getElementById('overlay-shortcut-btn').textContent = prefs.overlayShortcut;
}
}



window.addEventListener('DOMContentLoaded', async () => {
try {
const prefs = await window.api.loadPreferences();
if (prefs) {
if (prefs.position) document.getElementById('positionDropdown').value = prefs.position;
if (prefs.preset) document.getElementById('presetDropdown').value = prefs.preset;
if (prefs.sound) document.getElementById('soundSelect').value = prefs.sound;
if (prefs.notificationScale) {
const scaleSlider = document.getElementById('scaleSlider');
scaleSlider.value = prefs.notificationScale;
updateScaleLabel();
}
if (prefs.disableProgress !== undefined) {
const cb = document.getElementById('disableProgressCheckbox');
if (cb) cb.checked = prefs.disableProgress;
}

if (prefs.disablePlaytime !== undefined) {
  const cb1 = document.getElementById('settings-disablePlaytimeCheckbox');
  if (cb1) cb1.checked = prefs.disablePlaytime;
}

if (prefs.windowZoomFactor) {
  const zoomDropdown = document.getElementById('app-zoom-dropdown');
  if (zoomDropdown) {
    zoomDropdown.value = prefs.windowZoomFactor.toString();
    window.api.setZoom(prefs.windowZoomFactor);
  }
}
 if (prefs?.overlayShortcut) {
    document.getElementById('overlay-shortcut-btn').textContent = prefs.overlayShortcut;
  } else {
    document.getElementById('overlay-shortcut-btn').textContent = 'Set Shortcut';
  }
  
    const ssInput  = document.getElementById('settings-screenshotFolder');
    const ssButton = document.getElementById('settings-selectScreenshotFolder');
    if (ssInput) {
      ssInput.value = prefs?.screenshotFolder || '';
    }
    if (ssButton) {
      ssButton.addEventListener('click', async () => {
        const dir = await window.api.selectFolder();
        if (dir) {
          ssInput.value = dir;
          await window.api.savePreferences({ screenshotFolder: dir });
          console.log('üìÅ Screenshot folder set to:', dir);
        }
      });
	  }

const dsCb = document.getElementById('settings-disableScreenshotCheckbox');
if (dsCb) {
  dsCb.checked = !!(prefs && prefs.disableAchievementScreenshot);
  dsCb.addEventListener('change', async (e) => {
    await window.api.savePreferences({ disableAchievementScreenshot: e.target.checked });
  });
}


}
} catch (e) {
console.warn('Settings cannot be load:', e);
}
});

window.addEventListener('DOMContentLoaded', async () => {
  const prefs = await window.api.loadPreferences();
  const startInTrayEl = document.getElementById('settings-startInTrayCheckbox');
  if (startInTrayEl) {
    startInTrayEl.checked = !!prefs.startInTray;
    startInTrayEl.addEventListener('change', async (e) => {
      await window.api.savePreferences({ startInTray: e.target.checked });
      console.log(e.target.checked ? 'App will start in tray' : 'App will show on startup');
    });
  }
});

['positionDropdown', 'presetDropdown', 'soundSelect', 'languageSelect', 'scaleSlider', 'disableProgressCheckbox', 'app-zoom-dropdown'].forEach(id => {
  const el = document.getElementById(id);
  if (el) {
    el.addEventListener('change', () => {
      const prefs = {
        position: document.getElementById('positionDropdown')?.value,
        preset: document.getElementById('presetDropdown')?.value,
        sound: document.getElementById('soundSelect')?.value,
        language: document.getElementById('languageSelect')?.value,
        notificationScale: parseFloat(document.getElementById('scaleSlider')?.value || 1),
        disableProgress: document.getElementById('disableProgressCheckbox')?.checked,
        windowZoomFactor: parseFloat(document.getElementById('app-zoom-dropdown')?.value || 1)
      };
      window.api.savePreferences(prefs);
      window.api.setZoom(prefs.windowZoomFactor); // set zoom live
    });
  }
});



window.addEventListener('DOMContentLoaded', () => {
const savedMessage = localStorage.getItem('configSavedMessage');
const success = localStorage.getItem('configSavedSuccess') === 'true';

if (savedMessage) {
showNotification(savedMessage, success ? '#4CAF50' : '#f44336');
localStorage.removeItem('configSavedMessage');
localStorage.removeItem('configSavedSuccess');
}
});


function updateAchievementStats(achievements) {
const total = achievements.length;
const unlocked = achievements.filter(a => a.earned === true || a.earned === 1).length;

const label = document.getElementById('achStatsText');
const bar = document.getElementById('achStatsBar');
const percentLabel = document.getElementById('achStatsPercent');

const percentage = total > 0 ? Math.round((unlocked / total) * 100) : 0;

if (label && bar && percentLabel) {
label.textContent = `Progress: ${unlocked} / ${total}`;
bar.style.width = `${percentage}%`;
percentLabel.textContent = `${percentage}%`;
document.getElementById('achStats').style.display = 'block';
}
}

window.api.on('auto-select-config', (configName) => {
const configList = document.getElementById('configList');
if (configList) {
configList.value = configName;
configList.dispatchEvent(new Event('change'));
}
});

async function reloadConfigsDropdown() {
  const configs = await window.api.loadConfigs();
  const dropdown = document.getElementById('configList');
  if (!dropdown) {
    console.error('‚ö†Ô∏è configList element not found.');
    return;
  }

  const selectedBefore = dropdown.value;

  dropdown.innerHTML = '';

  const defaultOption = document.createElement('option');
  defaultOption.value = '';
  defaultOption.textContent = 'Select';
  defaultOption.disabled = true;
  defaultOption.selected = true;
  dropdown.appendChild(defaultOption);

  configs.forEach(config => {
    const option = document.createElement('option');
    option.value = config;
    option.textContent = config;
    dropdown.appendChild(option);
  });

  if (selectedBefore && configs.includes(selectedBefore)) {
    dropdown.value = selectedBefore;
    dropdown.querySelector('option[value=""]').selected = false;
  }
}


document.getElementById('generateConfigsBtn').addEventListener('click', async () => {
  const selectedFolder = await window.api.selectFolder();
  if (!selectedFolder) {
    alert('Canceled: You must select a save path folder to continue!');
    return;
  }

  const result = await window.autoConfigApi.generateConfigs(selectedFolder);
  if (result.success) {
    console.log('Configs generated successfully!');
	await reloadConfigsDropdown();
  } else {
    console.error('Failed to generate configs: ' + result.message);
  }
});

// Window control buttons
document.getElementById('minimizeBtn').addEventListener('click', () => {
  window.customApi.minimizeWindow();
});

document.getElementById('maximizeBtn').addEventListener('click', () => {
  window.customApi.maximizeWindow();
});

document.getElementById('closeBtn').addEventListener('click', () => {
  window.customApi.closeWindow();
});

// Update maximize button icon when window state changes
window.electron.ipcRenderer.on('window-state-change', (isMaximized) => {
  const maximizeBtn = document.getElementById('maximizeBtn');
  if (isMaximized) {
    maximizeBtn.innerHTML = '<i class="far fa-clone"></i>';
  } else {
    maximizeBtn.innerHTML = '<i class="far fa-square"></i>';
  }
});

// Add visual feedback when clicking buttons
const buttons = document.querySelectorAll('.titlebar-button');
buttons.forEach(button => {
  button.addEventListener('mousedown', () => {
    button.style.backgroundColor = 'rgba(255, 255, 255, 0.2)';
  });
  button.addEventListener('mouseup', () => {
    button.style.backgroundColor = '';
  });
  button.addEventListener('mouseleave', () => {
    button.style.backgroundColor = '';
  });
});

// Settings Menu Functionality
document.getElementById('settingsBtn').addEventListener('click', (event) => {
  event.stopPropagation();
  const settingsMenu = document.getElementById('settingsMenu');
  settingsMenu.classList.remove('hidden');
  
  // Sync settings values from main UI to settings menu
  syncSettingsToModal();
  
  // Set focus to the settings menu for keyboard accessibility
  setTimeout(() => {
    document.querySelector('.settings-content').focus();
  }, 10);
});

// Close settings menu with close button
document.getElementById('closeSettingsBtn').addEventListener('click', () => {
  const settingsMenu = document.getElementById('settingsMenu');
  settingsMenu.classList.add('hidden');
  syncSettingsFromModal();
});

// Click outside to close settings menu
document.getElementById('settingsMenu').addEventListener('click', (event) => {
  const settingsContent = document.querySelector('.settings-content');
  if (!settingsContent.contains(event.target)) {
    document.getElementById('settingsMenu').classList.add('hidden');
    syncSettingsFromModal();
  }
});

// Close settings menu with Escape key
document.addEventListener('keydown', (event) => {
  if (event.key === 'Escape') {
    const settingsMenu = document.getElementById('settingsMenu');
    if (!settingsMenu.classList.contains('hidden')) {
      settingsMenu.classList.add('hidden');
      syncSettingsFromModal();
    }
  }
});

// Tab switching
document.querySelectorAll('.settings-tab').forEach(tab => {
  tab.addEventListener('click', () => {
    // Remove active class from all tabs
    document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(c => c.classList.remove('active'));
    
    // Add active class to clicked tab and corresponding content
    tab.classList.add('active');
    const tabId = tab.getAttribute('data-tab');
    document.getElementById(tabId + 'Tab').classList.add('active');
  });
});

// Achievement test button in settings
document.getElementById('settings-testAchievementBtn').addEventListener('click', function() {
  const preset = document.getElementById('settings-presetDropdown').value || 'default';
  const position = document.getElementById('settings-positionDropdown').value;
  const sound = document.getElementById('settings-soundSelect').value;
  const scale = parseFloat(document.getElementById('settings-scaleSlider').value);
  
  window.api.showTestNotification({
    preset,
    position,
    sound,
    scale
  });
});

// Settings scale slider
const settingsScaleSlider = document.getElementById('settings-scaleSlider');
const settingsScaleValue = document.getElementById('settings-scaleValue');
const settingsScaleValueDisplay = document.getElementById('settings-scaleValueDisplay');

function updateSettingsScaleLabel() {
  const value = parseFloat(settingsScaleSlider.value);
  const percentage = Math.round(value * 100);
  settingsScaleValue.textContent = value.toFixed(2);
  settingsScaleValueDisplay.textContent = `${percentage}%`;
  settingsScaleSlider.style.background = `linear-gradient(to right, var(--dracula-cyan) 0%, var(--dracula-cyan) ${percentage}%, #ccc ${percentage}%, #ccc 100%)`;
}

settingsScaleSlider.addEventListener('input', () => {
  updateSettingsScaleLabel();
  window.api.savePreferences({ notificationScale: settingsScaleSlider.value });
});

// Save Settings without config
document.getElementById('settings-disableProgressCheckbox').addEventListener('change', async (e) => {
  const isChecked = e.target.checked;
  window.api.disableProgress(isChecked);
  await window.api.savePreferences({ disableProgress: isChecked });
});

document.getElementById('settings-disablePlaytimeCheckbox').addEventListener('change', async (e) => {
  const on = e.target.checked;
  window.api.setDisablePlaytime(on);
  await window.api.savePreferences({ disablePlaytime: on });
});

document.getElementById('settings-positionDropdown')
  .addEventListener('change', e => window.api.savePreferences({ position: e.target.value }));

document.getElementById('settings-presetDropdown')
  .addEventListener('change', e => window.api.savePreferences({ preset: e.target.value }));

document.getElementById('settings-soundSelect')
  .addEventListener('change', e => {
    window.api.savePreferences({ sound: e.target.value });
  });
  
// Function to sync values between main UI and settings menu
function syncSettingsToModal() {
  // Copy preset options
  const mainPresetDropdown = document.getElementById('presetDropdown');
  const settingsPresetDropdown = document.getElementById('settings-presetDropdown');
  
  if (mainPresetDropdown && settingsPresetDropdown) {
    settingsPresetDropdown.innerHTML = mainPresetDropdown.innerHTML;
    if (mainPresetDropdown.value) {
      settingsPresetDropdown.value = mainPresetDropdown.value;
    }
  }
  
  // Copy sound options
  const mainSoundSelect = document.getElementById('soundSelect');
  const settingsSoundSelect = document.getElementById('settings-soundSelect');
  
  if (mainSoundSelect && settingsSoundSelect) {
    settingsSoundSelect.innerHTML = mainSoundSelect.innerHTML;
    if (mainSoundSelect.value) {
      settingsSoundSelect.value = mainSoundSelect.value;
    }
  }
  
  // Sync position dropdown
  const mainPositionDropdown = document.getElementById('positionDropdown');
  const settingsPositionDropdown = document.getElementById('settings-positionDropdown');
  
  if (mainPositionDropdown && settingsPositionDropdown) {
    settingsPositionDropdown.value = mainPositionDropdown.value;
  }
  
  // Sync scale slider
  const mainScaleSlider = document.getElementById('scaleSlider');
  const settingsScaleSlider = document.getElementById('settings-scaleSlider');
  
  if (mainScaleSlider && settingsScaleSlider) {
    settingsScaleSlider.value = mainScaleSlider.value;
    updateSettingsScaleLabel();
  }
  
  // Sync disable progress checkbox
  const mainDisableProgressCheckbox = document.getElementById('disableProgressCheckbox');
  const settingsDisableProgressCheckbox = document.getElementById('settings-disableProgressCheckbox');
  
  if (mainDisableProgressCheckbox && settingsDisableProgressCheckbox) {
    settingsDisableProgressCheckbox.checked = mainDisableProgressCheckbox.checked;
  }
}

function syncSettingsFromModal() {
  // Copy values from settings menu to main UI
  const mainPresetDropdown = document.getElementById('presetDropdown');
  const settingsPresetDropdown = document.getElementById('settings-presetDropdown');
  
  if (mainPresetDropdown && settingsPresetDropdown && settingsPresetDropdown.value) {
    mainPresetDropdown.value = settingsPresetDropdown.value;
  }
  
  // Copy sound options
  const mainSoundSelect = document.getElementById('soundSelect');
  const settingsSoundSelect = document.getElementById('settings-soundSelect');
  
  if (mainSoundSelect && settingsSoundSelect && settingsSoundSelect.value) {
    mainSoundSelect.value = settingsSoundSelect.value;
  }
  
  // Sync position dropdown
  const mainPositionDropdown = document.getElementById('positionDropdown');
  const settingsPositionDropdown = document.getElementById('settings-positionDropdown');
  
  if (mainPositionDropdown && settingsPositionDropdown) {
    mainPositionDropdown.value = settingsPositionDropdown.value;
  }
  
  // Sync scale slider
  const mainScaleSlider = document.getElementById('scaleSlider');
  const settingsScaleSlider = document.getElementById('settings-scaleSlider');
  
  if (mainScaleSlider && settingsScaleSlider) {
    mainScaleSlider.value = settingsScaleSlider.value;
    const event = new Event('input');
    mainScaleSlider.dispatchEvent(event);
  }
  
  // Sync disable progress checkbox
  const mainDisableProgressCheckbox = document.getElementById('disableProgressCheckbox');
  const settingsDisableProgressCheckbox = document.getElementById('settings-disableProgressCheckbox');
  
  if (mainDisableProgressCheckbox && settingsDisableProgressCheckbox) {
    mainDisableProgressCheckbox.checked = settingsDisableProgressCheckbox.checked;
  }
    ['presetDropdown','positionDropdown','soundSelect'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.dispatchEvent(new Event('change')); // savePreferences()
  });
}

// Zoom level control
document.getElementById('app-zoom-dropdown').addEventListener('change', (e) => {
  const zoomValue = parseFloat(e.target.value);
  window.api.setZoom(zoomValue);
  window.api.savePreferences({ windowZoomFactor: zoomValue });
});

// Overlay shortcut functionality
const overlayShortcutBtn = document.getElementById('overlay-shortcut-btn');
let isListeningForShortcut = false;
let pressedKeys = new Set();
let shortcutTimeout;
let currentKeyHandler = null;

overlayShortcutBtn.addEventListener('click', () => {
  if (overlayShortcutBtn.textContent === 'Press keys...' || overlayShortcutBtn.classList.contains('listening')) {
    cleanupShortcutRecording();
    restoreSavedShortcutLabel();
    return;
  }

  overlayShortcutBtn.textContent = 'Press keys...';
  overlayShortcutBtn.classList.add('listening');
  isListeningForShortcut = true;
  pressedKeys.clear();

  const handleKeyDown = (e) => {
    if (!isListeningForShortcut) return;

    e.preventDefault();
    pressedKeys.add(e.key);

    clearTimeout(shortcutTimeout);
    shortcutTimeout = setTimeout(() => {
      if (!isListeningForShortcut) return;

      const keys = [];

      if (pressedKeys.has('Control')) keys.push('Control');
      if (pressedKeys.has('Shift')) keys.push('Shift');
      if (pressedKeys.has('Alt')) keys.push('Alt');

      const mainKeys = [...pressedKeys].filter(k => !['Control', 'Shift', 'Alt', 'Meta'].includes(k));
      if (mainKeys.length > 0) {
        const mainKey = mainKeys[0];
        keys.push(mainKey.length === 1 ? mainKey.toUpperCase() : mainKey);
      }

      if (keys.length < 2) {
        overlayShortcutBtn.textContent = 'Invalid combo';
        setTimeout(() => restoreSavedShortcutLabel(), 1200);
      } else {
        const combo = keys.join('+');
        overlayShortcutBtn.textContent = combo;
        window.api.savePreferences({ overlayShortcut: combo });
        window.api.updateOverlayShortcut?.(combo);
      }

      cleanupShortcutRecording();
    }, 400);
  };

  currentKeyHandler = handleKeyDown;
  document.addEventListener('keydown', handleKeyDown);
});

function cleanupShortcutRecording() {
  isListeningForShortcut = false;
  pressedKeys.clear();
  clearTimeout(shortcutTimeout);
  overlayShortcutBtn.classList.remove('listening');
  
  if (currentKeyHandler) {
    document.removeEventListener('keydown', currentKeyHandler);
    currentKeyHandler = null;
  }
}

async function restoreSavedShortcutLabel() {
  const prefs = await window.api.loadPreferences();
  overlayShortcutBtn.textContent = prefs?.overlayShortcut || 'Set Shortcut';
}

document.addEventListener('mousedown', (event) => {
  if (isListeningForShortcut && event.target !== overlayShortcutBtn) {
    cleanupShortcutRecording();
    restoreSavedShortcutLabel();
  }
});
</script>
</body>
</html>
