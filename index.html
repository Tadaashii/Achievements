<!-- index.html -->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />

    <title>Achievements</title>
    <style>
      html,
      body {
        user-select: none;
        overflow-y: auto;
        overflow-x: hidden;
        height: 100vh;
      }

      body::-webkit-scrollbar {
        display: none;
      }

      button,
      input,
      textarea,
      select {
        -webkit-app-region: no-drag;
      }

      table {
        width: 90%;
        border-collapse: collapse;
      }

      table,
      th,
      td {
        margin-top: 20px;
        border: 1px solid black;
      }

      .displayName {
        padding-left: 15px;
      }

      .description {
        padding-left: 25px;
      }

      .image {
        padding-top: 5px;
        text-align: center;
      }

      img {
        width: 100px;
        height: auto;
        align-self: center;
      }

      #config-list {
        margin-top: 10px;
        margin-bottom: 20px;
      }

      button {
        margin-top: 10px;
        margin-bottom: 20px;
      }

      label {
        margin-top: 10px;
        margin-bottom: 20px;
      }

      .status {
        text-align: center;
        vertical-align: middle;
        font-size: 14px;
      }

      .locked {
        color: red;
        font-weight: bold;
      }

      .unlocked {
        color: green;
        font-weight: bold;
      }

      .progress-bar {
        height: 5px;
        background-color: #44475a;
        border-radius: 3px;
        overflow: hidden;
        margin-top: 4px;
        width: 50%;
      }

      .progress-fill {
        height: 100%;
        background-color: #50fa7b;
        border-radius: 3px;
        transition: width 0.3s ease;
      }

      .achievement-progress {
        font-size: 0.85em;
        color: #888;
      }

      .sort-btn {
        position: relative;
        top: 2px;
        right: 5px;
        display: inline-flex;
        align-items: center;
        gap: 4px;
        padding: 4px 8px;
        border: 1px solid var(--dracula-purple, #6272a4);
        background: transparent;
        color: var(--dracula-purple, #bd93f9);
        border-radius: 8px;
        cursor: pointer;
        transition: background 0.15s, color 0.15s, border-color 0.15s;
      }

      .sort-btn .dir {
        font-weight: 400;
        font-size: 12px;
        opacity: 0.9;
      }

      .sort-btn.active {
        background: rgba(189, 147, 249, 0.15);
        color: white;
        border-color: var(--dracula-cyan, #8be9fd);
      }

      .sort-btn:focus {
        outline: none;
        box-shadow: 0 0 0 2px rgba(139, 233, 253, 0.35);
      }
    </style>
  </head>

  <body>
    <!-- Modern Titlebar -->
    <div id="titlebar" class="titlebar">
      <div class="titlebar-logo">
        <img id="appIcon" alt="App Icon" />
        <span class="titlebar-title">Achievements</span>
      </div>
      <div class="titlebar-controls">
        <button id="settingsBtn" class="titlebar-button">
          <i class="fas fa-cog"></i>
        </button>
        <button id="minimizeBtn" class="titlebar-button">
          <i class="fas fa-minus"></i>
        </button>
        <button id="maximizeBtn" class="titlebar-button">
          <i class="far fa-square"></i>
        </button>
        <button id="closeBtn" class="titlebar-button close">
          <i class="fas fa-times"></i>
        </button>
      </div>
    </div>

    <!-- Settings Menu Panel -->
    <div id="settingsMenu" class="settings-menu hidden">
      <div
        class="settings-content"
        role="dialog"
        aria-modal="true"
        tabindex="-1"
      >
        <button class="settings-close-button" id="closeSettingsBtn">
          &times;
        </button>

        <div class="settings-tabs" role="tablist" aria-label="Settings tabs">
          <h3 style="margin: 0 0 15px 10px; color: var(--dracula-purple)">
            Settings
          </h3>
          <button
            id="tab-general"
            class="settings-tab active"
            data-tab="general"
          >
            General
          </button>
          <button
            id="tab-notification"
            class="settings-tab"
            data-tab="notification"
          >
            Notification
          </button>
          <button id="tab-folders" class="settings-tab" data-tab="folders">
            Folders
          </button>
          <button id="tab-advanced" class="settings-tab" data-tab="advanced">
            Advanced
          </button>
          <button
            id="tab-shortcuts"
            class="settings-tab"
            data-tab="shortcuts"
            title="Keyboard & Controller Shortcuts"
          >
            Shortcuts
          </button>
        </div>

        <div class="settings-tabs-content" tabindex="0">
          <div
            id="generalTab"
            class="tab-content active"
            role="tabpanel"
            aria-labelledby="tab-general"
          >
            <div style="padding: 0 5px">
              <div class="settings-section">
                <h4>App Scale</h4>
                <div class="settings-control">
                  <label for="app-zoom-dropdown">Zoom Level:</label>
                  <select id="app-zoom-dropdown">
                    <option value="0.75">75%</option>
                    <option value="1" selected>100%</option>
                    <option value="1.25">125%</option>
                    <option value="1.5">150%</option>
                    <option value="2">200%</option>
                  </select>
                </div>
              </div>
              <div class="settings-section" style="margin-bottom: 5px">
                <h4>Overlay Shortcut</h4>
                <div class="settings-control">
                  <label for="overlay-shortcut-btn">Shortcut Key:</label>
                  <button id="overlay-shortcut-btn" type="button">
                    Set Shortcut
                  </button>
                </div>
              </div>
              <div class="settings-section">
                <h4>Hidden Achievements</h4>
                <div class="checkbox-control">
                  <input type="checkbox" id="settings-showHiddenDescription" />
                  <label for="settings-showHiddenDescription">
                    Show Hidden Description
                  </label>
                </div>
              </div>
              <div class="settings-section">
                <h4>Startup</h4>
                <div class="checkbox-control">
                  <input type="checkbox" id="settings-startWindowsCheckbox" />
                  <label for="settings-startWindowsCheckbox"
                    >Start with Windows (Run as admin to enable)</label
                  >
                </div>
                <div class="checkbox-control">
                  <input type="checkbox" id="settings-startMaximizedCheckbox" />
                  <label for="settings-startMaximizedCheckbox"
                    >Start maximized</label
                  >
                </div>
                <div class="checkbox-control">
                  <input type="checkbox" id="settings-startInTrayCheckbox" />
                  <label for="settings-startInTrayCheckbox"
                    >Start in tray</label
                  >
                </div>
                <div class="checkbox-control">
                  <input
                    type="checkbox"
                    id="settings-showDashboardOnStartCheckbox"
                  />
                  <label for="settings-showDashboardOnStartCheckbox"
                    >Show Dashboard</label
                  >
                </div>
              </div>
              <div class="settings-section" style="margin-bottom: 5px">
                <h4>Achievements Screenshots</h4>
                <div class="settings-control">
                  <div class="input-with-button">
                    <label for="settings-screenshotFolder"
                      >Save to folder:</label
                    >
                    <input
                      type="text"
                      id="settings-screenshotFolder"
                      placeholder="Default folder: Pictures\Achievements Screenshots"
                      readonly
                    />
                    <button
                      type="button"
                      id="settings-selectScreenshotFolder"
                      aria-label="Choose folder"
                    >
                      üìÇ
                    </button>
                  </div>
                </div>
                <div
                  class="checkbox-control"
                  style="margin-top: -10px; margin-bottom: 5px"
                >
                  <input
                    type="checkbox"
                    id="settings-disableScreenshotCheckbox"
                  />
                  <label for="settings-disableScreenshotCheckbox"
                    >Disable Screenshot</label
                  >
                </div>
              </div>
            </div>
          </div>

          <div
            id="notificationTab"
            class="tab-content"
            role="tabpanel"
            aria-labelledby="tab-notification"
            hidden
          >
            <div style="padding: 0 5px">
              <div class="settings-section">
                <h4>Achievement Testing</h4>
                <button
                  id="settings-testAchievementBtn"
                  class="settings-test-button"
                  style="width: 100%; margin: 10px 0; padding: 10px"
                >
                  Test Achievement
                </button>

                <div class="checkbox-control">
                  <input
                    type="checkbox"
                    id="settings-disableProgressCheckbox"
                  />
                  <label for="settings-disableProgressCheckbox"
                    >Disable Progress Notification</label
                  >
                </div>

                <div class="checkbox-control">
                  <input
                    type="checkbox"
                    id="settings-disablePlaytimeCheckbox"
                  />
                  <label for="settings-disablePlaytimeCheckbox"
                    >Disable Playtime Notification</label
                  >
                </div>

                <div class="checkbox-control">
                  <input
                    type="checkbox"
                    id="settings-disablePlatinumCheckbox"
                  />
                  <label for="settings-disablePlatinumCheckbox"
                    >Disable Platinum Notification</label
                  >
                </div>

                <div class="settings-slider">
                  <label for="settings-scaleSlider"
                    >Achievement Scale:
                    <span id="settings-scaleValue">1.0</span></label
                  >
                  <div class="slider-control">
                    <input
                      type="range"
                      id="settings-scaleSlider"
                      min="0.01"
                      max="2.0"
                      step="0.01"
                      value="1.0"
                    />
                    <span class="value" id="settings-scaleValueDisplay"
                      >100%</span
                    >
                  </div>
                </div>

                <div class="settings-control">
                  <label for="settings-positionDropdown"
                    >Achievement Position:</label
                  >
                  <select id="settings-positionDropdown">
                    <option value="center-bottom">Center Bottom</option>
                    <option value="center-top">Center Top</option>
                    <option value="top-right">Top Right</option>
                    <option value="bottom-right">Bottom Right</option>
                    <option value="top-left">Top Left</option>
                    <option value="bottom-left">Bottom Left</option>
                  </select>
                </div>

                <div class="settings-control">
                  <label for="settings-presetDropdown"
                    >Achievement Presets:</label
                  >
                  <select id="settings-presetDropdown"></select>
                </div>

                <div class="settings-control">
                  <label for="settings-soundSelect">Achievement Sound:</label>
                  <select id="settings-soundSelect"></select>
                </div>

                <hr />
                <h4 style="margin-top: 10px">Platinum Notification</h4>
                <div class="settings-control">
                  <label for="settings-platinumPositionDropdown"
                    >Platinum Achievement Position:</label
                  >
                  <select id="settings-platinumPositionDropdown">
                    <option value="center-bottom">Center Bottom</option>
                    <option value="center-top">Center Top</option>
                    <option value="top-right">Top Right</option>
                    <option value="bottom-right">Bottom Right</option>
                    <option value="top-left">Top Left</option>
                    <option value="bottom-left">Bottom Left</option>
                  </select>
                </div>

                <div class="settings-control">
                  <label for="settings-platinumPresetDropdown"
                    >Platinum Achievement Presets:</label
                  >
                  <select id="settings-platinumPresetDropdown"></select>
                </div>

                <div class="settings-control">
                  <label for="settings-platinumSoundSelect"
                    >Platinum Achievement Sound:</label
                  >
                  <select id="settings-platinumSoundSelect"></select>
                </div>
              </div>
            </div>
          </div>
          <div
            id="foldersTab"
            class="tab-content"
            role="tabpanel"
            aria-labelledby="tab-folders"
            hidden
          >
            <div style="padding: 0 5px">
              <div class="settings-section">
                <h4>Folders (auto-detect achievements)</h4>
                <div
                  class="settings-control"
                  style="display: flex; gap: 8px; flex-wrap: wrap"
                >
                  <button id="foldersAddBtn" type="button">Add Folder‚Ä¶</button>
                  <button id="foldersRescanBtn" type="button">Rescan</button>
                </div>
                <div id="foldersList" style="margin-top: 2px"></div>
              </div>
            </div>
          </div>
          <div
            id="advancedTab"
            class="tab-content"
            role="tabpanel"
            aria-labelledby="tab-advanced"
            hidden
          >
            <div style="padding: 0 5px">
              <div class="settings-section">
                <div class="settings-section" style="margin-bottom: 5px">
                  <h4>Steam Web API</h4>
                  <div class="settings-control">
                    <input
                      type="password"
                      id="settings-steamApiKeyInput"
                      placeholder="No key saved. Enter your Steam Web API key"
                      autocomplete="off"
                    />
                  </div>
                  <div class="settings-control" style="gap: 8px">
                    <button type="button" id="settings-steamApiKeySave">
                      Save
                    </button>
                    <button type="button" id="settings-steamApiKeyClear">
                      Remove
                    </button>
                  </div>
                </div>
                <div class="settings-section">
                  <h4>Blacklist</h4>
                  <div class="checkbox-control">
                    <input
                      type="checkbox"
                      id="settings-showBlacklistedCheckbox"
                    />
                    <label for="settings-showBlacklistedCheckbox">
                      Show blacklisted games
                    </label>
                  </div>
                  <div
                    id="blacklistList"
                    class="wf-list"
                    role="list"
                    aria-label="Blacklisted AppIDs"
                    style="margin-top: 8px"
                  ></div>
                  <div class="settings-control" style="gap: 8px">
                    <button type="button" id="settings-resetBlacklistBtn">
                      Reset Blacklist
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div
            id="shortcutsTab"
            class="tab-content"
            role="tabpanel"
            aria-labelledby="tab-shortcuts"
            hidden
            data-lazy="shortcuts"
            tabindex="0"
          >
            <template id="shortcutsTabTemplate">
              <div style="padding: 0 5px">
                <!-- Global -->
                <div class="settings-section">
                  <h4>Global</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Settings</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>F1</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>O</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-view">View</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-share">Share</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Dashboard</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>F2</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>D</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-y">Y</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-triangle">‚É§‚É§</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">
                        Show/Hide Options panel (on Main)
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>F3</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-x">X</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-square">‚òê</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Back / Close</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>Esc</kbd></div>
                        <div class="ctl-line sub"><kbd>Backspace</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-b">B</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-circle">‚óØ</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Play (launch)</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>P</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Enter</kbd>
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Shift</kbd>+<kbd>Enter</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-menu">Menu</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-options">Options</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Confirm / Activate</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>Enter</kbd></div>
                        <div class="ctl-line sub"><kbd>Space</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-a">A</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-cross">‚úï</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Page scroll</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>PageUp</kbd></div>
                        <div class="ctl-line sub"><kbd>PageDown</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            ><span class="btn stick">RS</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Move</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">Arrow Keys</div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">D-pad</div>
                        <div class="ctl-line sub">
                          <span class="btn stick">LS</span>
                        </div>
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Dashboard -->
                <div class="settings-section">
                  <h4>Dashboard</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Grid navigation</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">Arrows</div>
                        <div class="ctl-line sub"><kbd>Home</kbd></div>
                        <div class="ctl-line sub"><kbd>End</kbd></div>
                        <div class="ctl-line sub"><kbd>PageUp</kbd></div>
                        <div class="ctl-line sub"><kbd>PageDown</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">D-pad</div>
                        <div class="ctl-line sub">
                          <span class="btn stick">LS</span>
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Search</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>F</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-x">X</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-square">‚òê</span></span
                          >
                        </div>
                      </div>
                      <div class="ctl-line sub">
                        In search:
                        <div class="ctl-line sub">
                          <kbd>Enter</kbd> |
                          <span class="btn ps-cross">‚úï</span> |
                          <span class="btn xb-a">A</span> opens first visible
                          card
                        </div>
                        <div class="ctl-line sub">
                          <kbd>‚Üì</kbd> moves focus to first card
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Esc</kbd> | <span class="btn xb-b">B</span> |
                          <span class="btn ps-circle">‚óØ</span>
                          close Dashboard
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Open game (select card)</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>Enter</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-a">A</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-cross">‚úï</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Play from card</div>
                      <div class="ctl-line">
                        <span class="hint">Mouse:</span>
                        <div class="ctl-line sub">Click Play</div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>P</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Enter</kbd>
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Shift</kbd>+<kbd>Enter</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-menu">Menu</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-options">Options</span></span
                          >
                        </div>
                      </div>
                      <div class="ctl-line sub">
                        <span class="hint">(if executable)</span>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Sort cycles</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          By Name ‚Äî <kbd>Alt</kbd>+<kbd>1</kbd>
                        </div>
                        <div class="ctl-line sub">
                          By Progress ‚Äî <kbd>Alt</kbd>+<kbd>2</kbd>
                        </div>
                        <div class="ctl-line sub">
                          By Last Updated ‚Äî <kbd>Alt</kbd>+<kbd>3</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn stick">L3</span>,
                            <span class="btn shoulder">RB</span>,
                            <span class="btn shoulder">LB</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation: <span class="btn stick">L3</span>,
                            <span class="btn shoulder">R1</span>,
                            <span class="btn shoulder">L1</span></span
                          >
                        </div>
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Settings panel -->
                <div class="settings-section">
                  <h4>Settings panel</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Open/Close</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>F1</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>O</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-view">View</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-share">Share</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Tabs mode</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">‚Üë/‚Üì move</div>
                        <div class="ctl-line sub"><kbd>Enter</kbd> select</div>
                        <div class="ctl-line sub"><kbd>Esc</kbd> close</div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          D-pad / <span class="btn stick">RS</span> move
                        </div>
                        <div class="ctl-line sub">
                          <span class="btn xb-a">A</span>/<span
                            class="btn ps-cross"
                            >‚úï</span
                          >
                          select
                        </div>
                        <div class="ctl-line sub">
                          <span class="btn xb-b">B</span>/<span
                            class="btn ps-circle"
                            >‚óØ</span
                          >
                          close
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Section mode</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">‚Üë/‚Üì focus</div>
                        <div class="ctl-line sub">‚Üê/‚Üí adjust</div>
                        <div class="ctl-line sub">
                          <kbd>Enter</kbd> activate
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Esc</kbd> back to Tabs
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          D-pad / <span class="btn stick">LS</span> focus
                        </div>
                        <div class="ctl-line sub">
                          <span class="btn xb-a">A</span>/<span
                            class="btn ps-cross"
                            >‚úï</span
                          >
                          activate
                        </div>
                        <div class="ctl-line sub">
                          <span class="btn xb-b">B</span>/<span
                            class="btn ps-circle"
                            >‚óØ</span
                          >
                          back
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Cycle tabs</div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            ><span class="btn shoulder">LB</span>/<span
                              class="btn shoulder"
                              >RB</span
                            ></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            ><span class="btn shoulder">L1</span>/<span
                              class="btn shoulder"
                              >R1</span
                            ></span
                          >
                        </div>
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Main screen -->
                <div class="settings-section">
                  <h4>Main screen</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Toggle Options</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>F3</kbd></div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-x">X</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-square">‚òê</span></span
                          >
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Create New Config</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>N</kbd>
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Move</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">‚Üë/‚Üì</div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">D-pad</div>
                        <div class="ctl-line sub">
                          <span class="btn stick">LS</span>
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Play</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>P</kbd></div>
                        <div class="ctl-line sub">
                          <kbd>Ctrl</kbd>+<kbd>Enter</kbd>
                        </div>
                        <div class="ctl-line sub">
                          <kbd>Shift</kbd>+<kbd>Enter</kbd>
                        </div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-xb"
                            >Xbox: <span class="btn xb-menu">Menu</span></span
                          >
                        </div>
                        <div class="ctl-line sub">
                          <span class="ctl ctl-ps"
                            >PlayStation:
                            <span class="btn ps-options">Options</span></span
                          >
                        </div>
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Drop-downs -->
                <div class="settings-section">
                  <h4>Drop-downs</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Open</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub"><kbd>Enter</kbd></div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">While open</div>

                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">‚Üë/‚Üì/‚Üê/‚Üí navigate</div>
                        <div class="ctl-line sub"><kbd>Enter</kbd> confirm</div>
                        <div class="ctl-line sub">
                          <kbd>Esc</kbd>/<kbd>Backspace</kbd> cancel
                        </div>
                      </div>

                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">D-pad navigate</div>
                        <div class="ctl-line sub">
                          <span class="btn xb-a">A</span>/<span
                            class="btn ps-cross"
                            >‚úï</span
                          >
                          confirm
                        </div>
                        <div class="ctl-line sub">
                          <span class="btn xb-b">B</span>/<span
                            class="btn ps-circle"
                            >‚óØ</span
                          >
                          cancel
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">While closed</div>
                      <div class="ctl-line">
                        <span class="hint">Keyboard:</span>
                        <div class="ctl-line sub">‚Üê/‚Üí cycles options</div>
                      </div>
                      <div class="ctl-line">
                        <span class="hint">Controller:</span>
                        <div class="ctl-line sub">D-pad Left/Right</div>
                      </div>
                    </li>
                  </ul>
                </div>

                <!-- Notes -->
                <div class="settings-section">
                  <h4>Notes</h4>
                  <ul class="shortcut-list">
                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Right Stick scrolling</div>
                      <div class="ctl-line">
                        <div class="ctl-line sub">
                          Smooth scrolling in the active scrollable area.
                        </div>
                      </div>
                    </li>

                    <li class="shortcut-item" tabindex="0">
                      <div class="ctl-label">Back is contextual</div>
                      <div class="ctl-line sub">
                        <div class="ctl-line sub">Settings Section ‚Üí Tabs</div>
                        <div class="ctl-line sub">Settings Tabs ‚Üí Close</div>
                        <div class="ctl-line sub">Dashboard ‚Üí Close</div>
                        <div class="ctl-line sub">Config modal ‚Üí Close</div>
                        <div class="ctl-line sub">
                          Main with a selected config ‚Üí Clear selection/back
                        </div>
                      </div>
                    </li>
                  </ul>
                </div>
              </div>
            </template>
          </div>
        </div>
      </div>
    </div>

    <div class="container">
      <!-- Toggle Settings Button -->
      <div
        id="mainControlsRow"
        style="
          margin-bottom: 10px;
          position: relative;
          display: flex;
          align-items: center;
          gap: 10px;
        "
      >
        <div style="display: flex; flex-direction: column; gap: 0px">
          <button id="toggleDashboardBtn" type="button">Show Dashboard</button>
          <button id="toggleBtn">Hide Options</button>
        </div>

        <!-- Progres bar -->
        <div
          id="achStats"
          style="
            display: none;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 320px;
            z-index: 10;
            margin-top: -30px;
          "
        >
          <label id="achStatsText" style="color: white; font-weight: bold"
            >Progress: 0 / 0</label
          >
          <div
            style="
              width: 100%;
              background: #ccc;
              border-radius: 8px;
              height: 12px;
              margin-top: -10px;
              position: relative;
              margin-bottom: 20px;
            "
          >
            <div
              id="achStatsBar"
              style="
                width: 0%;
                height: 100%;
                background: #4caf50;
                border-radius: 8px;
                transition: width 0.3s;
              "
            ></div>
            <span
              id="achStatsPercent"
              style="
                position: absolute;
                right: 5px;
                top: -22px;
                font-size: 12px;
                color: white;
                font-weight: bold;
              "
              >0%</span
            >
            <div
              id="achStatsPlaytime"
              style="
                margin-top: 6px;
                font-size: 12px;
                color: #ffffff;
                font-weight: bold;
              "
            >
              Playtime: 0m
            </div>
          </div>
        </div>

        <button id="playBtn" style="display: none; margin-left: auto">
          <i class="fas fa-play"></i> Play
        </button>
      </div>

      <!-- Toggleable Settings Container -->
      <div
        id="buttonContainer"
        class="config-container"
        style="display: flex; justify-content: space-between; gap: 15px"
      >
        <!-- Left Side: Create Config and Select Config -->
        <div
          class="left-config"
          style="
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 5px;
          "
        >
          <div>
            <div style="display: flex; gap: 20px">
              <button id="createNewConfigBtn" style="flex: 1; padding: 10px">
                Create New Config <span class="arrow-icon">‚ñº</span>
              </button>

              <button id="generateConfigsBtn" style="flex: 1; padding: 10px">
                Generate Auto-Configs
              </button>
            </div>

            <div id="configModal" class="modal hidden">
              <div class="modal-content">
                <span class="close-button" id="closeConfigModal">&times;</span>
                <h2 id="configFormTitle" style="margin-top: 0">Config Form</h2>

                <div
                  id="new-config-form"
                  style="
                    display: flex;
                    flex-direction: column;
                    gap: 14px;
                    margin-top: -10px;
                  "
                >
                  <div style="display: flex; gap: 20px">
                    <!-- Right -->
                    <div style="flex: 1; display: flex; flex-direction: column">
                      <label for="configName">Config Name:</label>
                      <input
                        type="text"
                        id="configName"
                        placeholder="Enter Config Name *"
                      />

                      <label for="appid">AppID:</label>
                      <input
                        type="text"
                        id="appid"
                        placeholder="Enter AppID *"
                      />

                      <label for="configPath"
                        >Config path: ! Leave empty to generate !</label
                      >
                      <div class="input-with-button">
                        <input
                          type="text"
                          id="configPath"
                          placeholder="Example: steam_settings"
                        />
                        <button type="button" id="selectConfigFolder">
                          üìÇ
                        </button>
                      </div>

                      <label for="savePath">Save path:</label>
                      <div class="input-with-button">
                        <input
                          type="text"
                          id="savePath"
                          placeholder="Example: GSE Saves "
                        />
                        <button type="button" id="selectSaveFolder">üìÇ</button>
                      </div>
                    </div>

                    <!-- Left -->
                    <div style="flex: 1; display: flex; flex-direction: column">
                      <label for="executablePath">Executable (optional):</label>
                      <div class="input-with-button">
                        <input
                          type="text"
                          id="executablePath"
                          placeholder="Path to executable"
                        />
                        <button type="button" id="selectExecutable">üìÇ</button>
                      </div>

                      <label for="exeArgs">Arguments (optional):</label>
                      <input
                        type="text"
                        id="exeArgs"
                        placeholder="Optional arguments"
                      />

                      <label for="processName">Process name (optional):</label>
                      <input
                        type="text"
                        id="processName"
                        placeholder="Optional ‚Äì real .exe name"
                      />
                      <label for="platformSelect">Platform:</label>
                      <select id="platformSelect">
                        <option value="auto" selected>Auto</option>
                        <option value="steam">Steam</option>
                        <option value="uplay">Uplay</option>
                        <option value="epic">Epic</option>
                        <option value="gog">GOG</option>
                      </select>

                      <div
                        id="steamAppIdRow"
                        class="input-with-button"
                        style="display: none"
                      >
                        <input
                          type="text"
                          id="steamAppIdInput"
                          placeholder="Mapped Steam AppID"
                        />
                        <button type="button" id="lookupSteamIdBtn">??</button>
                      </div>
                    </div>
                  </div>

                  <!-- Buton Save -->
                  <div
                    style="
                      display: flex;
                      justify-content: center;
                      margin-top: 5px;
                    "
                  >
                    <button
                      id="saveBtn"
                      style="
                        background-color: #4caf50;
                        color: white;
                        border: none;
                        padding: 10px 24px;
                        border-radius: 6px;
                        font-weight: bold;
                        width: auto;
                      "
                    >
                      Save Config
                    </button>
                  </div>
                </div>
              </div>
            </div>
          </div>

          <div class="config-controls clean">
            <label for="configList" class="field-label">Select Config:</label>
            <select id="configList" class="field-input">
              <option value="" disabled selected>Select</option>
            </select>
            <button
              id="deleteConfigBtn"
              style="display: none; margin-top: 25px"
            >
              Delete
            </button>
            <button id="blacklistConfigBtn" style="display: none">
              Add to Blacklist
            </button>
            <div class="button-row">
              <button id="editConfigBtn" style="display: none">
                Edit Config
              </button>
              <button id="backButton" class="hidden">Back</button>
            </div>

            <div class="language-controls">
              <label for="languageSelect" class="field-label"
                >Select Language:</label
              >
              <select id="languageSelect" class="field-input">
                <option value="english">English</option>
                <option value="german">Deutsch</option>
                <option value="french">Fran√ßais</option>
                <option value="italian">Italiano</option>
                <option value="koreana">ÌïúÍµ≠Ïñ¥ (Korean)</option>
                <option value="spanish">Espa√±ol</option>
                <option value="schinese">
                  ÁÆÄ‰Ωì‰∏≠Êñá (Chinese - Simplified)
                </option>
                <option value="tchinese">
                  ÁπÅÈ´î‰∏≠Êñá (Chinese - Traditional)
                </option>
                <option value="russian">–†—É—Å—Å–∫–∏–π</option>
                <option value="japanese">Êó•Êú¨Ë™û</option>
                <option value="polish">Polski</option>
                <option value="brazilian">Portugu√™s (Brasil)</option>
                <option value="LATAM">Espa√±ol (Latinoam√©rica)</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Right Side: Game Image (embedded) -->
        <div
          class="settings-container"
          style="
            flex: 1;
            min-width: 300px;
            display: flex;
            flex-direction: column;
            gap: 5px;
          "
        >
          <div id="embeddedGameImage" class="game-image-embed">
            <div id="embeddedImageContainer">
              <img id="embeddedGameImageImg" src="" alt="Game Cover" />
              <button
                id="edit-btn"
                type="button"
                onclick="showAltAppIdPrompt()"
              >
                ‚úé
              </button>
            </div>

            <div
              id="embeddedFallbackPrompt"
              style="
                display: none;
                flex-direction: column;
                align-items: center;
                padding: 20px;
                color: white;
              "
            >
              <p>‚ö†Ô∏è Does the game have a different Steam AppID on Steam?</p>
              <input
                type="text"
                id="altAppId"
                placeholder="Enter alternative AppID"
                style="padding: 5px; font-size: 16px; width: 200px"
              />
              <div style="margin-top: 10px">
                <button type="button" onclick="downloadFromAlternativeAppId()">
                  ‚úÖ Try Alternative
                </button>
                <button
                  type="button"
                  onclick="cancelFallback()"
                  style="margin-left: 5px"
                >
                  ‚úñ Cancel
                </button>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div
      id="mainScroll"
      class="scroll-container"
      data-scroll-container="1"
      tabindex="0"
    >
      <table class="achievements">
        <thead>
          <tr></tr>
        </thead>
        <tbody id="achievementsTableBody"></tbody>
      </table>
      <div style="height: 50px"></div>
    </div>

    <!-- Hidden elements to maintain compatibility with existing code -->
    <div style="display: none">
      <button id="testAchievementBtn">Test Achievement</button>
      <input type="checkbox" id="disableProgressCheckbox" />
      <input
        type="range"
        id="scaleSlider"
        min="0.01"
        max="2.0"
        step="0.01"
        value="1.0"
      />
      <span id="scaleValue">1.0</span>
      <select id="positionDropdown">
        <option value="center-bottom">Center Bottom</option>
        <option value="center-top">Center Top</option>
        <option value="top-right">Top Right</option>
        <option value="bottom-right">Bottom Right</option>
        <option value="top-left">Top Left</option>
        <option value="bottom-left">Bottom Left</option>
      </select>
      <select id="presetDropdown"></select>
      <select id="soundSelect"></select>
      <input type="hidden" id="platinumPresetValue" />
      <input type="hidden" id="platinumPositionValue" />
      <input type="hidden" id="platinumSoundValue" />
    </div>

    <!-- DASHBOARD -->
    <div id="dashboardOverlay" aria-hidden="true">
      <div
        id="dashboardPanel"
        role="dialog"
        aria-modal="true"
        aria-label="Games Dashboard"
      >
        <div id="dashboardHeader">
          <div id="dashboardStats" aria-live="polite">
            <span>Games: <strong id="gamesTotal">0</strong></span>
            <span class="sep">‚Ä¢</span>
            <span>Perfect Games: <strong id="perfectTotal">0</strong></span>
          </div>

          <!-- SEARCH -->
          <div id="dashboardSearch">
            <input
              id="dashboardSearchInput"
              type="text"
              placeholder="Search games‚Ä¶"
              autocomplete="off"
              spellcheck="false"
            />
          </div>

          <!-- SORT CONTROL -->
          <div
            id="dashboardControls"
            style="
              margin-left: 12px;
              display: flex;
              align-items: center;
              gap: 8px;
            "
          >
            <div
              id="dashboardSortIcons"
              class="sort-icons"
              style="display: flex; gap: 6px"
            >
              <!-- Name -->
              <button
                id="sort-name"
                class="sort-btn"
                type="button"
                title="Sort by name (A‚ÜíZ / Z‚ÜíA)"
              >
                <i class="fa-solid fa-font"></i>
                <span class="dir">‚Üë</span>
              </button>

              <!-- Progress -->
              <button
                id="sort-progress"
                class="sort-btn"
                type="button"
                title="Sort by progress (low‚Üíhigh / high‚Üílow)"
              >
                <i class="fa-solid fa-chart-simple"></i>
                <span class="dir">‚Üë</span>
              </button>

              <!-- Last updated -->
              <button
                id="sort-time"
                class="sort-btn"
                type="button"
                title="Sort by last updated (newest / oldest)"
              >
                <i class="fa-regular fa-clock"></i>
                <span class="dir">‚Üì</span>
              </button>
            </div>
          </div>

          <button id="closeDashboard" type="button" title="Close">√ó</button>
        </div>

        <div id="dashboardBody">
          <div
            class="dashboard-grid"
            id="dashboardGrid"
            role="grid"
            aria-label="Games list"
            tabindex="0"
          ></div>
        </div>
      </div>
    </div>

    <script>
      window.__coverNameCache = window.__coverNameCache || {};
      function rememberCoverName(appid, displayName) {
        if (!appid || !displayName) return;
        const key = String(appid);
        window.__coverNameCache[key] = String(displayName).trim();
      }
      function rememberCoverNamesFromList(list) {
        if (!Array.isArray(list)) return;
        list.forEach((cfg) => {
          if (cfg?.appid && (cfg.displayName || cfg.name)) {
            rememberCoverName(cfg.appid, cfg.displayName || cfg.name);
          }
        });
      }
      function getCoverSearchTerm(appid) {
        if (!appid) return "";
        const key = String(appid);
        return window.__coverNameCache[key] || "";
      }

      window.__preferencesCache = window.__preferencesCache || null;
      window.__preferencesLoadPromise = null;
      const blacklistLabelCache = new Map();

      function deepEqual(a, b) {
        if (a === b) return true;
        if (Array.isArray(a) && Array.isArray(b)) {
          if (a.length !== b.length) return false;
          for (let i = 0; i < a.length; i += 1) {
            if (!deepEqual(a[i], b[i])) return false;
          }
          return true;
        }
        if (
          a &&
          b &&
          typeof a === "object" &&
          typeof b === "object" &&
          a.constructor === Object &&
          b.constructor === Object
        ) {
          const keys = new Set([...Object.keys(a), ...Object.keys(b)]);
          for (const k of keys) {
            if (!deepEqual(a[k], b[k])) return false;
          }
          return true;
        }
        return false;
      }

      async function loadPreferencesCached() {
        if (window.__preferencesLoadPromise) {
          return window.__preferencesLoadPromise;
        }
        window.__preferencesLoadPromise = (async () => {
          try {
            const prefs = await window.api.loadPreferences();
            window.__preferencesCache = { ...(prefs || {}) };
            return window.__preferencesCache;
          } catch (err) {
            console.error("Failed to load preferences:", err);
            return window.__preferencesCache || {};
          } finally {
            window.__preferencesLoadPromise = null;
          }
        })();
        return window.__preferencesLoadPromise;
      }

      function getCachedPreferences() {
        return window.__preferencesCache || {};
      }

      async function refreshPreferencesCache() {
        try {
          await loadPreferencesCached();
        } catch (err) {
          console.warn("Failed to refresh preferences cache:", err);
        }
      }
      async function maybeRequestPlatinum(
        configMeta,
        achievementsList,
        savedAchievementsObj
      ) {
        if (!configMeta) return;
        if (configMeta.platinum === true) return; // already flagged, skip
        const total = Array.isArray(achievementsList)
          ? achievementsList.length
          : 0;
        if (!total) return;
        const saved = savedAchievementsObj?.achievements || {};
        const earned = Object.values(saved).filter((x) => x?.earned).length;
        if (earned !== total) return;

        window.__platinumManualSent = window.__platinumManualSent || new Set();
        const key =
          configMeta.name ||
          configMeta.configName ||
          configMeta.appid ||
          configMeta.appId ||
          "";
        if (!key || window.__platinumManualSent.has(key)) return;
        window.__platinumManualSent.add(key);

        const payload = {
          configName: configMeta.name || configMeta.configName || "",
          appid: configMeta.appid || configMeta.appId || null,
          savePath: configMeta.save_path || configMeta.savePath || null,
          configPath: configMeta.config_path || configMeta.configPath || null,
          suppressNotify: false,
        };

        try {
          if (window.api?.requestPlatinumManual) {
            await window.api.requestPlatinumManual(payload);
          } else if (window.electron?.ipcRenderer?.invoke) {
            await window.electron.ipcRenderer.invoke(
              "platinum:manual",
              payload
            );
          }
        } catch (err) {
          console.warn("Failed to trigger manual platinum:", err);
        }
      }

      if (!window.__savePrefsPatched && window.api?.savePreferences) {
        window.__savePrefsPatched = true;
        const originalSavePreferences = window.api.savePreferences;
        window.api.savePreferences = async (prefs) => {
          const current = getCachedPreferences();
          const pending = { ...(prefs || {}) };
          Object.keys(pending).forEach((key) => {
            if (deepEqual(pending[key], current[key])) {
              delete pending[key];
            }
          });
          if (!Object.keys(pending).length) return current;
          const result = await originalSavePreferences(pending);
          try {
            const merged = {
              ...current,
              ...pending,
            };
            delete merged.steamApiKeyMasked;
            window.__preferencesCache = merged;
          } catch (err) {
            console.warn("Failed to update preferences cache:", err);
          }
          return result;
        };
      }

      function patchApiWithCacheRefresh(target, method) {
        if (!target || typeof target[method] !== "function") return;
        const flag = `__prefsCacheWrapped_${method}`;
        if (target[flag]) return;
        const original = target[method];
        target[method] = async (...args) => {
          const result = await original(...args);
          await refreshPreferencesCache();
          return result;
        };
        target[flag] = true;
      }

      patchApiWithCacheRefresh(window.api, "blacklistConfig");
      patchApiWithCacheRefresh(window.api, "resetBlacklist");
      patchApiWithCacheRefresh(window.api, "getBlacklist");
      if (window.folders) {
        ["add", "remove", "block", "unblock"].forEach((method) =>
          patchApiWithCacheRefresh(window.folders, method)
        );
      }

      //Start with Windows
      async function handleStartWithWindowsToggle(enabled) {
        const checkbox = document.getElementById(
          "settings-startWindowsCheckbox"
        );
        try {
          await window.api.setStartWithWindows(enabled);
          await window.api.savePreferences({ startWithWindows: enabled });
        } catch (err) {
          if (checkbox) checkbox.checked = !enabled;
          alert(
            "Failed to update auto-start setting. Please run as administrator."
          );
        }
      }

      // Image script
      window.addEventListener("DOMContentLoaded", () => {
        const embedRoot = document.getElementById("embeddedGameImage");
        const imgWrap = document.getElementById("embeddedImageContainer");
        const imgEl = document.getElementById("embeddedGameImageImg");
        const fallbackBox = document.getElementById("embeddedFallbackPrompt");
        const fallbackIcon = new URL(
          "./assets/achievements-logo.png",
          window.location.href
        ).toString();
        const downloadIdCache = new Map();
        const steamGridUrlCache = new Map();
        function buildSteamGridSearchTerm(input) {
          return String(input || "")
            .trim()
            .replace(/\+/g, " ")
            .replace(/\s+/g, "+");
        }
        async function downloadFromSteamGrid(
          targetAppId,
          rawTerm,
          size = "600x900"
        ) {
          const term = buildSteamGridSearchTerm(rawTerm);
          if (!term) return false;
          const cacheKey = `${size}::${term.toLowerCase()}`;
          if (steamGridUrlCache.has(cacheKey)) {
            const cached = steamGridUrlCache.get(cacheKey);
            if (cached === null) return false;
            try {
              await downloadAndSave(targetAppId, cached);
              return true;
            } catch (err) {
              steamGridUrlCache.delete(cacheKey);
            }
          }
          try {
            const response = await window.api.getSteamGridDbCover({
              term,
              size,
            });
            if (response?.ok && response.url) {
              steamGridUrlCache.set(cacheKey, response.url);
              await downloadAndSave(targetAppId, response.url);
              return true;
            }
          } catch (err) {}
          steamGridUrlCache.set(cacheKey, null);
          return false;
        }
        async function resolveRemoteAppId(appid) {
          const key = String(appid || "");
          if (!/^\d+$/.test(key)) return key;
          if (downloadIdCache.has(key)) return downloadIdCache.get(key);
          try {
            const mapped = await window.api.getSteamLookupAppId(key);
            const effective =
              mapped && /^\d+$/.test(String(mapped)) ? String(mapped) : key;
            downloadIdCache.set(key, effective);
            return effective;
          } catch {
            downloadIdCache.set(key, key);
            return key;
          }
        }
        if (!embedRoot || !imgWrap || !imgEl) return;

        // --- fallback logo ---
        function showFallbackLogo() {
          imgEl.onload = null;
          imgEl.onerror = null;
          imgEl.src = fallbackIcon;
          imgWrap.style.display = "flex";
          if (fallbackBox) fallbackBox.style.display = "none";
        }
        window.__showFallbackLogo = showFallbackLogo;
        showFallbackLogo();

        // --- UI helpers ---
        function setVisible(hasImage) {
          if (hasImage) {
            if (fallbackBox) fallbackBox.style.display = "none";
            imgWrap.style.display = "flex";
          } else {
            imgWrap.style.display = "flex";
            if (fallbackBox) fallbackBox.style.display = "none";
          }
        }

        function fileUrl(p) {
          return `file:///${encodeURI(String(p).replace(/\\/g, "/"))}`;
        }

        function setImg(src) {
          return new Promise((resolve, reject) => {
            const versioned = `${src}${
              src.includes("?") ? "&" : "?"
            }_=${Date.now()}`;

            imgEl.onload = () => resolve();
            imgEl.onerror = () =>
              reject(new Error(`image load failed: ${versioned}`));
            imgEl.src = "";
            requestAnimationFrame(() => {
              imgEl.src = versioned;
            });
          });
        }

        async function setImgFromLocal(localPath) {
          const url = fileUrl(localPath);
          await setImg(url);
        }

        const NOT_FOUND_TAG = "steamdb-miss";
        const isNotFoundError = (err) =>
          !!err && (err.tag === NOT_FOUND_TAG || err.code === NOT_FOUND_TAG);

        const CDN_HOSTS = [
          "https://shared.fastly.steamstatic.com",
          "https://shared.cloudflare.steamstatic.com",
          "https://cdn.akamai.steamstatic.com/",
        ];
        const remoteAppIdCache = new Map();
        async function resolveRemoteAppId(appid) {
          const key = String(appid || "");
          if (!/^\d+$/.test(key)) return key;
          if (remoteAppIdCache.has(key)) return remoteAppIdCache.get(key);
          try {
            const mapped = await window.api.getSteamLookupAppId(key);
            const effective =
              mapped && /^\d+$/.test(String(mapped)) ? String(mapped) : key;
            remoteAppIdCache.set(key, effective);
            return effective;
          } catch {
            remoteAppIdCache.set(key, key);
            return key;
          }
        }
        async function downloadAndSave(targetAppId, url, platformHint = null) {
          const logCover = (level, message, meta = {}) => {
            try {
              if (window.api?.logCoverEvent) {
                window.api.logCoverEvent(level, message, meta);
              }
            } catch {}
          };
          logCover("info", "download:start", {
            appid: targetAppId,
            platform: platformHint || "auto",
            url,
          });
          const res = await fetch(url, { cache: "no-store" });
          if (!res.ok) throw new Error("HTTP " + res.status);
          const blob = await res.blob();
          const buf = new Uint8Array(await blob.arrayBuffer());
          const platform =
            platformHint ||
            (await resolvePlatformForCurrentApp(targetAppId)) ||
            null;
          await window.api.saveGameImage(String(targetAppId), buf, platform);
          logCover("info", "download:saved", {
            appid: targetAppId,
            platform: platform || "auto",
            url,
          });
        }
        async function resolvePlatformForCurrentApp(appid) {
          try {
            const selectedConfig = document.getElementById("configList")?.value;
            if (selectedConfig && window.api.getConfigByName) {
              const cfg = await window.api.getConfigByName(selectedConfig);
              const cfgAppId = cfg?.appid || cfg?.appId;
              if (cfg && String(cfgAppId || "") === String(appid || cfgAppId)) {
                return cfg.platform || null;
              }
            }
          } catch {}
          return null;
        }

        const inFlightCovers = new Map();
        async function downloadFromCdnAndCache(
          targetAppId,
          fetchAppIdOverride = null,
          options = {}
        ) {
          const key = String(targetAppId);
          if (inFlightCovers.has(key)) {
            return inFlightCovers.get(key);
          }
          const task = (async () => {
            const fetchAppId = fetchAppIdOverride || targetAppId;
            const fallbackName = String(
              options?.gameName || getCoverSearchTerm(targetAppId) || ""
            ).trim();
            const platform =
              options?.platform ||
              (await resolvePlatformForCurrentApp(targetAppId)) ||
              null;
            const steamGridSize =
              options?.gridSize && String(options.gridSize).trim().length
                ? String(options.gridSize)
                : "600x900";
            const logCover = (level, message, meta = {}) => {
              try {
                if (window.api?.logCoverEvent) {
                  window.api.logCoverEvent(level, message, meta);
                }
              } catch {}
            };
            logCover("info", "cascade:start", {
              targetAppId,
              fetchAppId,
              platform,
              coverName: fallbackName || null,
              steamGridSize,
            });
            const plain = [
              `https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/${fetchAppId}/library_600x900.jpg`,
              `https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/${fetchAppId}/library_600x900.jpg`,
              `https://shared.cloudflare.steamstatic.com/store_item_assets/steam/apps/${fetchAppId}/portrait.png`,
              `https://shared.fastly.steamstatic.com/store_item_assets/steam/apps/${fetchAppId}/portrait.png`,
              `https://cdn.akamai.steamstatic.com/steam/apps/${fetchAppId}/library_600x900.jpg`,
              `https://cdn.akamai.steamstatic.com/steam/apps/${fetchAppId}/header.jpg`,
            ];

            for (const url of plain) {
              try {
                await downloadAndSave(targetAppId, url, platform);
                logCover("info", "cdn:hit", { targetAppId, fetchAppId, url });
                return true;
              } catch (err) {
                logCover("warn", "cdn:miss", {
                  targetAppId,
                  fetchAppId,
                  url,
                  error: err?.message || String(err),
                });
              }
            }

            try {
              const r = await window.api.getSteamDbCover(fetchAppId);
              if (r?.url) {
                await downloadAndSave(targetAppId, r.url, platform);
                logCover("info", "steamdb:hit", {
                  targetAppId,
                  fetchAppId,
                  url: r.url,
                });
                return true;
              }
            } catch (err) {
              logCover("warn", "steamdb:fail", {
                targetAppId,
                fetchAppId,
                error: err?.message || String(err),
              });
            }

            try {
              await downloadFromStoreHeader(fetchAppId, targetAppId);
              logCover("info", "store:hit", {
                targetAppId,
                fetchAppId,
              });
              return true;
            } catch (err) {
              logCover("warn", "store:fail", {
                targetAppId,
                fetchAppId,
                error: err?.message || String(err),
              });
            }

            if (fallbackName) {
              const ok = await downloadFromSteamGrid(
                targetAppId,
                fallbackName,
                steamGridSize
              );
              if (ok) {
                logCover("info", "steamgrid:hit", {
                  targetAppId,
                  fetchAppId,
                  term: fallbackName,
                  steamGridSize,
                });
                return true;
              }
            }

            logCover("warn", "covers:all-sources-failed", {
              targetAppId,
              fetchAppId,
            });
            return false;
          })().finally(() => inFlightCovers.delete(key));

          inFlightCovers.set(key, task);
          return task;
        }
        async function downloadFromStoreHeader(
          fetchAppId,
          targetAppId = fetchAppId
        ) {
          try {
            const res = await fetch(
              `https://store.steampowered.com/api/appdetails?appids=${fetchAppId}`,
              { cache: "no-store" }
            );
            if (!res.ok) throw new Error(`Store API HTTP ${res.status}`);

            const data = await res.json();
            const entry = data?.[String(fetchAppId)];
            const headerUrl =
              entry?.data?.library_assets?.library_600x900 ||
              entry?.data?.library_assets?.logo ||
              entry?.data?.header_image ||
              entry?.data?.capsule_image;

            if (!headerUrl) {
              const err = new Error("Store: no image field");
              err.tag = NOT_FOUND_TAG;
              throw err;
            }

            await downloadAndSave(targetAppId, headerUrl);
            return true;
          } catch (err) {
            if (!err.tag) err.tag = NOT_FOUND_TAG;
            throw err;
          }
        }

        // --- loader: local -> (fallback) -> CDN -> local ---
        async function loadLocalCover(appid) {
          if (!appid) {
            showFallbackLogo();
            return;
          }

          const fetchAppId = await resolveRemoteAppId(appid);
          const coverNameHint = getCoverSearchTerm(appid) || "";
          const platform =
            (await resolvePlatformForCurrentApp(appid)) || "steam";

          try {
            const localPath = await window.api.checkLocalGameImage(
              String(appid),
              platform
            );

            if (localPath) {
              try {
                await setImgFromLocal(localPath);
                setVisible(true);
                return;
              } catch {
                showFallbackLogo();
                return;
              }
            }
            showFallbackLogo();

            const ok = await downloadFromCdnAndCache(
              String(appid),
              fetchAppId,
              { gameName: coverNameHint, platform }
            );
            if (!ok) return;

            const newLocal = await window.api.checkLocalGameImage(
              String(appid),
              platform
            );
            if (newLocal) {
              try {
                await setImgFromLocal(newLocal);
                setVisible(true);
              } catch {
                showFallbackLogo();
              }
            } else {
              showFallbackLogo();
            }
          } catch {
            showFallbackLogo();
          }
        }
        window.__applyEmbeddedGameImageForAppId = async function (appid) {
          if (!appid) {
            showFallbackLogo();
            return;
          }
          try {
            await loadLocalCover(String(appid));
          } catch {
            showFallbackLogo();
          }
        };

        // ‚úé prompt
        window.showAltAppIdPrompt = function () {
          if (fallbackBox) fallbackBox.style.display = "flex";
          imgWrap.style.display = "none";
          const input = document.getElementById("altAppId");
          if (input) {
            input.focus();
            input.select();
          }
        };

        window.cancelFallback = function () {
          if (fallbackBox) fallbackBox.style.display = "none";
          imgWrap.style.display = "flex";
        };

        // alt AppID
        window.downloadFromAlternativeAppId = async function () {
          const input = document.getElementById("altAppId");
          const alt = (input?.value || "").trim();
          if (!/^\d+$/.test(alt)) {
            alert("Please enter a valid AppID");
            return;
          }

          const selectedConfig = document.getElementById("configList")?.value;
          const currentConfig = selectedConfig
            ? await window.api.getConfigByName(selectedConfig)
            : null;
          const currentAppId =
            currentConfig?.appid && /^\d+$/.test(String(currentConfig.appid))
              ? String(currentConfig.appid)
              : alt;
          const platform =
            currentConfig?.platform ||
            (await resolvePlatformForCurrentApp(currentAppId)) ||
            null;
          const coverName =
            getCoverSearchTerm(currentAppId) ||
            currentConfig?.displayName ||
            currentConfig?.name ||
            "";
          if (coverName) {
            rememberCoverName(currentAppId, coverName);
          }

          const ok = await downloadFromCdnAndCache(String(currentAppId), alt, {
            gameName: coverName,
            platform,
          });

          if (!ok) {
            alert("No image available for the alternate AppID.");
            return;
          }

          await loadLocalCover(String(currentAppId));
          if (fallbackBox) fallbackBox.style.display = "none";
          imgWrap.style.display = "flex";
        };

        // update main
        if (!window.__imageListenerAttached) {
          window.api.onImageUpdate(async (payload) => {
            const appid =
              typeof payload === "object" && payload?.appid
                ? String(payload.appid)
                : /^\d+$/.test(String(payload))
                ? String(payload)
                : null;
            if (appid) await loadLocalCover(appid);
            else showFallbackLogo();
          });

          window.__imageListenerAttached = true;
        }
        window.loadLocalCover = loadLocalCover;
      });

      window.addEventListener("DOMContentLoaded", () => {
        const iconParam = new URLSearchParams(location.search).get("icon");
        if (!iconParam) return;
        const url = decodeURIComponent(iconParam);
        const el = document.getElementById("appIcon");
        if (el) el.src = url;
      });
      function getAppIconUrl() {
        const q = new URLSearchParams(location.search).get("icon");
        return q ? decodeURIComponent(q) : "";
      }
      //Achievements Images
      async function resolveAchievementIcon(imgEl, cfgPath, rel) {
        const FALLBACK = getAppIconUrl();
        const r = String(rel || "");
        const base = r.split(/[\\/]/).pop();

        const candidates = []
          .concat(r ? [`${cfgPath}\\${r}`] : [])
          .concat([
            `${cfgPath}\\achievement_images\\${base}`,
            `${cfgPath}\\steam_settings\\achievement_images\\${base}`,
            `${cfgPath}\\img\\${base}`,
            `${cfgPath}\\images\\${base}`,
          ])
          .filter((v, i, a) => v && a.indexOf(v) === i)
          .map((p) => `file:///${p.replace(/\\/g, "/")}`);

        let i = 0;
        const tryNext = () => {
          if (i >= candidates.length) {
            imgEl.src = FALLBACK;
            return;
          }
          imgEl.onerror = () => {
            i++;
            tryNext();
          };
          imgEl.src = candidates[i];
        };
        tryNext();
      }

      async function buildMainAchievementsTable(
        selectedConfig,
        lang = "english"
      ) {
        if (!selectedConfig) return;

        const achievementsDataObj = await window.api.loadAchievementData(
          selectedConfig
        );
        if (
          !achievementsDataObj ||
          !Array.isArray(achievementsDataObj.achievements)
        ) {
          const body = document.getElementById("achievementsTableBody");
          if (body) body.innerHTML = "";
          const achStats = document.getElementById("achStats");
          if (achStats) achStats.style.display = "none";
          const playtimeLabel = document.getElementById("achStatsPlaytime");
          if (playtimeLabel) playtimeLabel.textContent = "Playtime: 0m";
          return;
        }
        const savedAchievementsObj = await window.api.loadSavedAchievements(
          selectedConfig
        );
        const currentConfig = await window.api.getConfigByName(selectedConfig);
        maybeRequestPlatinum(
          { name: selectedConfig, ...(currentConfig || {}) },
          achievementsDataObj?.achievements || [],
          savedAchievementsObj
        );

        const tableBody = document.getElementById("achievementsTableBody");
        if (!tableBody) return;
        tableBody.innerHTML = "";

        if (
          achievementsDataObj?.error ||
          !Array.isArray(achievementsDataObj?.achievements)
        )
          return;

        // Sort after name
        const seen = new Set();
        const unique = [];
        for (const a of achievementsDataObj.achievements) {
          if (!a?.name || seen.has(a.name)) continue;
          seen.add(a.name);
          unique.push(a);
        }

        // unlocked first
        const isUnlocked = (name) =>
          !!savedAchievementsObj?.achievements?.[name]?.earned;
        unique.sort(
          (a, b) => (isUnlocked(b.name) ? 1 : 0) - (isUnlocked(a.name) ? 1 : 0)
        );

        function tsToLocal(ts) {
          if (!ts) return "N/A";
          const d = new Date(String(ts).length === 10 ? ts * 1000 : Number(ts));
          return isNaN(d) ? "N/A" : d.toLocaleString();
        }

        for (const achievement of unique) {
          const displayName = getSafeLocalizedText(
            achievement.displayName,
            lang
          );
          const description = getSafeLocalizedText(
            achievement.description,
            lang
          );
          const iconGray = achievement.icon_gray || achievement.icongray;
          const icon = achievement.icon || iconGray;

          const saved = savedAchievementsObj?.achievements?.[achievement.name];
          const imgRel = saved?.earned ? icon : iconGray;
          const imagePath = `file:///${`${achievementsDataObj.config_path}\\${imgRel}`.replace(
            /\\/g,
            "/"
          )}`;

          const statusHTML = saved?.earned
            ? `<span class="unlocked">Unlocked</span>`
            : `<span class="locked">Locked</span>`;

          const earnedTimeText = saved?.earned_time
            ? `<br>${tsToLocal(saved.earned_time)}`
            : "";
          let progressText = "";
          if (
            Number.isFinite(saved?.progress) &&
            Number.isFinite(saved?.max_progress) &&
            saved.max_progress > 0
          ) {
            const pct = Math.min(
              100,
              Math.round((saved.progress / saved.max_progress) * 100)
            );
            progressText = `
                    <div class="achievement-progress">
                    Progress: ${saved.progress} / ${saved.max_progress}
                    <div class="progress-bar">
                        <div class="progress-fill" style="width:${pct}%"></div>
                    </div>
                    </div>`;
          }

          const row = document.createElement("tr");
          // col image
          const tdImg = document.createElement("td");
          tdImg.className = "image";
          const achImg = document.createElement("img");
          achImg.className = "ach-icon";
          achImg.alt = "Icon";
          tdImg.appendChild(achImg);

          // col text
          const tdText = document.createElement("td");
          tdText.className = "displayName";
          const strong = document.createElement("strong");
          strong.textContent = displayName || "Hidden";
          const descWrap = document.createElement("span");
          descWrap.className = "description";
          descWrap.style.display = "block";
          const prefs = getCachedPreferences() || {};
          const isHiddenInSchema = Number(achievement.hidden) === 1;
          const isUnlockedState = !!saved?.earned;
          const canShowHiddenDesc =
            isUnlockedState && description
              ? true
              : prefs.showHiddenDescription === true;
          const descText =
            isHiddenInSchema && !canShowHiddenDesc
              ? "Hidden"
              : description || "";
          descWrap.appendChild(document.createElement("em")).textContent =
            descText;
          tdText.appendChild(strong);
          tdText.appendChild(document.createElement("br"));
          tdText.appendChild(descWrap);

          // progress
          if (
            Number.isFinite(saved?.progress) &&
            Number.isFinite(saved?.max_progress) &&
            saved.max_progress > 0
          ) {
            const pct = Math.min(
              100,
              Math.round((saved.progress / saved.max_progress) * 100)
            );
            const progWrap = document.createElement("div");
            progWrap.className = "achievement-progress";
            progWrap.textContent = `Progress: ${saved.progress} / ${saved.max_progress}`;
            const bar = document.createElement("div");
            bar.className = "progress-bar";
            const fill = document.createElement("div");
            fill.className = "progress-fill";
            fill.style.width = `${pct}%`;
            bar.appendChild(fill);
            progWrap.appendChild(bar);
            tdText.appendChild(progWrap);
          }

          // col status
          const tdStatus = document.createElement("td");
          tdStatus.className = "status";
          const st = document.createElement("span");
          st.className = saved?.earned ? "unlocked" : "locked";
          st.textContent = saved?.earned ? "Unlocked" : "Locked";
          tdStatus.appendChild(st);
          if (saved?.earned_time) {
            tdStatus.appendChild(document.createElement("br"));
            tdStatus.appendChild(
              document.createTextNode(tsToLocal(saved.earned_time))
            );
          }

          row.append(tdImg, tdText, tdStatus);
          tableBody.appendChild(row);
          const imgEl = row.querySelector("img.ach-icon");
          resolveAchievementIcon(
            imgEl,
            achievementsDataObj.config_path,
            imgRel
          );
        }

        // Main Progress Bar
        updateAchievementStats(
          unique.map((a) => ({ ...a, earned: isUnlocked(a.name) }))
        );
        const achStats = document.getElementById("achStats");
        if (achStats) achStats.style.display = "block";
        await updatePlaytimeLabel(selectedConfig);
      }

      (function attachRefreshAchievementsHandlerOnce() {
        if (window.__refreshAchievementsHandlerAttached) return;
        window.__refreshAchievementsHandlerAttached = true;

        window.api.on("refresh-achievements-table", async (configName) => {
          const cfg =
            configName || document.getElementById("configList")?.value;
          if (cfg) {
            const lang =
              document.getElementById("languageSelect")?.value || "english";
            try {
              await buildMainAchievementsTable(cfg, lang);
            } catch {}
          }

          if (
            window.__dashboardOpen &&
            typeof window.updateCardProgressUI === "function"
          ) {
            const name =
              configName || document.getElementById("configList")?.value;
            if (name) {
              const card = document.querySelector(
                `.dash-card[data-name="${CSS.escape(name)}"]`
              );
              if (card) {
                try {
                  await window.updateCardProgressUI(card, name);
                } catch {}
              }
            }
          }
        });
      })();

      function formatPlaytimeLabel(ms) {
        const totalSeconds = Math.max(0, Math.floor(Number(ms || 0) / 1000));
        if (!totalSeconds) return "0s";

        const hours = Math.floor(totalSeconds / 3600);
        const minutes = Math.floor((totalSeconds % 3600) / 60);
        const seconds = totalSeconds % 60;

        const parts = [];
        if (hours) parts.push(`${hours}h`);
        if (minutes) parts.push(`${minutes}m`);

        // always show seconds if nothing else rendered, or when <1h to match request
        if (!parts.length) {
          parts.push(`${seconds}s`);
        } else if (hours === 0 && seconds) {
          parts.push(`${seconds}s`);
        } else if (hours > 0 && seconds) {
          parts.push(`${seconds}s`);
        }
        return parts.join(" ").trim();
      }

      async function updatePlaytimeLabel(configName) {
        const label = document.getElementById("achStatsPlaytime");
        if (!label || !configName) return;
        try {
          const res = await window.api.getTotalPlaytime(configName);
          const totalMs =
            typeof res === "number" ? res : Number(res?.totalMs || 0);
          label.textContent = `Playtime: ${formatPlaytimeLabel(totalMs)}`;
        } catch {
          label.textContent = "Playtime: 0m";
        }
      }

      const notificationQueue = [];
      let isNotificationActive = false;

      function showNotification(message, backgroundColor = "#4CAF50") {
        notificationQueue.push({ message, backgroundColor });
        if (!isNotificationActive) {
          processNextNotification();
        }
      }

      function processNextNotification() {
        if (notificationQueue.length === 0) {
          isNotificationActive = false;
          return;
        }

        isNotificationActive = true;
        const { message, backgroundColor } = notificationQueue.shift();

        const notif = document.createElement("div");
        notif.textContent = message;
        notif.style.position = "fixed";
        notif.style.top = "100px";
        notif.style.left = "50%";
        notif.style.transform = "translateX(-50%)";
        notif.style.backgroundColor = backgroundColor;
        notif.style.color = "white";
        notif.style.padding = "10px 20px";
        notif.style.borderRadius = "5px";
        notif.style.boxShadow = "0px 2px 8px rgba(0,0,0,0.3)";
        notif.style.zIndex = 9999;
        notif.style.fontWeight = "bold";
        notif.style.fontFamily = "sans-serif";
        notif.style.opacity = "0";
        notif.style.transition = "opacity 0.3s ease";
        notif.style.pointerEvents = "none";
        notif.style.userSelect = "none";
        document.body.appendChild(notif);
        requestAnimationFrame(() => (notif.style.opacity = "1"));

        setTimeout(() => {
          notif.style.opacity = "0";
          setTimeout(() => {
            notif.remove();
            processNextNotification();
          }, 300);
        }, 4000);
      }

      const SUPPRESS_MSG_PATTERNS = [
        /Save path is missing/i,
        /Config path is missing/i,
        /Achievements missing/i,
      ];

      const _shownWarns = new Set();
      function shouldShowOnce(msg) {
        const key = msg.replace(/\s+/g, " ").trim();
        if (_shownWarns.has(key)) return false;
        _shownWarns.add(key);
        setTimeout(() => _shownWarns.delete(key), 2000);
        return true;
      }

      window.api.onNotify(({ message, color }) => {
        const isConfigPathWarn = SUPPRESS_MSG_PATTERNS.some((rx) =>
          rx.test(message)
        );

        if (window.__dashboardOpen && isConfigPathWarn) return;

        if (isConfigPathWarn && !shouldShowOnce(message)) return;

        showNotification(message, color || "#4CAF50");
      });

      window.addEventListener("DOMContentLoaded", () => {
        const originalLog = console.log.bind(console);
        const originalWarn = console.warn.bind(console);
        const originalError = console.error.bind(console);
        const originalAlert = window.alert.bind(window);

        const toMsg = (args) =>
          args
            .map((a) => {
              if (typeof a === "string") return a;
              try {
                return JSON.stringify(a);
              } catch {
                return String(a);
              }
            })
            .join(" ");

        console.log = (...args) => {
          originalLog(...args);
          showNotification(toMsg(args), "#4CAF50");
        };

        console.warn = (...args) => {
          originalWarn(...args);
          showNotification(toMsg(args), "#ff9800");
        };

        console.error = (...args) => {
          originalError(...args);
          showNotification(toMsg(args), "#f44336");
        };

        window.alert = (message) => {
          showNotification(String(message), "#2196f3");
        };
      });

      const scaleSlider = document.getElementById("scaleSlider");
      const scaleValue = document.getElementById("scaleValue");

      function updateScaleLabel() {
        const value = parseFloat(scaleSlider.value);
        scaleValue.textContent = `${Math.round(value * 100)}%`;
        scaleSlider.style.background = `linear-gradient(to right, #007bff 0%, #007bff ${
          value * 100
        }%, #ccc ${value * 100}%, #ccc 100%)`;
      }
      scaleSlider.addEventListener("input", () => {
        updateScaleLabel();
        window.api.savePreferences({ notificationScale: scaleSlider.value });
      });
      updateScaleLabel();

      window.addEventListener("DOMContentLoaded", () => {
        const minimizeBtn = document.getElementById("minimizeBtn");
        const maximizeBtn = document.getElementById("maximizeBtn");
        const closeBtn = document.getElementById("closeBtn");

        document
          .getElementById("closeConfigModal")
          .addEventListener("click", () => {
            document.getElementById("configModal").classList.add("hidden");
            resetConfigForm();
          });
      });

      const platformSelect = document.getElementById("platformSelect");
      const steamAppIdInput = document.getElementById("steamAppIdInput");
      const steamAppIdRow = document.getElementById("steamAppIdRow");
      const lookupSteamIdBtn = document.getElementById("lookupSteamIdBtn");

      function toggleSteamAppIdRow(shouldShow) {
        if (!steamAppIdRow) return;
        steamAppIdRow.style.display = shouldShow ? "flex" : "none";
        if (!shouldShow && steamAppIdInput) {
          steamAppIdInput.value = "";
        }
      }

      async function lookupSteamAppId(manualTrigger = false) {
        if (!steamAppIdInput) return;
        const appidInput = document.getElementById("appid");
        const appIdValue = appidInput?.value.trim();
        if (!appIdValue) {
          if (manualTrigger) {
            showNotification("Enter the AppID.", "#FFC107");
          }
          return;
        }
        try {
          const mapped = await window.api.getSteamLookupAppId(appIdValue);
          if (mapped) {
            steamAppIdInput.value = mapped;
            if (manualTrigger) {
              showNotification(`Steam AppID found: ${mapped}`, "#4CAF50");
            }
            console.info("[platform] steam-id-resolved", {
              appid: appIdValue,
              steamAppId: mapped,
              manual: manualTrigger,
            });
          } else if (manualTrigger) {
            showNotification(
              "No mapping found. Enter Steam AppID manually.",
              "#FFC107"
            );
          }
          if (!mapped) {
            console.warn("[platform] steam-id-miss", {
              appid: appIdValue,
              manual: manualTrigger,
            });
          }
        } catch (err) {
          if (manualTrigger) {
            showNotification("Lookup Steam ID failed.", "#f44336");
          }
          console.error("[platform] steam-id-lookup-error", {
            appid: appIdValue,
            error: err?.message || String(err),
          });
        }
      }

      if (platformSelect) {
        platformSelect.addEventListener("change", async (event) => {
          const nextValue = (event.target.value || "").toLowerCase();
          const showSteamField = nextValue === "uplay";
          toggleSteamAppIdRow(showSteamField);
          if (
            showSteamField &&
            steamAppIdInput &&
            !steamAppIdInput.value.trim()
          ) {
            await lookupSteamAppId(false);
          }
        });
      }

      if (lookupSteamIdBtn) {
        lookupSteamIdBtn.addEventListener("click", async (e) => {
          e.preventDefault();
          await lookupSteamAppId(true);
        });
      }

      let editingConfigName = null;

      function resetConfigForm() {
        const form = document.getElementById("new-config-form");
        const button = document.getElementById("createNewConfigBtn");
        document.getElementById("configName").value = "";
        document.getElementById("appid").value = "";
        document.getElementById("configPath").value = "";
        document.getElementById("savePath").value = "";
        document.getElementById("executablePath").value = "";
        document.getElementById("exeArgs").value = "";
        document.getElementById("processName").value = "";
        if (platformSelect) {
          platformSelect.value = "auto";
          platformSelect.disabled = false;
          platformSelect.title = "";
        }
        toggleSteamAppIdRow(false);
        if (steamAppIdInput) {
          steamAppIdInput.value = "";
        }

        editingConfigName = null;

        if (!form.classList.contains("hidden")) {
          form.classList.add("hidden");
        }

        button.innerHTML =
          'Create New Config <span class="arrow-icon">‚ñº</span>';
        document.getElementById("configFormTitle").textContent =
          "Create New Config";
      }

      document
        .getElementById("createNewConfigBtn")
        .addEventListener("click", () => {
          resetConfigForm();
          document.getElementById("configModal").classList.remove("hidden");
          document.getElementById("new-config-form").classList.remove("hidden");
          document.getElementById("configFormTitle").textContent =
            "Create New Config";
        });

      document
        .getElementById("editConfigBtn")
        .addEventListener("click", async () => {
          const configName = document.getElementById("configList").value;
          if (!configName) return;

          try {
            const currentConfig = await window.api.getConfigByName(configName);

            if (!currentConfig) {
              alert("Config not found!");
              return;
            }

            document.getElementById("configName").value = currentConfig.name;
            document.getElementById("appid").value = currentConfig.appid;
            document.getElementById("configPath").value =
              currentConfig.config_path;
            document.getElementById("savePath").value = currentConfig.save_path;
            document.getElementById("executablePath").value =
              currentConfig.executable || "";
            document.getElementById("exeArgs").value =
              currentConfig.arguments || "";
            document.getElementById("processName").value =
              currentConfig.process_name || "";
            const currentPlatform = (
              currentConfig.platform || "auto"
            ).toLowerCase();
            if (platformSelect) {
              platformSelect.value = ["steam", "uplay", "epic", "gog"].includes(
                currentPlatform
              )
                ? currentPlatform
                : "auto";
              platformSelect.disabled = true;
              platformSelect.title =
                "Platform is locked for existing configs. Create a new config to change it.";
              toggleSteamAppIdRow(platformSelect.value === "uplay");
            }
            if (steamAppIdInput) {
              steamAppIdInput.value = currentConfig.steamAppId || "";
            }

            editingConfigName = currentConfig.name;
            const form = document.getElementById("new-config-form");
            if (form.style.display !== "block") {
              document.getElementById("configModal").classList.remove("hidden");
            }
            const button = document.getElementById("createNewConfigBtn");

            form.classList.remove("hidden");
            button.innerHTML =
              'Editing... <span class="arrow-icon" class="rotate-up">‚ñ≤</span>';
            document.getElementById("configFormTitle").textContent =
              "Edit Config";
          } catch (err) {
            console.error("Edit error:", err);
            alert("Something went wrong loading the config.");
          }
        });

      document
        .getElementById("selectConfigFolder")
        .addEventListener("click", async () => {
          const selectedPath = await window.api.selectFolder();
          if (selectedPath) {
            document.getElementById("configPath").value = selectedPath;
          }
        });

      document
        .getElementById("selectSaveFolder")
        .addEventListener("click", async () => {
          const selectedPath = await window.api.selectFolder();
          if (selectedPath) {
            document.getElementById("savePath").value = selectedPath;
          }
        });

      document.getElementById("saveBtn").addEventListener("click", async () => {
        const configName = document.getElementById("configName").value;
        const appid = document.getElementById("appid").value;
        const configPath = document.getElementById("configPath").value;
        const savePath = document.getElementById("savePath").value;
        const executable = document.getElementById("executablePath").value;
        const arguments = document.getElementById("exeArgs").value;
        const processName = document.getElementById("processName").value;
        const selectedPlatform = platformSelect?.value?.toLowerCase() || "auto";
        const steamAppId = steamAppIdInput?.value.trim() || "";

        if (!configName || !appid) {
          const notif = document.createElement("div");
          notif.textContent = "Name and AppID are required!";
          notif.style.position = "fixed";
          notif.style.top = "100px";
          notif.style.left = "50%";
          notif.style.transform = "translateX(-50%)";
          notif.style.backgroundColor = "#f44336";
          notif.style.color = "white";
          notif.style.padding = "10px 20px";
          notif.style.borderRadius = "5px";
          notif.style.boxShadow = "0px 2px 8px rgba(0,0,0,0.3)";
          notif.style.zIndex = 9999;
          notif.style.fontWeight = "bold";
          notif.style.fontFamily = "sans-serif";

          document.body.appendChild(notif);
          setTimeout(() => notif.remove(), 3000);
          return;
        }

        try {
          const check = await window.api.isAppIdBlacklisted(appid);
          if (check?.blacklisted) {
            showNotification(
              `${check.appid} is on Blacklist. Please remove it to continue.`,
              "#f44336"
            );
            return;
          }
        } catch (err) {
          console.error("Blacklist check failed:", err);
        }

        const config = {
          name: configName,
          appid: appid,
          config_path: configPath || null,
          save_path: savePath || null,
          executable: executable || null,
          arguments: arguments || "",
          process_name: processName || "",
        };
        if (
          selectedPlatform === "steam" ||
          selectedPlatform === "uplay" ||
          selectedPlatform === "epic" ||
          selectedPlatform === "gog"
        ) {
          config.platform = selectedPlatform;
        }
        if (steamAppId) {
          config.steamAppId = steamAppId;
        }

        const result =
          editingConfigName && editingConfigName !== configName
            ? await window.api.renameAndSaveConfig(editingConfigName, config)
            : await window.api.saveConfig(config);

        showNotification(
          result.message,
          result.success ? "#4CAF50" : "#f44336"
        );

        if (result.success) {
          editingConfigName = null;
          document.getElementById("createNewConfigBtn").innerText =
            "Create New Config";
          localStorage.setItem("configSavedMessage", result.message);
          localStorage.setItem(
            "configSavedSuccess",
            result.success ? "true" : "false"
          );

          window.location.reload();
        }
      });

      document
        .getElementById("toggleBtn")
        .addEventListener("click", function () {
          let container = document.getElementById("buttonContainer");
          if (container.classList.contains("hidden")) {
            container.classList.remove("hidden");
            container.style.display = "flex";
            this.textContent = "Hide Options";
          } else {
            container.classList.add("hidden");
            container.style.display = "none";
            this.textContent = "Show Options";
          }
        });

      document
        .getElementById("selectExecutable")
        .addEventListener("click", async () => {
          const selectedExe = await window.api.selectExecutable();
          if (selectedExe) {
            document.getElementById("executablePath").value = selectedExe;
          }
        });

      document.getElementById("playBtn").addEventListener("click", async () => {
        const name = document.getElementById("configList")?.value;
        if (!name) return;
        const config = await window.api.getConfigByName(name);
        if (config?.executable) {
          const args = config.arguments || "";
          await window.api.launchExecutable(config.executable, args);
        }
      });

      document
        .getElementById("languageSelect")
        .addEventListener("change", async (e) => {
          const selectedLang = e.target.value;

          await window.api.savePreferences({ language: selectedLang });

          const configName = document.getElementById("configList").value;
          window.api.refreshUILanguage({ language: selectedLang, configName });

          if (configName) {
            await buildMainAchievementsTable(configName, selectedLang);
          }

          localStorage.setItem("preferredLanguage", selectedLang);
        });

      const savedLang = localStorage.getItem("preferredLanguage") || "english";
      document.getElementById("languageSelect").value = savedLang;
      function getLocalizedText(obj, lang = "english") {
        if (!obj) return "";
        if (typeof obj === "string") return obj;
        return obj[lang] || obj["english"] || "";
      }

      const presetDropdown = document.getElementById("presetDropdown");
      const positionDropdown = document.getElementById("positionDropdown");
      const configList = document.getElementById("configList");
      const deleteConfigBtn = document.getElementById("deleteConfigBtn");
      const editConfigBtn = document.getElementById("editConfigBtn");
      const backButton = document.getElementById("backButton");
      const blacklistConfigBtn = document.getElementById("blacklistConfigBtn");
      const showBlacklistedCheckbox = document.getElementById(
        "settings-showBlacklistedCheckbox"
      );
      const resetBlacklistBtn = document.getElementById(
        "settings-resetBlacklistBtn"
      );

      const configMetaIndex = new Map();
      const blacklistState = {
        appids: new Set(),
        showBlacklisted: false,
      };
      let lastSelectedConfigMeta = null;

      function normalizeConfigEntry(entry) {
        if (!entry) return null;
        if (typeof entry === "string") {
          return {
            name: entry,
            displayName: entry,
            appid: null,
            blacklisted: false,
          };
        }
        const name = entry.name || entry.configName || "";
        if (!name) return null;
        return {
          name,
          displayName:
            entry.displayName || entry.title || entry.name || entry.configName,
          appid: entry.appid ? String(entry.appid) : null,
          blacklisted: !!entry.blacklisted,
        };
      }

      function normalizeConfigList(list) {
        return Array.isArray(list)
          ? list
              .map((item) => normalizeConfigEntry(item))
              .filter((item) => item && item.name)
          : [];
      }

      function cacheConfigMeta(list) {
        configMetaIndex.clear();
        list.forEach((cfg) => {
          if (cfg && cfg.name) {
            configMetaIndex.set(cfg.name, cfg);
          }
        });
      }

      function isAppIdInBlacklist(appid) {
        if (!appid) return false;
        return blacklistState.appids.has(String(appid));
      }

      async function syncBlacklistList() {
        try {
          const res = await window.api.getBlacklist();
          blacklistState.appids = new Set(res?.appids || []);
        } catch (err) {
          console.warn("Failed to load blacklist:", err);
          blacklistState.appids = new Set();
        }
      }

      function resolveBlacklistName(appid) {
        if (!appid) return null;
        // Prefer cached meta by appid
        for (const meta of configMetaIndex.values()) {
          if (!meta?.appid) continue;
          if (String(meta.appid) === String(appid)) {
            return (
              meta.displayName ||
              meta.name ||
              meta.appid ||
              meta.appId ||
              `App ${appid}`
            );
          }
        }
        if (
          lastSelectedConfigMeta &&
          String(lastSelectedConfigMeta.appid || "") === String(appid || "")
        ) {
          return (
            lastSelectedConfigMeta.displayName ||
            lastSelectedConfigMeta.name ||
            `App ${appid}`
          );
        }
        return null;
      }

      async function renderBlacklistList() {
        const listEl = document.getElementById("blacklistList");
        if (!listEl) return;
        listEl.innerHTML = "";

        const entries = Array.from(blacklistState.appids || []);
        if (entries.length === 0) {
          listEl.innerHTML =
            '<div style="padding:10px; color:#aaa;"><small>No blacklisted apps.</small></div>';
          return;
        }

        // Build a map appid -> displayName from cached configs
        const nameById = new Map();
        configMetaIndex.forEach((cfg) => {
          if (cfg?.appid) {
            const id = String(cfg.appid);
            const name =
              cfg.displayName ||
              cfg.name ||
              cfg.appid ||
              cfg.appId ||
              `App ${id}`;
            nameById.set(id, name);
          }
        });

        for (const appid of entries) {
          const row = document.createElement("div");
          row.className = "wf-row";
          row.setAttribute("role", "listitem");
          row.dataset.appid = appid;

          const pathEl = document.createElement("div");
          pathEl.className = "wf-path";
          const cachedLabel = blacklistLabelCache.get(appid);
          const label =
            cachedLabel ||
            nameById.get(appid) ||
            resolveBlacklistName(appid) ||
            `App ${appid}`;
          pathEl.textContent = `${appid} ‚Äî ${label}`;
          pathEl.title = pathEl.textContent;

          const actions = document.createElement("div");
          actions.className = "wf-actions";

          const btnRemove = document.createElement("button");
          btnRemove.className = "icon-btn remove";
          btnRemove.title = "Remove from blacklist";
          btnRemove.innerHTML = '<i class="fa-regular fa-trash-can"></i>';
          btnRemove.addEventListener("click", async () => {
            try {
              await window.api.blacklistConfig({
                appid,
                remove: true,
              });
              await syncBlacklistList();
              renderBlacklistList();
              await reloadConfigsDropdown(true);
              if (typeof buildDashboard === "function") {
                await buildDashboard();
              }
            } catch (err) {
              console.error("Failed to remove from blacklist:", err);
              alert("Failed to remove this AppID from blacklist.");
            }
          });

          actions.appendChild(btnRemove);
          row.appendChild(pathEl);
          row.appendChild(actions);
          listEl.appendChild(row);

          // Async resolve label from config if missing
          if (
            !cachedLabel &&
            (!nameById.has(appid) || label === `App ${appid}`)
          ) {
            (async () => {
              try {
                const res = await window.api.getConfigByAppId(appid);
                const fetchedLabel =
                  res?.displayName || res?.name || `App ${appid}`;
                blacklistLabelCache.set(appid, fetchedLabel);
                const currentRow = listEl.querySelector(
                  `.wf-row[data-appid="${appid}"] .wf-path`
                );
                if (currentRow) {
                  currentRow.textContent = `${appid} ‚Äî ${fetchedLabel}`;
                  currentRow.title = currentRow.textContent;
                }
              } catch {}
            })();
          }
        }
      }

      function applyShowBlacklistPreference(value) {
        const next = !!value;
        blacklistState.showBlacklisted = next;
        if (showBlacklistedCheckbox) {
          showBlacklistedCheckbox.checked = next;
        }
        renderBlacklistList();
      }

      function updateBlacklistButtonState(appid) {
        if (!blacklistConfigBtn) return;
        if (!appid) {
          blacklistConfigBtn.disabled = true;
          blacklistConfigBtn.textContent = "Ignore Game";
          return;
        }
        blacklistConfigBtn.disabled = false;
        const isBlacklisted = isAppIdInBlacklist(appid);
        if (blacklistState.showBlacklisted && isBlacklisted) {
          blacklistConfigBtn.textContent = "Remove from Blacklist";
        } else {
          blacklistConfigBtn.textContent = "Ignore Game";
        }
      }

      function updateMainConfig() {
        const selectedConfig = configList.value;
        const preset = presetDropdown.value;
        const position = positionDropdown.value;

        if (selectedConfig) {
          window.api.updateConfig({
            configName: selectedConfig,
            preset: preset,
            position: position,
          });
        }
      }

      presetDropdown.addEventListener("change", updateMainConfig);

      positionDropdown.addEventListener("change", updateMainConfig);

      configList.addEventListener("change", updateMainConfig);

      function getSafeLocalizedText(input, lang = "english") {
        if (!input) return "Hidden";
        if (typeof input === "string") return input.trim() || "Hidden";
        if (typeof input === "object") {
          return (
            input[lang] ||
            input.english ||
            Object.values(input).find(
              (v) => typeof v === "string" && v.trim() !== ""
            ) ||
            "Hidden"
          );
        }
        return "Hidden";
      }

      window.addEventListener("DOMContentLoaded", async () => {
        try {
          await syncBlacklistList();
          const configsRaw = await window.api.loadConfigs();
          const configs = normalizeConfigList(configsRaw);
          cacheConfigMeta(configs);
          rememberCoverNamesFromList(configs);
          const configList = document.getElementById("configList");
          if (configList) {
            configList.innerHTML =
              '<option value="" disabled selected>Select</option>';
            const visibleConfigs = blacklistState.showBlacklisted
              ? configs
              : configs.filter((cfg) => !isAppIdInBlacklist(cfg.appid));
            visibleConfigs.forEach((config) => {
              const option = document.createElement("option");
              option.value = config.name;
              option.textContent = config.displayName || config.name;
              if (isAppIdInBlacklist(config.appid)) {
                option.textContent += " (Ignored)";
              }
              configList.appendChild(option);
            });
          }
        } catch (error) {
          console.error("Config Load Error:", error);
        }

        function formatTimestamp(timestamp) {
          if (!timestamp) return "N/A";
          const date = new Date(timestamp * 1000);
          return date.toLocaleString();
        }

        configList.addEventListener("change", async () => {
          const selectedConfig = configList.value;
          const cachedMeta = configMetaIndex.get(selectedConfig) || null;
          const blocked =
            !!cachedMeta?.appid &&
            blacklistState.appids.has(String(cachedMeta.appid));

          updateBlacklistButtonState(cachedMeta?.appid || null);

          if (selectedConfig && !blocked) {
            window.api.updateConfig({
              configName: selectedConfig,
              preset: presetDropdown.value,
              position: positionDropdown.value,
            });
          }
          const achievementsDataObj = await window.api.loadAchievementData(
            selectedConfig
          );
          const savedAchievementsObj = await window.api.loadSavedAchievements(
            selectedConfig
          );
          const currentConfig = await window.api.getConfigByName(
            selectedConfig
          );
          maybeRequestPlatinum(
            currentConfig,
            achievementsDataObj?.achievements || [],
            savedAchievementsObj
          );
          lastSelectedConfigMeta = currentConfig || null;
          updateBlacklistButtonState(currentConfig?.appid || null);
          if (currentConfig?.appid) {
            const resolvedName =
              currentConfig.displayName ||
              currentConfig.name ||
              currentConfig.appid;
            rememberCoverName(currentConfig.appid, resolvedName);
            window.__showFallbackLogo?.();
            window
              .__applyEmbeddedGameImageForAppId(currentConfig.appid)
              ?.catch(() => {});
          } else {
            window.__showFallbackLogo?.();
          }
          const playBtn = document.getElementById("playBtn");
          if (playBtn)
            playBtn.style.display = currentConfig?.executable
              ? "inline-block"
              : "none";

          const tableBody = document.querySelector("#achievementsTableBody");
          if (tableBody) {
            tableBody.innerHTML = "";
          } else {
            console.error("tableBody could not be found.");
            return;
          }

          if (achievementsDataObj.error) {
            alert(achievementsDataObj.error);
            return;
          }

          if (!Array.isArray(achievementsDataObj.achievements)) {
            if (achievementsDataObj.achievements == null) {
              const achStats = document.getElementById("achStats");
              if (achStats) achStats.style.display = "none";
              const playtimeLabel = document.getElementById("achStatsPlaytime");
              if (playtimeLabel) playtimeLabel.textContent = "Playtime: 0m";
              return;
            }
            console.warn(
              "Achievements payload is not an array; skipping table render."
            );
            return;
          }

          const lang = document.getElementById("languageSelect").value;
          await buildMainAchievementsTable(selectedConfig, lang);

          const statsArray = achievementsDataObj.achievements.map((a) => {
            const saved = savedAchievementsObj?.achievements?.[a.name];
            return { ...a, earned: !!saved?.earned };
          });
          updateAchievementStats(statsArray);
          const achStatsEl = document.getElementById("achStats");
          if (achStatsEl) achStatsEl.style.display = "block";
        });
      });

      window.addEventListener("DOMContentLoaded", async () => {
        try {
          const presetsData = await window.api.loadPresets();
          const presetDropdown = document.getElementById("presetDropdown");
          presetDropdown.innerHTML = "";

          // Create category for presets that support scaling above 100%
          const highScalingGroup = document.createElement("optgroup");
          highScalingGroup.label = "‚≠ê Supports 200% Scaling";

          // Create category for regular presets
          const regularGroup = document.createElement("optgroup");
          regularGroup.label = "Standard Presets (100% Max)";

          // Check if we have the new structured format or old format
          if (presetsData.isStructured) {
            // Handle new structured format with separate folders

            // Add scalable presets
            presetsData.scalable.forEach((preset) => {
              const option = document.createElement("option");
              option.value = preset;
              option.textContent = preset;
              highScalingGroup.appendChild(option);
            });

            // Add non-scalable presets
            presetsData.nonScalable.forEach((preset) => {
              const option = document.createElement("option");
              option.value = preset;
              option.textContent = preset;
              regularGroup.appendChild(option);
            });
          } else {
            // Handle old format for backwards compatibility
            presetsData.forEach((preset) => {
              const option = document.createElement("option");
              option.value = preset;
              option.textContent = preset;

              // Add presets to their appropriate groups using the old logic
              if (
                preset === "Modern" ||
                preset === "xqjan" ||
                preset === "Neon Future"
              ) {
                highScalingGroup.appendChild(option);
              } else {
                regularGroup.appendChild(option);
              }
            });
          }

          // Add groups to dropdown with enhanced scaling options first
          presetDropdown.appendChild(highScalingGroup);
          presetDropdown.appendChild(regularGroup);
        } catch (error) {
          console.error("Error loading presets:", error);
        }
      });

      document.addEventListener("DOMContentLoaded", function () {
        const testButton = document.getElementById("testAchievementBtn");
        const configList = document.getElementById("configList");
        const presetDropdown = document.getElementById("presetDropdown");
        const positionDropdown = document.getElementById("positionDropdown");

        let position = positionDropdown.value;

        positionDropdown.addEventListener("change", function () {
          position = positionDropdown.value;
        });

        testButton.addEventListener("click", async function () {
          const preset = presetDropdown.value || "default";
          const position = positionDropdown.value;
          const sound = document.getElementById("soundSelect").value;
          const scale = parseFloat(
            document.getElementById("scaleSlider").value
          );

          window.api.showTestNotification({
            preset,
            position,
            sound,
            scale,
          });
        });
      });
      document.addEventListener("DOMContentLoaded", async function () {
        async function loadConfigs() {
          try {
            await reloadConfigsDropdown(true);
          } catch (error) {
            console.error("Config Load Error:", error);
          }
        }
        configList.addEventListener("change", function () {
          if (deleteConfigBtn) {
            deleteConfigBtn.style.display = configList.value
              ? "inline-block"
              : "none";
          }
          if (blacklistConfigBtn) {
            blacklistConfigBtn.style.display = configList.value
              ? "inline-block"
              : "none";
          }
          if (!configList.value) {
            lastSelectedConfigMeta = null;
            updateBlacklistButtonState(null);
          }
        });

        deleteConfigBtn.addEventListener("click", async function () {
          const selectedConfig = configList.value;
          if (!selectedConfig) return;

          const confirmDelete = await window.ui.confirm({
            title: "Delete config",
            message: `Do you want to delete: ${selectedConfig}?`,
          });
          if (!confirmDelete) return;

          await window.ui.refocus();

          try {
            const response = await window.api.deleteConfig(selectedConfig);
            if (response.success) {
              await loadConfigs();
              const configList = document.getElementById("configList");
              configList.value = "";
              document.getElementById("backButton").style.display = "none";

              const selectOption = configList.querySelector('option[value=""]');
              if (selectOption) {
                selectOption.selected = true;
                selectOption.disabled = true;
              }

              document.getElementById("deleteConfigBtn").style.display = "none";
              document.getElementById("blacklistConfigBtn").style.display =
                "none";
              document.getElementById("editConfigBtn").style.display = "none";
              document.getElementById("playBtn").style.display = "none";
              document.getElementById("achStats").style.display = "none";
              resetConfigForm();

              const tableBody = document.getElementById(
                "achievementsTableBody"
              );
              if (tableBody) tableBody.innerHTML = "";

              window.api.updateConfig({
                configName: null,
                preset: null,
                position: null,
              });
              window.api.toggleOverlay(null);
              window.api.onLoadOverlayData(null);
              window.__showFallbackLogo?.();
            } else {
              console.error("Error on delete:", response.error);
            }
          } catch (error) {
            console.error("Error on delete:", error);
          }
        });
        blacklistConfigBtn.addEventListener("click", async () => {
          const selectedConfig = configList.value;
          if (!selectedConfig) return;
          const configMeta =
            lastSelectedConfigMeta ||
            (await window.api.getConfigByName(selectedConfig));
          const targetAppId = configMeta?.appid
            ? String(configMeta.appid)
            : null;
          if (!targetAppId) {
            alert("Missing AppID for this configuration.");
            return;
          }

          const currentlyBlacklisted = isAppIdInBlacklist(targetAppId);
          const removeMode =
            blacklistState.showBlacklisted && currentlyBlacklisted;

          const confirmed = await window.ui.confirm({
            title: removeMode ? "Remove from blacklist" : "Add to blacklist",
            message: removeMode
              ? `Remove ${selectedConfig} from blacklist?`
              : `Ignore ${selectedConfig} and stop tracking it?`,
          });
          if (!confirmed) return;

          await window.ui.refocus();

          const response = await window.api.blacklistConfig({
            configName: selectedConfig,
            appid: targetAppId,
            remove: removeMode,
          });
          if (!response?.success) {
            alert(response?.error || "Failed to update blacklist");
            return;
          }

          if (Array.isArray(response.blacklist)) {
            blacklistState.appids = new Set(response.blacklist);
          } else {
            await syncBlacklistList();
          }
          renderBlacklistList();

          await reloadConfigsDropdown(true);
          if (!blacklistState.showBlacklisted) {
            configList.value = "";
            [
              "deleteConfigBtn",
              "blacklistConfigBtn",
              "editConfigBtn",
              "playBtn",
            ].forEach((id) => {
              const el = document.getElementById(id);
              if (el) el.style.display = "none";
            });
            document.getElementById("backButton").style.display = "none";
            window.__showFallbackLogo?.();
          } else {
            configList.dispatchEvent(new Event("change", { bubbles: true }));
          }

          if (typeof buildDashboard === "function") {
            await buildDashboard();
          }
        });
      });

      if (showBlacklistedCheckbox) {
        showBlacklistedCheckbox.addEventListener("change", async (e) => {
          const next = !!e.target.checked;
          try {
            await window.api.savePreferences({
              showBlacklistedGames: next,
            });
            applyShowBlacklistPreference(next);
            await reloadConfigsDropdown(true);
            if (typeof buildDashboard === "function") {
              await buildDashboard();
            }
            await syncBlacklistList();
            renderBlacklistList();
          } catch (err) {
            console.error("Failed to toggle blacklist visibility:", err);
            alert("Failed to update blacklist visibility setting.");
            e.target.checked = !next;
          }
        });
      }

      if (resetBlacklistBtn) {
        resetBlacklistBtn.addEventListener("click", async () => {
          const confirmed = await window.ui.confirm({
            title: "Reset blacklist",
            message: "Remove all blacklisted games?",
          });
          if (!confirmed) return;

          await window.ui.refocus();
          try {
            await window.api.resetBlacklist();
            await syncBlacklistList();
            renderBlacklistList();
            await reloadConfigsDropdown(true);
            if (typeof buildDashboard === "function") {
              await buildDashboard();
            }
          } catch (err) {
            console.error("Failed to reset blacklist:", err);
            alert(err?.message || "Failed to reset blacklist");
          }
        });
      }

      //Dashboard
      function enableDashboardHoverSync() {
        const grid = document.getElementById("dashboardGrid");
        if (!grid || grid.__hoverSyncBound) return;
        grid.__hoverSyncBound = true;

        let raf = 0;
        let lastCard = null;
        const search = document.getElementById("dashboardSearchInput");

        const activateFromHover = (card) => {
          if (!card || card === lastCard) return;
          lastCard = card;

          const name = card.getAttribute("data-name") || "";
          setActiveCard(name);

          try {
            const cards = getDashCards(false);
            __dashNav.index = Math.max(0, cards.indexOf(card));
          } catch {}

          try {
            getDashCards(false).forEach((c) =>
              c.querySelector(".dash-play")?.classList.remove("force-show")
            );
            card.querySelector(".dash-play")?.classList.add("force-show");
          } catch {}

          const searchFocused = document.activeElement === search;
          const shouldFocus =
            !searchFocused && !isSettingsOpen() && window.__dashboardOpen;

          if (shouldFocus && document.activeElement !== card) {
            card.focus({ preventScroll: true });
          }
        };

        grid.addEventListener("pointerover", (e) => {
          if (!window.__dashboardOpen || e.pointerType === "touch" || e.buttons)
            return;

          const card = e.target.closest(".dash-card");
          if (!card || !grid.contains(card)) return;

          cancelAnimationFrame(raf);
          raf = requestAnimationFrame(() => activateFromHover(card));
        });
      }

      (function () {
        const seen = new Set();

        window.api.onAchievementsMissing((payload) => {
          if (window.__dashboardOpen) return;

          const data =
            payload && typeof payload === "object"
              ? payload
              : { configName: String(payload || ""), reason: "" };

          const { configName, reason } = data || {};

          const selected = document.getElementById("configList")?.value || "";
          if (!selected || selected !== configName) return;

          const key = `${reason}|${configName}`;
          if (seen.has(key)) return;
          seen.add(key);
          setTimeout(() => seen.delete(key), 4000);

          let msg = "";
          switch (reason) {
            case "no-config-path":
              msg = `‚ö†Ô∏è Config path is missing for "${configName}". Generate of Select steam_settings in order to see the achievements.`;
              break;
            case "no-file":
              msg = `‚ö†Ô∏è Achievements missing for "${configName}" (achievements.json not found config path).`;
              break;
            case "no-save-path":
              msg = `‚ö†Ô∏è Save path is missing for "${configName}". Achievements will not be tracked.`;
              break;
            default:
              msg = `‚ö†Ô∏è Achievements missing for "${configName}".`;
          }
          showNotification(msg, "#FFC107");
        });
      })();

      document
        .getElementById("backButton")
        .addEventListener("click", async () => {
          const configList = document.getElementById("configList");
          const backButton = document.getElementById("backButton");

          // 1) reset UI + state
          if (configList) configList.value = "";
          if (backButton) {
            backButton.classList.add("hidden");
            backButton.style.display = "none";
          }
          const selectOption = configList?.querySelector?.('option[value=""]');
          if (selectOption) {
            selectOption.selected = true;
            selectOption.disabled = true;
          }

          const hide = (id) => {
            const el = document.getElementById(id);
            if (el) el.style.display = "none";
          };
          hide("deleteConfigBtn");
          hide("editConfigBtn");
          hide("playBtn");
          hide("achStats");
          hide("blacklistConfigBtn");
          const tableBody = document.getElementById("achievementsTableBody");
          if (tableBody) tableBody.innerHTML = "";

          try {
            window.api.updateConfig({
              configName: null,
              preset: null,
              position: null,
            });
            window.api.toggleOverlay(null);
            window.api.onLoadOverlayData(null);
          } catch {}

          window.__showFallbackLogo?.();

          try {
            await loadPreferencesCached();
            const prefs = getCachedPreferences();
            if (prefs?.showDashboardOnStart) {
              await window.openDashboard?.();
            }
          } catch (e) {
            console.warn("Cannot open Dashboard after Back:", e);
          }
        });

      window.api.onToggleOverlayShortcut(() => {
        const selectedConfig = document.getElementById("configList").value;
        if (!selectedConfig) {
          alert("Select a config!");
          return;
        }
        window.api.toggleOverlay(selectedConfig);
      });

      configList.addEventListener("change", () => {
        if (!configList.value) return;

        if (backButton) {
          backButton.classList.remove("hidden");
          backButton.style.display = "inline-block";
        }
        if (deleteConfigBtn) deleteConfigBtn.style.display = "inline-block";
        if (editConfigBtn) editConfigBtn.style.display = "inline-block";
        if (blacklistConfigBtn)
          blacklistConfigBtn.style.display = "inline-block";
        resetConfigForm();
      });

      window.onload = async () => {
        const soundSelect = document.getElementById("soundSelect");

        try {
          await loadPreferencesCached();

          const prefs = getCachedPreferences();

          const sounds = await window.api.getSounds();

          const muteOption = document.createElement("option");

          muteOption.value = "mute";

          muteOption.textContent = "üîá Mute";

          soundSelect.appendChild(muteOption);

          sounds.forEach((sound) => {
            const option = document.createElement("option");

            option.value = sound;

            option.textContent = sound;

            soundSelect.appendChild(option);
          });

          renderSteamApiKeyStatusFromPrefs(prefs);

          if (
            prefs &&
            prefs.sound &&
            soundSelect.querySelector(`option[value="${prefs.sound}"]`)
          ) {
            soundSelect.value = prefs.sound;
          }

          if (prefs.disableProgress !== undefined) {
            document.getElementById("disableProgressCheckbox").checked =
              prefs.disableProgress;
          }

          if (prefs.disablePlaytime !== undefined) {
            const cb = document.getElementById(
              "settings-disablePlaytimeCheckbox"
            );

            if (cb) cb.checked = !!prefs.disablePlaytime;
          }

          if (typeof window.api.disableProgress === "function") {
            window.api.disableProgress(!!prefs?.disableProgress);
          }

          if (typeof window.api.setDisablePlaytime === "function") {
            window.api.setDisablePlaytime(!!prefs?.disablePlaytime);
          }
        } catch (err) {
          console.error("Sound Load Error:", err);
        }
      };

      window.api.onPlaySound(async (soundName) => {
        if (soundName && soundName !== "mute") {
          await playCustomSound(soundName);
        }
      });

      if (window.api?.on) {
        window.api.on("blacklist:updated", async (_evt, payload) => {
          try {
            await syncBlacklistList();
            renderBlacklistList();
            if (payload?.appids) {
              blacklistState.appids = new Set(payload.appids);
            }
          } catch (err) {
            console.warn("Blacklist update handling failed:", err);
          }
        });
      }

      function playSelectedSound() {
        const soundSelect = document.getElementById("soundSelect");
        const selectedSound = soundSelect?.value;

        if (!selectedSound || selectedSound === "mute") return;

        const audio = new Audio(`sounds/${selectedSound}`);
        audio.play().catch((err) => {
          console.error("‚ö†Ô∏è Sound play error:", err);
        });
      }

      async function playCustomSound(fileName) {
        if (!fileName || fileName === "mute") return;

        try {
          const fullPath = await window.api.getSoundFullPath(fileName);
          const audio = new Audio(fullPath);
          audio.play().catch((err) => {
            console.error("‚ö†Ô∏è Custom sound play error:", err);
          });
        } catch (err) {
          console.error("‚ùå Failed to load sound path:", err);
        }
      }

      async function loadPreferences() {
        await loadPreferencesCached();
        const prefs = getCachedPreferences();
        renderSteamApiKeyStatusFromPrefs(prefs);
        applyShowBlacklistPreference(prefs?.showBlacklistedGames);
        await syncBlacklistList();
        renderBlacklistList();

        if (prefs.position)
          document.getElementById("positionDropdown").value = prefs.position;
        const settingsPositionDropdown = document.getElementById(
          "settings-positionDropdown"
        );
        if (settingsPositionDropdown && prefs.position) {
          settingsPositionDropdown.value = prefs.position;
        }
        if (prefs.preset)
          document.getElementById("presetDropdown").value = prefs.preset;
        const settingsPresetDropdown = document.getElementById(
          "settings-presetDropdown"
        );
        if (settingsPresetDropdown && prefs.preset) {
          settingsPresetDropdown.value = prefs.preset;
        }
        if (prefs.sound)
          document.getElementById("soundSelect").value = prefs.sound;
        const settingsSoundSelect = document.getElementById(
          "settings-soundSelect"
        );
        if (settingsSoundSelect && prefs.sound) {
          settingsSoundSelect.value = prefs.sound;
        }
        if (prefs.notificationScale) {
          const scaleSlider = document.getElementById("scaleSlider");
          scaleSlider.value = prefs.notificationScale;
          updateScaleLabel();
          const settingsScaleSlider = document.getElementById(
            "settings-scaleSlider"
          );
          if (settingsScaleSlider) {
            settingsScaleSlider.value = prefs.notificationScale;
            updateSettingsScaleLabel();
          }
        }
        const hiddenPlatPos = document.getElementById("platinumPositionValue");
        if (prefs.platinumPosition) {
          const el = document.getElementById(
            "settings-platinumPositionDropdown"
          );
          if (el) el.value = prefs.platinumPosition;
        }
        if (hiddenPlatPos) {
          hiddenPlatPos.value =
            prefs.platinumPosition ||
            hiddenPlatPos.value ||
            prefs.position ||
            "center-bottom";
        }
        const hiddenPlatPreset = document.getElementById("platinumPresetValue");
        if (prefs.platinumPreset) {
          const el = document.getElementById("settings-platinumPresetDropdown");
          if (el) el.value = prefs.platinumPreset;
        }
        if (hiddenPlatPreset) {
          hiddenPlatPreset.value =
            prefs.platinumPreset ||
            hiddenPlatPreset.value ||
            prefs.preset ||
            "default";
        }
        const hiddenPlatSound = document.getElementById("platinumSoundValue");
        if (prefs.platinumSound) {
          const el = document.getElementById("settings-platinumSoundSelect");
          if (el) el.value = prefs.platinumSound;
        }
        if (hiddenPlatSound) {
          hiddenPlatSound.value =
            prefs.platinumSound ||
            hiddenPlatSound.value ||
            prefs.sound ||
            "mute";
        }
        if (prefs.disableProgress !== undefined) {
          const cb = document.getElementById("disableProgressCheckbox");
          if (cb) cb.checked = prefs.disableProgress;
        }
        if (prefs.disablePlaytime !== undefined) {
          const cb = document.getElementById(
            "settings-disablePlaytimeCheckbox"
          );
          if (cb) cb.checked = prefs.disablePlaytime;
        }

        if (prefs.windowZoomFactor) {
          const zoomDropdown = document.getElementById("app-zoom-dropdown");
          if (zoomDropdown) {
            zoomDropdown.value = prefs.windowZoomFactor.toString();
            document.body.dataset.zoom = String(
              Math.round((prefs.windowZoomFactor || 1) * 100)
            );
            window.api.setZoom(prefs.windowZoomFactor);
          }
        }
        if (prefs.disablePlatinum !== undefined) {
          const cb = document.getElementById(
            "settings-disablePlatinumCheckbox"
          );
          if (cb) cb.checked = prefs.disablePlatinum;
        }
        if (prefs.overlayShortcut) {
          document.getElementById("overlay-shortcut-btn").textContent =
            prefs.overlayShortcut;
        }
      }

      window.addEventListener("DOMContentLoaded", async () => {
        try {
          await loadPreferencesCached();
          const prefs = getCachedPreferences();
          renderSteamApiKeyStatusFromPrefs(prefs);
          applyShowBlacklistPreference(prefs?.showBlacklistedGames);
          if (prefs) {
            if (prefs.position)
              document.getElementById("positionDropdown").value =
                prefs.position;
            const settingsPositionDropdown = document.getElementById(
              "settings-positionDropdown"
            );
            if (settingsPositionDropdown && prefs.position) {
              settingsPositionDropdown.value = prefs.position;
            }
            if (prefs.preset)
              document.getElementById("presetDropdown").value = prefs.preset;
            const settingsPresetDropdown = document.getElementById(
              "settings-presetDropdown"
            );
            if (settingsPresetDropdown && prefs.preset) {
              settingsPresetDropdown.value = prefs.preset;
            }
            if (prefs.sound)
              document.getElementById("soundSelect").value = prefs.sound;
            const settingsSoundSelect = document.getElementById(
              "settings-soundSelect"
            );
            if (settingsSoundSelect && prefs.sound) {
              settingsSoundSelect.value = prefs.sound;
            }
            if (prefs.notificationScale) {
              const scaleSlider = document.getElementById("scaleSlider");
              scaleSlider.value = prefs.notificationScale;
              updateScaleLabel();
              const settingsScaleSlider = document.getElementById(
                "settings-scaleSlider"
              );
              if (settingsScaleSlider) {
                settingsScaleSlider.value = prefs.notificationScale;
                updateSettingsScaleLabel();
              }
            }
            const hiddenPlatPos = document.getElementById(
              "platinumPositionValue"
            );
            if (prefs.platinumPosition) {
              const el = document.getElementById(
                "settings-platinumPositionDropdown"
              );
              if (el) el.value = prefs.platinumPosition;
            }
            if (hiddenPlatPos) {
              hiddenPlatPos.value =
                prefs.platinumPosition ||
                hiddenPlatPos.value ||
                prefs.position ||
                "center-bottom";
            }
            const hiddenPlatPreset = document.getElementById(
              "platinumPresetValue"
            );
            if (prefs.platinumPreset) {
              const el = document.getElementById(
                "settings-platinumPresetDropdown"
              );
              if (el) el.value = prefs.platinumPreset;
            }
            if (hiddenPlatPreset) {
              hiddenPlatPreset.value =
                prefs.platinumPreset ||
                hiddenPlatPreset.value ||
                prefs.preset ||
                "default";
            }
            const hiddenPlatSound =
              document.getElementById("platinumSoundValue");
            if (prefs.platinumSound) {
              const el = document.getElementById(
                "settings-platinumSoundSelect"
              );
              if (el) el.value = prefs.platinumSound;
            }
            if (hiddenPlatSound) {
              hiddenPlatSound.value =
                prefs.platinumSound ||
                hiddenPlatSound.value ||
                prefs.sound ||
                "mute";
            }
            if (prefs.disableProgress !== undefined) {
              const cb = document.getElementById("disableProgressCheckbox");
              if (cb) cb.checked = prefs.disableProgress;
            }

            if (prefs.disablePlaytime !== undefined) {
              const cb1 = document.getElementById(
                "settings-disablePlaytimeCheckbox"
              );
              if (cb1) cb1.checked = prefs.disablePlaytime;
            }
            if (prefs.disablePlatinum !== undefined) {
              const cb = document.getElementById(
                "settings-disablePlatinumCheckbox"
              );
              if (cb) cb.checked = prefs.disablePlatinum;
            }

            if (prefs.windowZoomFactor) {
              const zoomDropdown = document.getElementById("app-zoom-dropdown");
              if (zoomDropdown) {
                zoomDropdown.value = prefs.windowZoomFactor.toString();
                document.body.dataset.zoom = String(
                  Math.round((prefs.windowZoomFactor || 1) * 100)
                );
                window.api.setZoom(prefs.windowZoomFactor);
              }
            }
            if (prefs?.overlayShortcut) {
              document.getElementById("overlay-shortcut-btn").textContent =
                prefs.overlayShortcut;
            } else {
              document.getElementById("overlay-shortcut-btn").textContent =
                "Set Shortcut";
            }

            const ssInput = document.getElementById(
              "settings-screenshotFolder"
            );
            const ssButton = document.getElementById(
              "settings-selectScreenshotFolder"
            );
            if (ssInput) {
              ssInput.value = prefs?.screenshotFolder || "";
            }
            if (ssButton) {
              ssButton.addEventListener("click", async () => {
                const dir = await window.api.selectFolder();
                if (dir) {
                  ssInput.value = dir;
                  await window.api.savePreferences({ screenshotFolder: dir });
                  console.log("üìÅ Screenshot folder set to:", dir);
                }
              });
            }

            const dsCb = document.getElementById(
              "settings-disableScreenshotCheckbox"
            );
            if (dsCb) {
              dsCb.checked = !!(prefs && prefs.disableAchievementScreenshot);
              dsCb.addEventListener("change", async (e) => {
                await window.api.savePreferences({
                  disableAchievementScreenshot: e.target.checked,
                });
              });
            }
          }

          const steamApiKeyInput = document.getElementById(
            "settings-steamApiKeyInput"
          );
          const steamApiKeySaveBtn = document.getElementById(
            "settings-steamApiKeySave"
          );
          const steamApiKeyClearBtn = document.getElementById(
            "settings-steamApiKeyClear"
          );

          steamApiKeySaveBtn.addEventListener("click", async () => {
            const input = document.getElementById("settings-steamApiKeyInput");
            if (!input) return;
            const raw = input.value.trim();
            if (!raw || raw === input.placeholder) return;

            try {
              await window.api.savePreferences({ steamApiKey: raw });
              await refreshSteamApiKeyStatus();
              console.log("Steam API key saved.");
            } catch (err) {
              console.error("Steam API key save error:", err);
            }
          });

          if (steamApiKeyClearBtn) {
            steamApiKeyClearBtn.addEventListener("click", async () => {
              const confirmed = window.confirm(
                "Remove the stored Steam API key?"
              );
              if (!confirmed) return;
              try {
                await window.api.savePreferences({ steamApiKey: "" });
                if (steamApiKeyInput) steamApiKeyInput.value = "";
                await refreshSteamApiKeyStatus();
              } catch (err) {
                console.error("Steam API key clear error:", err);
              }
            });
          }
        } catch (e) {
          console.warn("Settings cannot be load:", e);
        }
      });

      window.addEventListener("DOMContentLoaded", async () => {
        await loadPreferencesCached();
        const prefs = getCachedPreferences();
        renderSteamApiKeyStatusFromPrefs(prefs);
        const startMaxEl = document.getElementById(
          "settings-startMaximizedCheckbox"
        );
        if (startMaxEl) {
          startMaxEl.checked = !!prefs.startMaximized;
          startMaxEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({
              startMaximized: e.target.checked,
            });
            console.log(
              e.target.checked
                ? "App will start maximized"
                : "App will not force maximize on startup"
            );
          });
        }
        const startInTrayEl = document.getElementById(
          "settings-startInTrayCheckbox"
        );
        if (startInTrayEl) {
          startInTrayEl.checked = !!prefs.startInTray;
          startInTrayEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({ startInTray: e.target.checked });
            console.log(
              e.target.checked
                ? "App will start in tray"
                : "App will show on startup"
            );
          });
        }

        const startWindowsEl = document.getElementById(
          "settings-startWindowsCheckbox"
        );
        if (startWindowsEl) {
          let initial = await window.api
            .getStartWithWindows()
            .catch(() => null);
          if (initial === null) initial = !!prefs.startWithWindows;
          startWindowsEl.checked = initial;
          startWindowsEl.addEventListener("change", (e) =>
            handleStartWithWindowsToggle(e.target.checked)
          );
        }

        const showHiddenDescEl = document.getElementById(
          "settings-showHiddenDescription"
        );
        if (showHiddenDescEl) {
          showHiddenDescEl.checked = !!prefs.showHiddenDescription;
          showHiddenDescEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({
              showHiddenDescription: e.target.checked,
            });
            await loadPreferencesCached().catch(() => {});
            const cfg = document.getElementById("configList")?.value;
            const lang =
              document.getElementById("languageSelect")?.value || "english";
            if (cfg) {
              try {
                await buildMainAchievementsTable(cfg, lang);
              } catch {}
            }
          });
        }

        const showDashEl = document.getElementById(
          "settings-showDashboardOnStartCheckbox"
        );
        if (showDashEl) {
          showDashEl.checked = !!prefs.showDashboardOnStart;
          showDashEl.addEventListener("change", async (e) => {
            await window.api.savePreferences({
              showDashboardOnStart: e.target.checked,
            });
            console.log(
              e.target.checked
                ? "Dashboard will show on launch"
                : "Dashboard will not show on launch"
            );
          });
        }

        if (prefs.showDashboardOnStart) {
          const btn = document.getElementById("toggleDashboardBtn");
          setTimeout(() => btn?.click(), 0);
        }
      });
      window.api.onPlaytimeUpdate?.((payload = {}) => {
        const activeRaw = document.getElementById("configList")?.value || "";
        const activeSafe = sanitizeConfigName(activeRaw);
        const payloadSafe = sanitizeConfigName(payload.configName || "");

        if (activeSafe && payloadSafe && activeSafe === payloadSafe) {
          const label = document.getElementById("achStatsPlaytime");
          if (label) {
            label.textContent = `Playtime: ${formatPlaytimeLabel(
              payload.totalMs
            )}`;
          }
        }
      });
      [
        "positionDropdown",
        "presetDropdown",
        "soundSelect",
        "languageSelect",
        "scaleSlider",
        "disableProgressCheckbox",
        "app-zoom-dropdown",
      ].forEach((id) => {
        const el = document.getElementById(id);
        if (el) {
          el.addEventListener("change", () => {
            const zoomValue = parseFloat(
              document.getElementById("app-zoom-dropdown")?.value || 1
            );
            const prefs = {
              position: document.getElementById("positionDropdown")?.value,
              preset: document.getElementById("presetDropdown")?.value,
              sound: document.getElementById("soundSelect")?.value,
              language: document.getElementById("languageSelect")?.value,
              notificationScale: parseFloat(
                document.getElementById("scaleSlider")?.value || 1
              ),
              disableProgress: document.getElementById(
                "disableProgressCheckbox"
              )?.checked,
              windowZoomFactor: parseFloat(
                document.getElementById("app-zoom-dropdown")?.value || 1
              ),
              windowZoomFactor: zoomValue,
            };
            document.body.dataset.zoom = String(
              Math.round((zoomValue || 1) * 100)
            );
            window.api.savePreferences(prefs);
            window.api.setZoom(prefs.windowZoomFactor); // set zoom live
          });
        }
      });

      window.addEventListener("DOMContentLoaded", () => {
        const savedMessage = localStorage.getItem("configSavedMessage");
        const success = localStorage.getItem("configSavedSuccess") === "true";

        if (savedMessage) {
          showNotification(savedMessage, success ? "#4CAF50" : "#f44336");
          localStorage.removeItem("configSavedMessage");
          localStorage.removeItem("configSavedSuccess");
        }
      });

      function updateAchievementStats(achievements) {
        const total = achievements.length;
        const unlocked = achievements.filter(
          (a) => a.earned === true || a.earned === 1
        ).length;

        const label = document.getElementById("achStatsText");
        const bar = document.getElementById("achStatsBar");
        const percentLabel = document.getElementById("achStatsPercent");

        const percentage = total > 0 ? Math.round((unlocked / total) * 100) : 0;

        if (label && bar && percentLabel) {
          label.textContent = `Progress: ${unlocked} / ${total}`;
          bar.style.width = `${percentage}%`;
          percentLabel.textContent = `${percentage}%`;
          document.getElementById("achStats").style.display = "block";
        }
      }
      let __watcherAutoSelect = null;
      window.api.on("auto-select-config", async (configName) => {
        const configList = document.getElementById("configList");
        __watcherAutoSelect = sanitizeConfigName(configName);
        if (!configList) return;

        const currentSafe = sanitizeConfigName(configList.value || "");
        if (currentSafe === __watcherAutoSelect) {
          return; // already selected, avoid duplicate reloads
        }

        const cached = configMetaIndex.get(configName);
        if (
          !blacklistState.showBlacklisted &&
          cached?.appid &&
          isAppIdInBlacklist(cached.appid)
        ) {
          return;
        }

        const ensureOption = async () => {
          const hasOption = !!configList.querySelector(
            `option[value="${configName.replace(/"/g, '\\"')}"]`
          );
          if (!hasOption) {
            await reloadConfigsDropdown();
          }
        };

        await ensureOption();

        // if still missing, abort gracefully
        const optionExists = !!configList.querySelector(
          `option[value="${configName.replace(/"/g, '\\"')}"]`
        );
        if (!optionExists) return;

        configList.value = configName;
        configList.dispatchEvent(new Event("change", { bubbles: true }));
      });

      async function reloadConfigsDropdown(forceRefreshBlacklist = false) {
        if (forceRefreshBlacklist) {
          await syncBlacklistList();
        }
        const dropdown = document.getElementById("configList");
        if (!dropdown) {
          console.error("‚ö†Ô∏è configList element not found.");
          return;
        }

        const configsRaw = await window.api.loadConfigs();
        const configs = normalizeConfigList(configsRaw);
        cacheConfigMeta(configs);
        const selectedBefore = dropdown.value;

        dropdown.innerHTML = "";

        const defaultOption = document.createElement("option");
        defaultOption.value = "";
        defaultOption.textContent = "Select";
        defaultOption.disabled = true;
        defaultOption.selected = true;
        dropdown.appendChild(defaultOption);

        const visibleConfigs = blacklistState.showBlacklisted
          ? configs
          : configs.filter((cfg) => !isAppIdInBlacklist(cfg.appid));

        visibleConfigs.forEach((config) => {
          const option = document.createElement("option");
          option.value = config.name;
          option.textContent = config.displayName || config.name;
          if (isAppIdInBlacklist(config.appid)) {
            option.textContent += " (Ignored)";
          }
          dropdown.appendChild(option);
        });

        const prevSanitized = sanitizeConfigName(selectedBefore || "");
        const autoSelectSanitized = sanitizeConfigName(
          __watcherAutoSelect || ""
        );
        const findMatchingValue = () => {
          const byPrev = visibleConfigs.find(
            (cfg) => sanitizeConfigName(cfg.name) === prevSanitized
          );
          if (byPrev) return byPrev.name;
          const byAuto = visibleConfigs.find(
            (cfg) => sanitizeConfigName(cfg.name) === autoSelectSanitized
          );
          if (byAuto) return byAuto.name;
          return "";
        };
        const matchValue = findMatchingValue();
        if (matchValue) {
          dropdown.value = matchValue;
          const defaultOpt = dropdown.querySelector('option[value=""]');
          if (defaultOpt) defaultOpt.selected = false;
        }
        const currentValue = dropdown.value;
        if (currentValue) {
          const cachedMeta = configMetaIndex.get(currentValue);
          lastSelectedConfigMeta = cachedMeta || null;
          updateBlacklistButtonState(cachedMeta?.appid || null);
        } else {
          lastSelectedConfigMeta = null;
          updateBlacklistButtonState(null);
        }
      }

      document
        .getElementById("generateConfigsBtn")
        .addEventListener("click", async () => {
          const selectedFolder = await window.api.selectFolder();
          if (!selectedFolder) {
            alert("Canceled: You must select a save path folder to continue!");
            return;
          }

          const result = await window.autoConfigApi.generateConfigs(
            selectedFolder
          );
          if (result.success) {
            console.log("Configs generated successfully!");
            await reloadConfigsDropdown();
          } else {
            console.error("Failed to generate configs: " + result.message);
          }
        });

      // Window control buttons
      document.getElementById("minimizeBtn").addEventListener("click", () => {
        window.customApi.minimizeWindow();
      });

      document.getElementById("maximizeBtn").addEventListener("click", () => {
        window.customApi.maximizeWindow();
      });

      document.getElementById("closeBtn").addEventListener("click", () => {
        window.customApi.closeWindow();
      });

      // Update maximize button icon when window state changes
      window.electron?.ipcRenderer?.on?.(
        "window-state-change",
        (isMaximized) => {
          const maximizeBtn = document.getElementById("maximizeBtn");
          if (!maximizeBtn) return;
          maximizeBtn.innerHTML = isMaximized
            ? '<i class="far fa-clone"></i>'
            : '<i class="far fa-square"></i>';
          document.body.classList.toggle("window-maximized", !!isMaximized);
        }
      );

      // Add visual feedback when clicking buttons
      const buttons = document.querySelectorAll(".titlebar-button");
      buttons.forEach((button) => {
        button.addEventListener("mousedown", () => {
          button.style.backgroundColor = "rgba(255, 255, 255, 0.2)";
        });
        button.addEventListener("mouseup", () => {
          button.style.backgroundColor = "";
        });
        button.addEventListener("mouseleave", () => {
          button.style.backgroundColor = "";
        });
      });

      // Settings Menu Functionality
      function setInertExcept(keepIds = []) {
        const keep = new Set(["titlebar", ...keepIds]);
        Array.from(document.body.children).forEach((el) => {
          if (!(el instanceof HTMLElement)) return;
          if (keep.has(el.id)) {
            el.removeAttribute("aria-hidden");
            el.inert = false;
          } else {
            el.setAttribute("aria-hidden", "true");
            el.inert = true;
          }
        });
      }
      function clearInertAll() {
        Array.from(document.body.children).forEach((el) => {
          if (!(el instanceof HTMLElement)) return;
          el.removeAttribute("aria-hidden");
          el.inert = false;
        });
      }

      function isElementVisible(el) {
        const st = getComputedStyle(el);
        if (st.display === "none" || st.visibility === "hidden") return false;
        const r = el.getBoundingClientRect();
        return r.width > 0 && r.height > 0;
      }

      let __settingsTrapHandler = null;

      function trapFocus(container) {
        const sel =
          'a,button,input,select,textarea,[tabindex]:not([tabindex="-1"])';
        const visible = (el) => {
          if (!(el instanceof HTMLElement)) return false;
          const st = getComputedStyle(el);
          if (st.display === "none" || st.visibility === "hidden") return false;
          const r = el.getBoundingClientRect();
          return r.width > 0 && r.height > 0;
        };
        const getFocusable = () =>
          Array.from(container.querySelectorAll(sel)).filter(
            (el) => !el.disabled && el.tabIndex !== -1 && visible(el)
          );

        const activeTab =
          container.querySelector(".settings-tab.active") ||
          container.querySelector(".settings-tab");
        (activeTab || getFocusable()[0] || container).focus({
          preventScroll: true,
        });

        const handler = (e) => {
          if (e.key !== "Tab") return;
          const f = getFocusable();
          if (!f.length) return;
          const first = f[0],
            last = f[f.length - 1];

          if (e.shiftKey && document.activeElement === first) {
            e.preventDefault();
            last.focus({ preventScroll: true });
          } else if (!e.shiftKey && document.activeElement === last) {
            e.preventDefault();
            first.focus({ preventScroll: true });
          }
        };

        __settingsTrapHandler = handler;
        container.addEventListener("keydown", handler, true);
      }

      function untrapFocus(container) {
        if (__settingsTrapHandler && container) {
          container.removeEventListener("keydown", __settingsTrapHandler, true);
          __settingsTrapHandler = null;
        }
      }

      // ===== STRICT BG-SCROLL BLOCKERS (Settings + Dashboard) =====
      let __scrollBlockersOn = false;

      function installBgScrollBlockers() {
        if (__scrollBlockersOn) return;
        __scrollBlockersOn = true;

        const settingsMenu = document.getElementById("settingsMenu");
        const settingsContent = document.querySelector(".settings-content");

        const dashOverlay = document.getElementById("dashboardOverlay");
        const dashPanel = document.getElementById("dashboardPanel");

        const isAnyOpen = () =>
          (!!settingsMenu && !settingsMenu.classList.contains("hidden")) ||
          (!!dashOverlay && dashOverlay.classList.contains("open"));

        const isInsideOverlay = (t) =>
          (!!settingsContent && t && settingsContent.contains(t)) ||
          (!!dashPanel && t && dashPanel.contains(t));

        // ‚Äî mouse/trackpad/touch
        const wheelBlock = (e) => {
          if (isAnyOpen() && !isInsideOverlay(e.target)) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        };
        const touchBlock = (e) => {
          if (isAnyOpen() && !isInsideOverlay(e.target)) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        };

        // ‚Äî scroll in Main
        const SCROLL_KEYS = new Set([
          "ArrowUp",
          "ArrowDown",
          "ArrowLeft",
          "ArrowRight",
          "PageUp",
          "PageDown",
          "Home",
          "End",
          " ",
          "Spacebar",
        ]);

        const keyBlock = (e) => {
          if (!isAnyOpen()) return;

          if (!isInsideOverlay(e.target) && SCROLL_KEYS.has(e.key)) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        };

        document.addEventListener("wheel", wheelBlock, {
          passive: false,
          capture: true,
        });
        document.addEventListener("touchmove", touchBlock, {
          passive: false,
          capture: true,
        });
        document.addEventListener("keydown", keyBlock, true);

        window.___bgScrollGuards = { wheelBlock, touchBlock, keyBlock };
      }

      function removeBgScrollBlockers() {
        const settingsOpen = !document
          .getElementById("settingsMenu")
          ?.classList.contains("hidden");
        const dashOpen = document
          .getElementById("dashboardOverlay")
          ?.classList?.contains("open");
        if (settingsOpen || dashOpen) return;

        if (!__scrollBlockersOn || !window.___bgScrollGuards) return;
        __scrollBlockersOn = false;

        const { wheelBlock, touchBlock, keyBlock } = window.___bgScrollGuards;
        document.removeEventListener("wheel", wheelBlock, { capture: true });
        document.removeEventListener("touchmove", touchBlock, {
          capture: true,
        });
        document.removeEventListener("keydown", keyBlock, true);
        window.___bgScrollGuards = null;
      }

      function isSettingsOpen() {
        const m = document.getElementById("settingsMenu");
        return !!(m && !m.classList.contains("hidden"));
      }

      function refocusSettings(afterMs = 140) {
        const attempts = [afterMs, 700, 1400, 2200];
        const doFocus = () => {
          if (!isSettingsOpen()) return;
          try {
            window.ui?.refocus?.();
          } catch {}
          const content = document.querySelector(".settings-content");
          if (!content) return;
          const activeTab = content.querySelector(".settings-tab.active");
          const firstFocusable = content.querySelector(
            'button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])'
          );
          (activeTab || firstFocusable || content).focus?.({
            preventScroll: true,
          });
        };
        attempts.forEach((ms) => setTimeout(doFocus, ms));
      }

      function escGateWhileSettings(e) {
        if (e.key !== "Escape") return;
        const menu = document.getElementById("settingsMenu");
        const open = menu && !menu.classList.contains("hidden");
        if (!open) return;

        e.stopImmediatePropagation();
        e.preventDefault();

        if (window.__settingsMode === "section") {
          const activeTab = document.querySelector(".settings-tab.active");
          if (activeTab) {
            activeTab.focus({ preventScroll: true });
            window.__settingsMode = "tabs";
          }
          return;
        }

        document.getElementById("closeSettingsBtn")?.click();
      }

      let __bodyOverflowPrev = "";

      function openSettingsModal() {
        const settingsMenu = document.getElementById("settingsMenu");
        const content = document.querySelector(".settings-content");

        setInertExcept(["settingsMenu", "titlebar"]);
        settingsMenu.classList.remove("hidden");
        document.documentElement.classList.add("settings-open");
        document.body.classList.add("settings-open");

        installBgScrollBlockers();

        const stopOutside = (e) => {
          if (!settingsMenu || settingsMenu.classList.contains("hidden"))
            return;
          if (!content.contains(e.target)) {
            e.preventDefault();
            e.stopPropagation();
          }
        };
        if (!window.__settingsWheelGuards) {
          document.addEventListener("wheel", stopOutside, {
            passive: false,
            capture: true,
          });
          document.addEventListener("touchmove", stopOutside, {
            passive: false,
            capture: true,
          });
          window.__settingsWheelGuards = true;
        }

        trapFocus(content);
        settingsEnterTabsMode();
        document.addEventListener("keydown", escGateWhileSettings, {
          capture: true,
        });
      }

      function closeSettingsModal() {
        window.__settingsMode = null;

        const settingsMenu = document.getElementById("settingsMenu");
        const content = document.querySelector(".settings-content");

        untrapFocus(content);
        settingsMenu.classList.add("hidden");

        document.documentElement.classList.remove("settings-open");
        document.body.classList.remove("settings-open");

        document.removeEventListener("keydown", escGateWhileSettings, {
          capture: true,
        });

        removeBgScrollBlockers();

        if (window.__dashboardOpen) {
          try {
            setBackgroundInert(true);
          } catch {}
          refocusDashboard();
        } else {
          clearInertAll();
        }
      }

      document
        .getElementById("settingsBtn")
        .addEventListener("click", (event) => {
          event.stopPropagation();
          syncSettingsToModal();
          openSettingsModal();
        });

      document
        .getElementById("closeSettingsBtn")
        .addEventListener("click", async () => {
          syncSettingsFromModal();
          await persistSettingsPreferences();
          closeSettingsModal();
        });

      document
        .getElementById("settingsMenu")
        .addEventListener("click", async (event) => {
          const settingsContent = document.querySelector(".settings-content");
          if (!settingsContent.contains(event.target)) {
            syncSettingsFromModal();
            await persistSettingsPreferences();
            closeSettingsModal();
          }
        });

      // Tab switching
      document.querySelectorAll(".settings-tab").forEach((tab) => {
        tab.addEventListener("click", () => {
          // Remove active class from all tabs
          document
            .querySelectorAll(".settings-tab")
            .forEach((t) => t.classList.remove("active"));
          document
            .querySelectorAll(".tab-content")
            .forEach((c) => c.classList.remove("active"));

          // Add active class to clicked tab and corresponding content
          tab.classList.add("active");
          const tabId = tab.getAttribute("data-tab");
          if (tabId === "shortcuts") ensureShortcutsTabContent();
          const tabContent = document.getElementById(tabId + "Tab");
          if (tabContent) {
            tabContent.classList.add("active");
            tabContent.removeAttribute("hidden");
          }

          // Enter section mode after switching tabs
          window.settingsEnterSectionMode();
        });
      });

      // Achievement test button in settings
      document
        .getElementById("settings-testAchievementBtn")
        .addEventListener("click", function () {
          const preset =
            document.getElementById("settings-presetDropdown").value ||
            "default";
          const position = document.getElementById(
            "settings-positionDropdown"
          ).value;
          const sound = document.getElementById("settings-soundSelect").value;
          const scale = parseFloat(
            document.getElementById("settings-scaleSlider").value
          );

          window.api.showTestNotification({
            preset,
            position,
            sound,
            scale,
          });
        });

      // Settings scale slider
      const settingsScaleSlider = document.getElementById(
        "settings-scaleSlider"
      );
      const settingsScaleValue = document.getElementById("settings-scaleValue");
      const settingsScaleValueDisplay = document.getElementById(
        "settings-scaleValueDisplay"
      );

      function updateSettingsScaleLabel() {
        const value = parseFloat(settingsScaleSlider.value);
        const percentage = Math.round(value * 100);
        settingsScaleValue.textContent = value.toFixed(2);
        settingsScaleValueDisplay.textContent = `${percentage}%`;
        settingsScaleSlider.style.background = `linear-gradient(to right, var(--dracula-cyan) 0%, var(--dracula-cyan) ${percentage}%, #ccc ${percentage}%, #ccc 100%)`;
      }

      function renderSteamApiKeyStatus(masked) {
        const inputEl = document.getElementById("settings-steamApiKeyInput");
        if (!inputEl) return;

        if (masked) {
          inputEl.value = masked;
          inputEl.placeholder = "Enter your Steam Web API key";
        } else {
          inputEl.value = "";
          inputEl.placeholder = "No key saved. Enter your Steam Web API key";
        }
      }

      function renderSteamApiKeyStatusFromPrefs(prefs) {
        renderSteamApiKeyStatus(prefs?.steamApiKeyMasked || "");
      }

      async function refreshSteamApiKeyStatus() {
        try {
          await loadPreferencesCached();
          renderSteamApiKeyStatusFromPrefs(getCachedPreferences());
        } catch (err) {
          console.error("Steam API key status error:", err);
        }
      }

      settingsScaleSlider.addEventListener("input", () => {
        updateSettingsScaleLabel();
        window.api.savePreferences({
          notificationScale: settingsScaleSlider.value,
        });
      });

      // Save Settings without config
      document
        .getElementById("settings-disableProgressCheckbox")
        .addEventListener("change", async (e) => {
          const isChecked = e.target.checked;
          window.api.disableProgress(isChecked);
          await window.api.savePreferences({ disableProgress: isChecked });
        });

      document
        .getElementById("settings-disablePlaytimeCheckbox")
        .addEventListener("change", async (e) => {
          const on = e.target.checked;
          window.api.setDisablePlaytime(on);
          await window.api.savePreferences({ disablePlaytime: on });
        });

      document
        .getElementById("settings-disablePlatinumCheckbox")
        .addEventListener("change", async (e) => {
          await window.api.savePreferences({
            disablePlatinum: e.target.checked,
          });
        });

      document
        .getElementById("settings-positionDropdown")
        .addEventListener("change", (e) =>
          window.api.savePreferences({ position: e.target.value })
        );

      document
        .getElementById("settings-platinumPositionDropdown")
        .addEventListener("change", (e) => {
          const hidden = document.getElementById("platinumPositionValue");
          if (hidden) hidden.value = e.target.value;
          window.api.savePreferences({ platinumPosition: e.target.value });
        });

      document
        .getElementById("settings-presetDropdown")
        .addEventListener("change", (e) =>
          window.api.savePreferences({ preset: e.target.value })
        );

      document
        .getElementById("settings-platinumPresetDropdown")
        .addEventListener("change", (e) => {
          const hidden = document.getElementById("platinumPresetValue");
          if (hidden) hidden.value = e.target.value;
          window.api.savePreferences({ platinumPreset: e.target.value });
        });

      document
        .getElementById("settings-soundSelect")
        .addEventListener("change", (e) => {
          window.api.savePreferences({ sound: e.target.value });
        });

      document
        .getElementById("settings-platinumSoundSelect")
        .addEventListener("change", (e) => {
          const hidden = document.getElementById("platinumSoundValue");
          if (hidden) hidden.value = e.target.value;
          window.api.savePreferences({ platinumSound: e.target.value });
        });

      // Function to sync values between main UI and settings menu
      function syncSettingsToModal() {
        // Copy preset options
        const mainPresetDropdown = document.getElementById("presetDropdown");
        const settingsPresetDropdown = document.getElementById(
          "settings-presetDropdown"
        );

        if (mainPresetDropdown && settingsPresetDropdown) {
          settingsPresetDropdown.innerHTML = mainPresetDropdown.innerHTML;
          if (mainPresetDropdown.value) {
            settingsPresetDropdown.value = mainPresetDropdown.value;
          }
          const prefs = getCachedPreferences();
          const platinumPresetDropdown = document.getElementById(
            "settings-platinumPresetDropdown"
          );
          if (platinumPresetDropdown) {
            platinumPresetDropdown.innerHTML = mainPresetDropdown.innerHTML;
            platinumPresetDropdown.value =
              prefs.platinumPreset || platinumPresetDropdown.value || "default";
          }
        }

        // Copy sound options
        const mainSoundSelect = document.getElementById("soundSelect");
        const settingsSoundSelect = document.getElementById(
          "settings-soundSelect"
        );

        if (mainSoundSelect && settingsSoundSelect) {
          settingsSoundSelect.innerHTML = mainSoundSelect.innerHTML;
          if (mainSoundSelect.value) {
            settingsSoundSelect.value = mainSoundSelect.value;
          }
          const prefs = getCachedPreferences();
          const platinumSoundSelect = document.getElementById(
            "settings-platinumSoundSelect"
          );
          if (platinumSoundSelect) {
            platinumSoundSelect.innerHTML = mainSoundSelect.innerHTML;
            platinumSoundSelect.value =
              prefs.platinumSound || platinumSoundSelect.value || "mute";
          }
        }

        // Sync position dropdown
        const mainPositionDropdown =
          document.getElementById("positionDropdown");
        const settingsPositionDropdown = document.getElementById(
          "settings-positionDropdown"
        );

        if (mainPositionDropdown && settingsPositionDropdown) {
          settingsPositionDropdown.value = mainPositionDropdown.value;
        }
        const settingsPlatinumPositionDropdown = document.getElementById(
          "settings-platinumPositionDropdown"
        );
        if (settingsPlatinumPositionDropdown && mainPositionDropdown) {
          if (!settingsPlatinumPositionDropdown.value) {
            settingsPlatinumPositionDropdown.value = mainPositionDropdown.value;
          }
        }

        // Sync scale slider
        const mainScaleSlider = document.getElementById("scaleSlider");
        const settingsScaleSlider = document.getElementById(
          "settings-scaleSlider"
        );

        if (mainScaleSlider && settingsScaleSlider) {
          settingsScaleSlider.value = mainScaleSlider.value;
          updateSettingsScaleLabel();
        }

        // Sync disable progress checkbox
        const mainDisableProgressCheckbox = document.getElementById(
          "disableProgressCheckbox"
        );
        const settingsDisableProgressCheckbox = document.getElementById(
          "settings-disableProgressCheckbox"
        );

        if (mainDisableProgressCheckbox && settingsDisableProgressCheckbox) {
          settingsDisableProgressCheckbox.checked =
            mainDisableProgressCheckbox.checked;
        }
        const settingsDisablePlatinumCheckbox = document.getElementById(
          "settings-disablePlatinumCheckbox"
        );
        if (settingsDisablePlatinumCheckbox) {
          // no main checkbox; leave as stored
        }
        const steamApiKeyInput = document.getElementById(
          "settings-steamApiKeyInput"
        );
        if (steamApiKeyInput) {
          steamApiKeyInput.value = "";
        }
        refreshSteamApiKeyStatus();
      }

      function syncSettingsFromModal() {
        // Copy values from settings menu to main UI
        const mainPresetDropdown = document.getElementById("presetDropdown");
        const settingsPresetDropdown = document.getElementById(
          "settings-presetDropdown"
        );

        if (
          mainPresetDropdown &&
          settingsPresetDropdown &&
          settingsPresetDropdown.value
        ) {
          mainPresetDropdown.value = settingsPresetDropdown.value;
        }

        // Copy sound options
        const mainSoundSelect = document.getElementById("soundSelect");
        const settingsSoundSelect = document.getElementById(
          "settings-soundSelect"
        );

        if (
          mainSoundSelect &&
          settingsSoundSelect &&
          settingsSoundSelect.value
        ) {
          mainSoundSelect.value = settingsSoundSelect.value;
        }

        // Sync position dropdown
        const mainPositionDropdown =
          document.getElementById("positionDropdown");
        const settingsPositionDropdown = document.getElementById(
          "settings-positionDropdown"
        );

        if (mainPositionDropdown && settingsPositionDropdown) {
          mainPositionDropdown.value = settingsPositionDropdown.value;
        }

        // Sync scale slider
        const mainScaleSlider = document.getElementById("scaleSlider");
        const settingsScaleSlider = document.getElementById(
          "settings-scaleSlider"
        );

        if (mainScaleSlider && settingsScaleSlider) {
          mainScaleSlider.value = settingsScaleSlider.value;
          const event = new Event("input");
          mainScaleSlider.dispatchEvent(event);
        }

        // Sync disable progress checkbox
        const mainDisableProgressCheckbox = document.getElementById(
          "disableProgressCheckbox"
        );
        const settingsDisableProgressCheckbox = document.getElementById(
          "settings-disableProgressCheckbox"
        );

        if (mainDisableProgressCheckbox && settingsDisableProgressCheckbox) {
          mainDisableProgressCheckbox.checked =
            settingsDisableProgressCheckbox.checked;
        }
        const settingsDisablePlatinumCheckbox = document.getElementById(
          "settings-disablePlatinumCheckbox"
        );
        if (settingsDisablePlatinumCheckbox) {
          settingsDisablePlatinumCheckbox.dispatchEvent(new Event("change"));
        }
        if (typeof updateMainConfig === "function") {
          try {
            updateMainConfig();
          } catch (err) {
            console.warn(
              "Failed to update config after syncing settings:",
              err
            );
          }
        }
      }

      function collectSettingsPreferences() {
        const byId = (id) => document.getElementById(id);
        const checkbox = (id) => !!byId(id)?.checked;
        const getVal = (id) => byId(id)?.value || "";
        const zoomValue = parseFloat(getVal("app-zoom-dropdown"));
        const settingsScale = parseFloat(getVal("settings-scaleSlider"));
        const overlayLabel = (byId("overlay-shortcut-btn")?.textContent || "")
          .trim()
          .replace(/\s+/g, " ");
        const base = { ...getCachedPreferences() };
        delete base.steamApiKeyMasked;

        const pick = (value, fallback) => {
          return value !== undefined && value !== null && value !== ""
            ? value
            : fallback;
        };

        const snapshot = {
          ...base,
          preset: pick(
            getVal("settings-presetDropdown") || getVal("presetDropdown"),
            base.preset || "default"
          ),
          position: pick(
            getVal("settings-positionDropdown") || getVal("positionDropdown"),
            base.position || "center-bottom"
          ),
          sound: pick(
            getVal("settings-soundSelect") || getVal("soundSelect"),
            base.sound || "mute"
          ),
          notificationScale: Number.isFinite(settingsScale)
            ? settingsScale
            : base.notificationScale || 1,
          disableProgress: checkbox("settings-disableProgressCheckbox"),
          disablePlaytime: checkbox("settings-disablePlaytimeCheckbox"),
          disablePlatinum: checkbox("settings-disablePlatinumCheckbox"),
          startMaximized: checkbox("settings-startMaximizedCheckbox"),
          startInTray: checkbox("settings-startInTrayCheckbox"),
          showDashboardOnStart: checkbox(
            "settings-showDashboardOnStartCheckbox"
          ),
          screenshotFolder: pick(
            getVal("settings-screenshotFolder").trim(),
            base.screenshotFolder || ""
          ),
          disableAchievementScreenshot: checkbox(
            "settings-disableScreenshotCheckbox"
          ),
          windowZoomFactor: Number.isFinite(zoomValue)
            ? zoomValue
            : base.windowZoomFactor || 1,
          language: pick(getVal("languageSelect"), base.language || undefined),
        };

        snapshot.platinumPreset = pick(
          getVal("settings-platinumPresetDropdown") ||
            getVal("platinumPresetValue"),
          base.platinumPreset || snapshot.preset
        );
        snapshot.platinumPosition = pick(
          getVal("settings-platinumPositionDropdown") ||
            getVal("platinumPositionValue"),
          base.platinumPosition || snapshot.position
        );
        snapshot.platinumSound = pick(
          getVal("settings-platinumSoundSelect") ||
            getVal("platinumSoundValue"),
          base.platinumSound || snapshot.sound
        );

        return snapshot;
      }

      async function persistSettingsPreferences() {
        await refreshPreferencesCache();
        try {
          const payload = collectSettingsPreferences();
          await window.api.savePreferences(payload);
          await refreshPreferencesCache();
        } catch (err) {
          console.error("Failed to persist settings snapshot:", err);
        }
      }

      // Zoom level control
      document
        .getElementById("app-zoom-dropdown")
        .addEventListener("change", (e) => {
          const zoomValue = parseFloat(e.target.value);
          window.api.setZoom(zoomValue);
          window.api.savePreferences({ windowZoomFactor: zoomValue });
        });

      // Overlay shortcut functionality
      const overlayShortcutBtn = document.getElementById(
        "overlay-shortcut-btn"
      );
      let isListeningForShortcut = false;
      let pressedKeys = new Set();
      let shortcutTimeout;
      let currentKeyHandler = null;

      overlayShortcutBtn.addEventListener("click", () => {
        if (
          overlayShortcutBtn.textContent === "Press keys..." ||
          overlayShortcutBtn.classList.contains("listening")
        ) {
          cleanupShortcutRecording();
          restoreSavedShortcutLabel();
          return;
        }

        overlayShortcutBtn.textContent = "Press keys...";
        overlayShortcutBtn.classList.add("listening");
        isListeningForShortcut = true;
        pressedKeys.clear();

        const handleKeyDown = (e) => {
          if (!isListeningForShortcut) return;

          e.preventDefault();
          pressedKeys.add(e.key);

          clearTimeout(shortcutTimeout);
          shortcutTimeout = setTimeout(() => {
            if (!isListeningForShortcut) return;

            const keys = [];

            if (pressedKeys.has("Control")) keys.push("Control");
            if (pressedKeys.has("Shift")) keys.push("Shift");
            if (pressedKeys.has("Alt")) keys.push("Alt");

            const mainKeys = [...pressedKeys].filter(
              (k) => !["Control", "Shift", "Alt", "Meta"].includes(k)
            );
            if (mainKeys.length > 0) {
              const mainKey = mainKeys[0];
              keys.push(mainKey.length === 1 ? mainKey.toUpperCase() : mainKey);
            }

            if (keys.length < 2) {
              overlayShortcutBtn.textContent = "Invalid combo";
              setTimeout(() => restoreSavedShortcutLabel(), 1200);
            } else {
              const combo = keys.join("+");
              overlayShortcutBtn.textContent = combo;
              window.api.savePreferences({ overlayShortcut: combo });
              window.api.updateOverlayShortcut?.(combo);
            }

            cleanupShortcutRecording();
          }, 400);
        };

        currentKeyHandler = handleKeyDown;
        document.addEventListener("keydown", handleKeyDown);
      });

      function cleanupShortcutRecording() {
        isListeningForShortcut = false;
        pressedKeys.clear();
        clearTimeout(shortcutTimeout);
        overlayShortcutBtn.classList.remove("listening");

        if (currentKeyHandler) {
          document.removeEventListener("keydown", currentKeyHandler);
          currentKeyHandler = null;
        }
      }

      async function restoreSavedShortcutLabel() {
        await loadPreferencesCached();
        const prefs = getCachedPreferences();
        overlayShortcutBtn.textContent =
          prefs?.overlayShortcut || "Set Shortcut";
      }

      // ==== FOLDERS TAB ‚Äì UI & IPC ====
      (function initFoldersTab() {
        const listEl = document.getElementById("foldersList");
        const addBtn = document.getElementById("foldersAddBtn");
        const rescanBtn = document.getElementById("foldersRescanBtn");

        if (!listEl || !addBtn || !rescanBtn) return;

        async function invoke(channel, ...args) {
          if (window.api?.invoke) return window.api.invoke(channel, ...args);
          if (window.electron?.ipcRenderer?.invoke)
            return window.electron.ipcRenderer.invoke(channel, ...args);
          console.warn("IPC invoke bridge not found for", channel);
          return null;
        }

        function renderFoldersList(folders) {
          listEl.innerHTML = "";

          const arr = Array.isArray(folders) ? folders : [];
          if (arr.length === 0) {
            listEl.innerHTML =
              '<div style="padding:15px; color:#aaa;"><small>No watched folders yet.</small></div>';
            return;
          }

          for (const f of arr) {
            const folderPath = typeof f === "string" ? f : f?.path;
            const blocked = typeof f === "object" && !!f?.blocked;
            const isDefault = typeof f === "object" && !!f?.isDefault;

            const row = document.createElement("div");
            row.className = "wf-row";
            if (blocked) row.classList.add("wf-row--blocked");
            row.setAttribute("role", "listitem");
            row.dataset.folder = folderPath;

            const pathEl = document.createElement("div");
            pathEl.className = "wf-path";
            pathEl.title = folderPath;
            if (blocked) pathEl.dataset.status = "Ignored";
            else delete pathEl.dataset.status;
            pathEl.textContent = folderPath;

            const actions = document.createElement("div");
            actions.className = "wf-actions";

            //BLOCK
            const btnBlock = document.createElement("button");
            btnBlock.className = blocked
              ? "icon-btn unblock"
              : "icon-btn block";
            btnBlock.title = blocked ? "Resume watching" : "Ignore this folder";
            btnBlock.setAttribute("aria-label", btnBlock.title);
            btnBlock.innerHTML = blocked
              ? '<i class="fa-solid fa-bell-slash"></i>' // ignore
              : '<i class="fa-solid fa-bell"></i>'; // active
            btnBlock.addEventListener("click", async () => {
              const channel = blocked ? "folders:unblock" : "folders:block";
              const res = await invoke(channel, folderPath);
              if (res?.ok) renderFoldersList(res.folders);
              else alert(res?.error || "Failed to update folder");
            });

            // EDIT (‚úé)
            const btnEdit = document.createElement("button");
            btnEdit.className = "icon-btn edit";
            btnEdit.title = "Edit folder";
            btnEdit.setAttribute("aria-label", "Edit folder");
            btnEdit.innerHTML = '<i class="fa-regular fa-pen-to-square"></i>';
            btnEdit.addEventListener("click", async () => {
              let next = null;
              if (typeof window.api?.selectFolder === "function") {
                next = await window.api.selectFolder();
              }
              if (!next || next === folderPath) return;
              const rem = await invoke("folders:remove", folderPath);
              if (!rem?.ok) {
                alert(rem?.error || "Failed to replace folder (remove step).");
                return;
              }

              const add = await invoke("folders:add", next);
              if (!add?.ok) {
                alert(add?.error || "Failed to replace folder (add step).");
                await invoke("folders:add", folderPath);
                return;
              }
              renderFoldersList(add.folders);
            });

            // REMOVE
            const btnRemove = document.createElement("button");
            btnRemove.className = "icon-btn remove";
            btnRemove.title = "Remove folder";
            btnRemove.setAttribute("aria-label", "Remove folder");
            btnRemove.innerHTML = '<i class="fa-regular fa-trash-can"></i>';
            btnRemove.addEventListener("click", async () => {
              const res = await invoke("folders:remove", folderPath);
              if (res?.ok) renderFoldersList(res.folders);
              else alert(res?.error || "Failed to remove folder");
            });
            if (isDefault) {
              btnRemove.style.display = "none";
              btnEdit.style.display = "none";
            }

            actions.append(btnEdit, btnRemove, btnBlock);
            row.append(pathEl, actions);
            listEl.appendChild(row);
          }
        }

        async function loadFolders() {
          try {
            const res = await invoke("folders:list");
            renderFoldersList(res?.folders || []);
          } catch (e) {
            console.warn("Failed to load folders:", e);
            renderFoldersList([]);
          }
        }

        addBtn.addEventListener("click", async () => {
          try {
            const dir = await (window.api?.selectFolder?.() ||
              invoke("selectFolder"));
            if (!dir) return;
            const res = await invoke("folders:add", dir);
            if (res?.ok) renderFoldersList(res.folders || []);
            else alert(res?.error || "Failed to add folder");
          } catch (e) {
            console.error("Add folder error:", e);
          }
        });

        rescanBtn.addEventListener("click", async () => {
          try {
            const res = await invoke("folders:rescan");
            if (res?.ok) {
              renderFoldersList(res.folders || []);
            } else {
              alert(res?.error || "Failed to restart watchers");
            }
          } catch (e) {
            console.error("Rescan error:", e);
          }
        });

        document
          .getElementById("settingsBtn")
          ?.addEventListener("click", () => {
            setTimeout(loadFolders, 50);
          });

        loadFolders();
      })();

      document.addEventListener("mousedown", (event) => {
        if (isListeningForShortcut && event.target !== overlayShortcutBtn) {
          cleanupShortcutRecording();
          restoreSavedShortcutLabel();
        }
      });

      // ==== DASHBOARD / GAMES LIST ====
      function setBackgroundInert(on) {
        const keep = new Set([
          "dashboardOverlay",
          "appSettingsDontHide",
          "titlebar",
        ]);

        Array.from(document.body.children).forEach((el) => {
          if (!(el instanceof HTMLElement)) return;

          if (keep.has(el.id)) {
            el.removeAttribute("aria-hidden");
            el.inert = false;
            return;
          }

          if (on) {
            el.setAttribute("aria-hidden", "true");
            el.inert = true;
          } else {
            el.removeAttribute("aria-hidden");
            el.inert = false;
          }
        });
      }
      function focusDashboardSearch(selectAll = true) {
        const input = document.getElementById("dashboardSearchInput");
        if (!input) return;
        if (!window.__dashboardOpen) {
          window.openDashboard?.();
          setTimeout(() => focusDashboardSearch(selectAll), 0);
          return;
        }
        input.focus({ preventScroll: true });
        if (selectAll) input.select();
      }
      window.focusDashboardSearch = focusDashboardSearch;

      function refocusDashboard() {
        if (!window.__dashboardOpen) return;
        const dash = document.getElementById("dashboardOverlay");
        if (!dash) return;

        const search = document.getElementById("dashboardSearchInput");
        const grid = document.getElementById("dashboardGrid");
        const activeCard = dash.querySelector(".dash-card.active");
        const firstCard = dash.querySelector(".dash-card");

        const target = activeCard || firstCard || grid || search;

        requestAnimationFrame(() => {
          target?.focus?.({ preventScroll: true });
        });
      }

      (function () {
        const dashboard = document.getElementById("dashboardOverlay");
        const gridEl = document.getElementById("dashboardGrid");
        const btnToggle = document.getElementById("toggleDashboardBtn");
        const btnClose = document.getElementById("closeDashboard");

        const fileUrl = (p) =>
          p ? `file:///${String(p).replace(/\\/g, "/")}` : "";
        const fallbackIcon = new URL(
          "./assets/achievements-logo.png",
          window.location.href
        ).toString();

        const scheduleIdle =
          typeof window.requestIdleCallback === "function"
            ? window.requestIdleCallback
            : (cb) => setTimeout(cb, 16);

        const DASH_PROGRESS_PREFIX = "dashboard:lastProgress:";
        const dashboardConfigCache = new Map();
        const dashboardImageCache = new Map();
        let dashboardLazyObserver = null;
        const IMG_CACHE_PREFIX = "dashboard:lastImage:";

        const ensureLazyObserver = () => {
          if (dashboardLazyObserver) return dashboardLazyObserver;

          if ("IntersectionObserver" in window) {
            dashboardLazyObserver = new IntersectionObserver(
              (entries) => {
                for (const entry of entries) {
                  if (!entry.isIntersecting) continue;
                  const img = entry.target;
                  dashboardLazyObserver.unobserve(img);
                  const src = img.dataset.src;
                  if (src)
                    scheduleIdle(() => {
                      img.src = src;
                    });
                }
              },
              { rootMargin: "80px" }
            );
          } else {
            dashboardLazyObserver = {
              observe(img) {
                scheduleIdle(() => {
                  const src = img.dataset?.src;
                  if (src) img.src = src;
                });
              },
              unobserve() {},
            };
          }
          return dashboardLazyObserver;
        };

        async function getConfigCached(name) {
          if (dashboardConfigCache.has(name))
            return dashboardConfigCache.get(name);
          try {
            const cfg = await window.api.getConfigByName(name);
            dashboardConfigCache.set(name, cfg);
            return cfg;
          } catch {
            dashboardConfigCache.set(name, null);
            return null;
          }
        }

        let __dashNav = { index: 0, cols: 1 };
        let __gpLoopId = null;

        function getDashCards(onlyVisible = true) {
          const all = Array.from(gridEl.querySelectorAll(".dash-card"));
          if (!onlyVisible) return all;
          return all.filter(
            (c) =>
              c.offsetParent !== null && getComputedStyle(c).display !== "none"
          );
        }

        function computeGridCols() {
          // Count columns from computed grid-template-columns
          const s = window.getComputedStyle(gridEl);
          const cols = (s.gridTemplateColumns || "")
            .split(" ")
            .filter(Boolean).length;
          __dashNav.cols = Math.max(1, cols || 1);
          return __dashNav.cols;
        }

        function focusCardAt(idx) {
          const cards = getDashCards();
          if (!cards.length) return;
          const n = cards.length;
          __dashNav.index = ((idx % n) + n) % n; // wrap
          const el = cards[__dashNav.index];
          setActiveCard(el.getAttribute("data-name") || "");
          el.focus({ preventScroll: true });
          el.scrollIntoView({ block: "nearest", inline: "nearest" });
          cards.forEach((c) =>
            c.querySelector(".dash-play")?.classList.remove("force-show")
          );
          el.querySelector(".dash-play")?.classList.add("force-show");
        }

        function moveFocus(delta) {
          focusCardAt(__dashNav.index + delta);
        }

        function focusFirstVisibleDashCard() {
          if (!window.__dashboardOpen) return null;
          const body = document.getElementById("dashboardBody");
          const grid = document.getElementById("dashboardGrid");
          if (!body || !grid) return null;
          const bodyRect = body.getBoundingClientRect();
          const cards = Array.from(grid.querySelectorAll(".dash-card"))
            .filter(
              (card) =>
                card.offsetParent !== null &&
                getComputedStyle(card).display !== "none"
            )
            .map((card) => ({ card, rect: card.getBoundingClientRect() }));
          if (!cards.length) return null;

          const within = (rect, strict = false) =>
            strict
              ? rect.top >= bodyRect.top + 1 &&
                rect.bottom <= bodyRect.bottom - 1
              : rect.bottom > bodyRect.top + 1 &&
                rect.top < bodyRect.bottom - 1;

          const fullyVisible = cards.filter(({ rect }) => within(rect, true));
          const usable = fullyVisible.length
            ? fullyVisible
            : cards.filter(({ rect }) => within(rect));
          if (!usable.length) return null;

          usable.sort((a, b) =>
            a.rect.top !== b.rect.top
              ? a.rect.top - b.rect.top
              : a.rect.left - b.rect.left
          );
          const topEdge = usable[0].rect.top;
          const row = usable
            .filter(({ rect }) => Math.abs(rect.top - topEdge) <= 5)
            .sort((a, b) => a.rect.left - b.rect.left);

          const el = (row[0] || usable[0]).card;
          if (!el) return null;

          const name = el.getAttribute("data-name") || "";
          if (name) setActiveCard(name);
          try {
            const all = getDashCards(false);
            __dashNav.index = Math.max(0, all.indexOf(el));
          } catch {}

          el.focus({ preventScroll: true });
          return el;
        }
        window.focusFirstVisibleDashCard = focusFirstVisibleDashCard;

        async function openDashboard() {
          if (isSettingsOpen()) {
            return;
          }
          dashboard.classList.add("open");
          document.body.style.overflow = "hidden";
          window.__dashboardOpen = true;
          try {
            window.api?.setDashboardOpen?.(true);
          } catch {}
          setBackgroundInert(true);
          await buildDashboard();
          enableDashboardHoverSync();
          requestAnimationFrame(() => {
            try {
              refocusDashboard();
            } catch {}
            if (dashboardBody) dashboardBody.scrollTop = dashboardScrollTop;
          });
          startDashboardPoll();
          installBgScrollBlockers();
        }
        function closeDashboard() {
          if (isSettingsOpen()) {
            return;
          }
          if (dashboardBody) dashboardScrollTop = dashboardBody.scrollTop;
          dashboard.classList.remove("open");
          document.body.style.overflow = "";
          window.__dashboardOpen = false;
          try {
            window.api?.setDashboardOpen?.(false);
          } catch {}
          clearDashboardSearch();
          stopDashboardPoll();
          setBackgroundInert(false);
          removeBgScrollBlockers();
        }
        window.openDashboard = openDashboard;
        window.closeDashboard = closeDashboard;
        window.dashboardFocusCardAt = focusCardAt;

        // polling to refresh card progress in near-real-time
        const DASH_POLL_DEFAULT_MS = 4000;
        const DASH_POLL_SLOW_MS = 12000;
        let __dashboardPollId = null;
        let __dashboardPollActive = false;
        let __dashboardPollPaused = false;
        let __dashboardPollInterval = DASH_POLL_DEFAULT_MS;
        let __dashboardPollSkipped = false;
        window.__notificationBusy = false;
        function startDashboardPoll() {
          if (__dashboardPollPaused) return;
          if (__dashboardPollId) return;
          __dashboardPollId = setInterval(async () => {
            if (__dashboardPollActive) return;
            __dashboardPollActive = true;
            try {
              if (!window.__dashboardOpen || window.__notificationBusy) {
                __dashboardPollSkipped = true;
                return;
              }
              let anyChange = false;
              const cards = Array.from(gridEl.querySelectorAll(".dash-card"));
              for (const card of cards) {
                const cfgName = card.getAttribute("data-name");
                if (!cfgName) continue;
                try {
                  const { pct } = await computeCardProgress(cfgName);
                  const key = `dashboard:lastProgress:${cfgName}`;
                  const prev = JSON.parse(localStorage.getItem(key) || "null");
                  const prevPct =
                    prev && typeof prev.pct === "number" ? prev.pct : null;
                  if (prevPct === null || prevPct !== pct) {
                    await updateCardProgressUI(card, cfgName);
                    anyChange = true;
                  }
                } catch (e) {
                  // ignore per-card errors
                }
              }
              if (anyChange) {
                try {
                  window.applyDashboardSortAndFilter?.();
                } catch (e) {}
              }
              // after a slow cycle, return to default cadence
              if (
                __dashboardPollInterval !== DASH_POLL_DEFAULT_MS &&
                !__dashboardPollPaused
              ) {
                stopDashboardPoll();
                __dashboardPollInterval = DASH_POLL_DEFAULT_MS;
                startDashboardPoll();
              }
            } catch (e) {
              console.error("Dashboard poll error:", e);
            } finally {
              __dashboardPollActive = false;
            }
          }, __dashboardPollInterval);
        }
        function stopDashboardPoll() {
          if (!__dashboardPollId) return;
          clearInterval(__dashboardPollId);
          __dashboardPollId = null;
          __dashboardPollActive = false;
        }
        function pauseDashboardPoll() {
          __dashboardPollPaused = true;
          stopDashboardPoll();
        }
        function resumeDashboardPoll() {
          __dashboardPollPaused = false;
          if (window.__dashboardOpen) startDashboardPoll();
        }

        document.addEventListener("visibilitychange", () => {
          if (document.hidden) {
            stopDashboardPoll?.();
          } else if (window.__dashboardOpen) {
            startDashboardPoll?.();
          }
        });

        function setActiveCard(name) {
          document.querySelectorAll(".dash-card").forEach((el) => {
            el.classList.toggle(
              "active",
              el.getAttribute("data-name") === name
            );
          });
        }

        function openOptionsPanel() {
          const container = document.getElementById("buttonContainer");
          const toggle = document.getElementById("toggleBtn");
          if (!container || !toggle) return;

          container.classList.remove("hidden");
          container.style.display = "flex";

          toggle.textContent = "Hide Options";
        }

        async function updateDashboardCounts(items, softStats = null) {
          const gamesEl = document.getElementById("gamesTotal");
          const perfectEl = document.getElementById("perfectTotal");
          if (gamesEl) gamesEl.textContent = String(items.length);
          if (!perfectEl) return;
          const results = await Promise.all(
            items.map(async (it) => {
              try {
                const p = await computeCardProgress(it.name);
                return p.total > 0 && p.unlocked === p.total;
              } catch {
                return false;
              }
            })
          );
          perfectEl.textContent = String(results.filter(Boolean).length);
        }

        function setupDashboardSearch(gridEl) {
          const input = document.getElementById("dashboardSearchInput");
          if (!input || !gridEl) return;

          const norm = (s) =>
            (s || "")
              .toString()
              .toLowerCase()
              .normalize("NFD")
              .replace(/\p{Diacritic}/gu, "");

          const getCards = () => getDashCards(true);

          const prepareCards = () => {
            getCards().forEach((c) => {
              if (!c.dataset._search) {
                const name =
                  c.getAttribute("data-display") ||
                  c.getAttribute("data-name") ||
                  "";
                const appid = c.getAttribute("data-appid") || "";
                c.dataset._search = norm(name + " " + appid);
              }
            });
          };

          const applyFilter = () => {
            prepareCards();
            const q = norm(input.value.trim());
            const all = getDashCards(false);
            const hideBlacklisted = !blacklistState.showBlacklisted;

            if (!q) {
              all.forEach((c) => {
                const blocked =
                  hideBlacklisted && c.dataset.blacklisted === "1";
                c.style.display = blocked ? "none" : "";
              });
            } else {
              all.forEach((c) => {
                const matches = c.dataset._search.includes(q);
                const blocked =
                  hideBlacklisted && c.dataset.blacklisted === "1";
                c.style.display = matches && !blocked ? "" : "none";
              });
            }
          };

          if (input._filterHandler)
            input.removeEventListener("input", input._filterHandler);

          let filterDebounce = null;
          let focusIdleTimer = null;

          input._filterHandler = () => {
            clearTimeout(filterDebounce);
            filterDebounce = setTimeout(applyFilter, 60);
          };
          input.addEventListener("input", input._filterHandler);

          input.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              const v = getCards();
              if (v.length) {
                e.preventDefault();
                v[0].click();
              }
            } else if (e.key === "ArrowDown") {
              const v = getCards();
              if (v.length) {
                e.preventDefault();
                __dashNav.index = 0;
                focusCardAt(0);
                gridEl.focus();
              }
            } else if (e.key === "Escape") {
              if (input.value) {
                input.value = "";
                applyFilter();
              } else {
                try {
                  closeDashboard();
                } catch {}
              }
            }
          });

          input.resetSearch = () => {
            input.value = "";
            applyFilter();
          };

          prepareCards();
          applyFilter();
        }

        window.applyDashboardSortAndFilter = applyDashboardSortAndFilter;

        function clearDashboardSearch() {
          const input = document.getElementById("dashboardSearchInput");
          if (!input) return;
          if (typeof input.resetSearch === "function") {
            input.resetSearch();
          } else {
            input.value = "";
            const hideBlacklisted = !blacklistState.showBlacklisted;
            document
              .querySelectorAll("#dashboardGrid .dash-card")
              .forEach((c) => {
                const blocked =
                  hideBlacklisted && c.dataset.blacklisted === "1";
                c.style.display = blocked ? "none" : "";
              });
          }
          input.blur();
        }
        window.clearDashboardSearch = clearDashboardSearch;

        async function buildDashboard() {
          if (!gridEl || !window.api) return;
          await syncBlacklistList();

          // load configs and enrich with basic metadata
          let items = normalizeConfigList(await window.api.loadConfigs());
          cacheConfigMeta(items);
          if (!blacklistState.showBlacklisted) {
            items = items.filter((cfg) => !isAppIdInBlacklist(cfg.appid));
          }

          const quickCards = items.map((it) => {
            const key = DASH_PROGRESS_PREFIX + it.name;
            let stored = null;
            try {
              stored = JSON.parse(localStorage.getItem(key) || "null");
            } catch {
              stored = null;
            }
            const normalized = {
              pct: Number(stored?.pct) || 0,
              unlocked: Number(stored?.unlocked) || 0,
              total: Number(stored?.total) || 0,
              updated: Number(stored?.updated) || 0,
            };
            const imgCacheKey = IMG_CACHE_PREFIX + it.name;
            const cachedImg = localStorage.getItem(imgCacheKey);

            return {
              name: it.name,
              displayName: it.displayName || it.name,
              appid: it.appid || null,
              blacklisted: it.appid ? isAppIdInBlacklist(it.appid) : false,
              progress: normalized,
              img: cachedImg || fallbackIcon,
              hasCachedImg: Boolean(cachedImg),
            };
          });

          gridEl.innerHTML = "";
          const cardMeta = new Map();

          quickCards.forEach((cardData) => {
            const card = document.createElement("div");
            card.className = "dash-card";
            card.tabIndex = 0;
            card.setAttribute("role", "button");
            card.setAttribute(
              "aria-label",
              `${cardData.displayName} ‚Äì ${cardData.progress.pct}% complete`
            );
            card.dataset.name = cardData.name;
            card.dataset.display = cardData.displayName;
            card.dataset.pct = String(cardData.progress.pct);
            card.dataset.unlocked = String(cardData.progress.unlocked);
            card.dataset.total = String(cardData.progress.total);
            card.dataset.updated = String(cardData.progress.updated);
            card.dataset.blacklisted = cardData.blacklisted ? "1" : "0";

            const pill = document.createElement("div");
            pill.className = "dash-progresspill";
            pill.textContent = `${cardData.progress.pct}% Complete`;

            const img = document.createElement("img");
            img.className = "dash-thumb";
            img.loading = "lazy";
            img.decoding = "async";
            img.alt = cardData.displayName;
            img.src = cardData.img;
            if (!cardData.hasCachedImg) {
              img.dataset.src = cardData.img || fallbackIcon;
              ensureLazyObserver().observe(img);
            }

            const nameWrap = document.createElement("div");
            nameWrap.className = "dash-name";
            const title = document.createElement("div");
            title.className = "dash-title";
            title.title = cardData.displayName;
            title.textContent = cardData.displayName;
            const bar = document.createElement("div");
            bar.className = "dash-progressbar";
            const span = document.createElement("span");
            span.style.width = `${cardData.progress.pct}%`;
            bar.appendChild(span);

            nameWrap.appendChild(title);
            nameWrap.appendChild(bar);

            card.appendChild(pill);
            card.appendChild(img);
            card.appendChild(nameWrap);
            gridEl.appendChild(card);

            cardMeta.set(cardData.name, {
              element: card,
              pill,
              bar: span,
              img,
              data: { ...cardData },
            });
          });

          setupDashboardSearch(gridEl);
          updateDashboardCounts(items, quickCards);
          updateSortIconsUI();
          applyDashboardSortAndFilter();

          const detailJobs = items.map(async (it) => {
            const meta = cardMeta.get(it.name);
            if (!meta) return null;

            const cfg = await getConfigCached(it.name);
            const appid = cfg?.appid ? String(cfg.appid) : null;
            if (appid) {
              meta.element.dataset.appid = appid;
              meta.data.appid = appid;
            }
            const platform = cfg?.platform || null;
            const cardBlacklisted = appid && isAppIdInBlacklist(appid);
            meta.element.dataset.blacklisted = cardBlacklisted ? "1" : "0";
            meta.data.blacklisted = cardBlacklisted;
            if (platform) {
              meta.data.platform = platform;
            }
            let imgSrc = null;
            if (appid) {
              if (dashboardImageCache.has(appid)) {
                imgSrc = dashboardImageCache.get(appid);
              } else {
                try {
                  const p = await window.api.checkLocalGameImage(
                    appid,
                    platform || null
                  );
                  imgSrc = p ? fileUrl(p) : null;
                } catch {
                  imgSrc = null;
                }
                if (imgSrc) {
                  dashboardImageCache.set(appid, imgSrc);
                  localStorage.setItem(IMG_CACHE_PREFIX + it.name, imgSrc);
                  meta.img.dataset.src = imgSrc;
                  meta.img.src = imgSrc;
                  ensureLazyObserver().observe(meta.img);
                } else {
                  dashboardImageCache.delete(appid);
                  localStorage.removeItem(IMG_CACHE_PREFIX + it.name);
                  meta.img.dataset.src = fallbackIcon;
                  meta.img.src = fallbackIcon;
                }
              }

              if (imgSrc) {
                meta.img.dataset.src = imgSrc;
                meta.img.src = imgSrc;
                ensureLazyObserver().observe(meta.img);
                localStorage.setItem(IMG_CACHE_PREFIX + it.name, imgSrc);
              }
              const cardImg = meta.img;
              if (cardImg) {
                cardImg.addEventListener("error", () => {
                  cardImg.src = fallbackIcon;
                  localStorage.removeItem(IMG_CACHE_PREFIX + it.name);
                });
              }
            }

            async function refreshDashboardImage(appid) {
              const cards = Array.from(
                gridEl.querySelectorAll(`.dash-card[data-appid="${appid}"]`)
              );
              if (!cards.length) return;

              let imgSrc = null;
              try {
                const localPath = await window.api.checkLocalGameImage(
                  appid,
                  platform || null
                );
                if (localPath) imgSrc = fileUrl(localPath);
              } catch {
                /* ignore */
              }

              if (imgSrc) {
                dashboardImageCache.set(appid, imgSrc);
                localStorage.setItem(IMG_CACHE_PREFIX + it.name, imgSrc);
                meta.img.dataset.src = imgSrc;
                meta.img.src = imgSrc;
                ensureLazyObserver().observe(meta.img);
              } else {
                dashboardImageCache.delete(appid);
                cards.forEach((card) => {
                  localStorage.removeItem(IMG_CACHE_PREFIX + card.dataset.name);
                });
                imgSrc = fallbackIcon;
              }
              for (const card of cards) {
                const img = card.querySelector(".dash-thumb");
                if (!img) continue;
                img.dataset.src = imgSrc;
                img.src = imgSrc;
              }
            }

            if (!window.__dashboardImageListenerAttached) {
              window.api.onImageUpdate(async (payload) => {
                const appid =
                  typeof payload === "object" && payload?.appid
                    ? String(payload.appid)
                    : /^\d+$/.test(String(payload))
                    ? String(payload)
                    : null;
                if (!appid) return;
                await refreshDashboardImage(appid);
              });
              window.__dashboardImageListenerAttached = true;
            }

            const progress = await computeCardProgress(it.name);
            localStorage.setItem(
              DASH_PROGRESS_PREFIX + it.name,
              JSON.stringify(progress)
            );

            meta.bar.style.width = `${progress.pct}%`;
            meta.pill.textContent = `${progress.pct}% Complete`;
            meta.element.dataset.pct = String(progress.pct);
            meta.element.dataset.unlocked = String(progress.unlocked);
            meta.element.dataset.total = String(progress.total);
            meta.element.dataset.updated = String(progress.updated || 0);
            meta.data.progress = progress;

            return meta.data;
          });

          Promise.allSettled(detailJobs).then((resolved) => {
            const ready = resolved
              .map((r) => (r.status === "fulfilled" ? r.value : null))
              .filter((it) => it && it.progress);
            if (ready.length) {
              updateDashboardCounts(items, ready);
              scheduleIdle(() => updateDashboardCounts(items));
              applyDashboardSortAndFilter();
            }
          });

          (async function injectPlayButtons() {
            const cards = Array.from(gridEl.querySelectorAll(".dash-card"));
            const names = cards.map((c) => c.dataset.name).filter(Boolean);
            const configs = await Promise.all(names.map(getConfigCached));

            cards.forEach((card, idx) => {
              const cfgName = names[idx];
              const cfg = configs[idx];
              if (!cfg) return;

              const exe = cfg.executable || null;
              const args = cfg.arguments || "";
              if (card.querySelector(".dash-play")) return;

              const btn = document.createElement("button");
              btn.className = "dash-play";
              btn.setAttribute("aria-label", "Play");
              btn.title = exe ? "Play" : "No executable set";
              btn.innerHTML = '<i class="fas fa-play"></i>';

              if (!exe) {
                btn.classList.add("is-disabled");
                btn.setAttribute("aria-disabled", "true");
                btn.setAttribute("tabindex", "-1");
              }

              const swallowIfDisabled = (e) => {
                if (btn.classList.contains("is-disabled")) {
                  e.preventDefault();
                  e.stopImmediatePropagation();
                  return false;
                }
              };
              [
                "click",
                "pointerdown",
                "pointerup",
                "mousedown",
                "mouseup",
              ].forEach((t) =>
                btn.addEventListener(t, swallowIfDisabled, true)
              );

              btn.addEventListener("click", async (ev) => {
                ev.preventDefault();
                ev.stopPropagation();
                if (btn.classList.contains("is-disabled")) return;

                try {
                  const preset =
                    document.getElementById("presetDropdown")?.value;
                  const position =
                    document.getElementById("positionDropdown")?.value;

                  await window.api.updateConfig({
                    configName: cfgName,
                    preset,
                    position,
                  });

                  const sel = document.getElementById("configList");
                  if (sel) {
                    sel.value = cfgName;
                    sel.dispatchEvent(new Event("change", { bubbles: true }));
                  }
                } catch {}
                closeDashboard?.();

                const container = document.getElementById("buttonContainer");
                const toggleBtn = document.getElementById("toggleBtn");
                if (container) {
                  container.classList.remove("hidden");
                  container.style.display = "flex";
                }
                if (toggleBtn) toggleBtn.textContent = "Hide Options";

                if (exe) window.api.launchExecutable(exe, args);
              });

              const appidValue = cfg.appid ? String(cfg.appid) : null;
              const cardBlacklisted =
                appidValue && isAppIdInBlacklist(appidValue);
              card.dataset.blacklisted = cardBlacklisted ? "1" : "0";

              const blockBtn = document.createElement("button");
              blockBtn.className = "dash-block";
              const removing =
                blacklistState.showBlacklisted && cardBlacklisted;
              blockBtn.setAttribute(
                "aria-label",
                removing ? "Remove from blacklist" : "Ignore game"
              );
              blockBtn.title = removing
                ? "Remove this game from blacklist"
                : "Stop tracking this game";
              blockBtn.innerHTML = removing
                ? '<i class="fa-solid fa-check"></i>'
                : '<i class="fa-solid fa-ban"></i>';
              blockBtn.addEventListener("click", async (ev) => {
                ev.preventDefault();
                ev.stopPropagation();
                if (!appidValue) return;
                const removeMode =
                  blacklistState.showBlacklisted && cardBlacklisted;
                const confirmed = await window.ui.confirm({
                  title: removeMode ? "Remove from blacklist" : "Ignore game",
                  message: removeMode
                    ? `Remove ${cfgName} from blacklist?`
                    : `Ignore ${cfgName} and stop tracking it?`,
                });
                if (!confirmed) return;

                await window.ui.refocus();

                const response = await window.api.blacklistConfig({
                  configName: cfgName,
                  appid: appidValue,
                  remove: removeMode,
                });
                if (!response?.success) {
                  alert(response?.error || "Failed to update blacklist");
                  return;
                }

                localStorage.removeItem(`${DASH_PROGRESS_PREFIX}${cfgName}`);
                localStorage.removeItem(`${IMG_CACHE_PREFIX}${cfgName}`);
                dashboardImageCache?.delete?.(appidValue);
                if (Array.isArray(response.blacklist)) {
                  blacklistState.appids = new Set(response.blacklist);
                } else {
                  await syncBlacklistList();
                }

                if (typeof reloadConfigsDropdown === "function") {
                  await reloadConfigsDropdown(true);
                }
                await buildDashboard();
              });

              card.appendChild(blockBtn);
              card.appendChild(btn);
            });
          })();
          computeGridCols();
          const cards = getDashCards();
        }
        try {
          window.buildDashboard = buildDashboard;
        } catch {}

        const dashboardSchemaCache = new Map();
        const dashboardSavedCache = new Map();

        async function getSchemaCached(cfgName) {
          if (dashboardSchemaCache.has(cfgName)) {
            return dashboardSchemaCache.get(cfgName);
          }
          const achData = await window.api.loadAchievementData(cfgName);
          const list = Array.isArray(achData?.achievements)
            ? achData.achievements
            : [];
          dashboardSchemaCache.set(cfgName, list);
          return list;
        }

        async function getSavedCached(cfgName) {
          if (dashboardSavedCache.has(cfgName)) {
            return dashboardSavedCache.get(cfgName);
          }
          const saved = await window.api.loadSavedAchievements(cfgName);
          const savedMap = saved?.achievements || {};
          dashboardSavedCache.set(cfgName, savedMap);
          return savedMap;
        }

        async function computeCardProgress(cfgName) {
          try {
            const [list, savedMap] = await Promise.all([
              getSchemaCached(cfgName),
              getSavedCached(cfgName),
            ]);
            if (!list.length)
              return { pct: 0, unlocked: 0, total: 0, updated: 0 };

            let unlocked = 0;
            let maxTs = 0;
            for (const a of list) {
              const s = savedMap[a.name];
              if (s?.earned) unlocked++;
              const t = Number(s?.earned_time || 0);
              if (t > 0) {
                const tsMs = String(t).length === 10 ? t * 1000 : t;
                if (tsMs > maxTs) maxTs = tsMs;
              }
            }
            return {
              pct: Math.round((unlocked / list.length) * 100),
              unlocked,
              total: list.length,
              updated: maxTs,
            };
          } catch {
            return { pct: 0, unlocked: 0, total: 0, updated: 0 };
          }
        }

        async function updateCardProgressUI(cardEl, cfgName) {
          const { pct, unlocked, total, updated } = await computeCardProgress(
            cfgName
          );
          const bar = cardEl.querySelector(".dash-progressbar > span");
          const pill = cardEl.querySelector(".dash-progresspill");
          if (bar) bar.style.width = pct + "%";
          if (pill) {
            pill.textContent = `${pct}% Complete`;
            pill.title = total
              ? `Unlocked ${unlocked} / ${total}`
              : "No achievements found";
          }

          cardEl.dataset.pct = String(pct);
          cardEl.dataset.unlocked = String(unlocked);
          cardEl.dataset.total = String(total);
          cardEl.dataset.updated = String(updated || 0);

          const st =
            typeof getMultiSortState === "function"
              ? getMultiSortState()
              : null;
          if (st && (st.progress !== "off" || st.updated !== "off")) {
            applyDashboardSortAndFilter();
          }
        }

        try {
          window.updateCardProgressUI = updateCardProgressUI;
        } catch {}

        setupDashboardSearch(gridEl);

        function selectConfigInDropdown(name) {
          const sel = document.getElementById("configList");
          if (!sel) return false;

          const opt = Array.from(sel.options).find(
            (o) => o.value === name || o.text.trim() === name
          );
          if (opt) {
            sel.value = opt.value;
            sel.dispatchEvent(new Event("change", { bubbles: true }));
            return true;
          }
          return false;
        }
        function openCardFromDashboard(card) {
          if (!card) return;
          const safeName = card.getAttribute("data-name");

          if (typeof window.setActiveCard === "function") {
            window.setActiveCard(safeName);
          } else {
            document.querySelectorAll(".dash-card").forEach((el) => {
              el.classList.toggle(
                "active",
                el.getAttribute("data-name") === safeName
              );
            });
          }

          const selectInDropdown =
            typeof window.selectConfigInDropdown === "function"
              ? window.selectConfigInDropdown
              : function (name) {
                  const sel = document.getElementById("configList");
                  if (!sel) return false;
                  const opt = Array.from(sel.options).find(
                    (o) => o.value === name || o.text.trim() === name
                  );
                  if (opt) {
                    sel.value = opt.value;
                    sel.dispatchEvent(new Event("change", { bubbles: true }));
                    return true;
                  }
                  return false;
                };

          const ok = selectInDropdown(safeName);
          if (!ok && window.api?.updateConfig) {
            window.api.updateConfig({ configName: safeName });
          }

          const input = document.getElementById("dashboardSearchInput");
          if (input && typeof input.resetSearch === "function")
            input.resetSearch();

          const container = document.getElementById("buttonContainer");
          const toggle = document.getElementById("toggleBtn");
          if (container) {
            container.classList.remove("hidden");
            container.style.display = "flex";
          }
          if (toggle) toggle.textContent = "Hide Options";

          closeDashboard();
        }
        window.openCardFromDashboard = openCardFromDashboard;
        window.setActiveCard = setActiveCard;
        window.selectConfigInDropdown = selectConfigInDropdown;
        gridEl.onclick = (e) => {
          const card = e.target.closest(".dash-card");
          if (!card) return;
          openCardFromDashboard(card);

          const safeName = card.getAttribute("data-name");
          setActiveCard(safeName);

          const ok = selectConfigInDropdown(safeName);
          if (!ok && window.api?.updateConfig) {
            window.api.updateConfig({ configName: safeName });
          }
          const input = document.getElementById("dashboardSearchInput");
          if (input && typeof input.resetSearch === "function") {
            input.resetSearch();
          }

          openOptionsPanel();
          closeDashboard();
        };

        // --- MULTI-SORT ---
        const SORT_KEYS = ["name", "progress", "updated"];
        const STORE = {
          name: "dashSort:name",
          progress: "dashSort:progress",
          updated: "dashSort:updated",
        };

        function getMultiSortState() {
          return {
            name: localStorage.getItem(STORE.name) || "asc",
            progress: localStorage.getItem(STORE.progress) || "off",
            updated: localStorage.getItem(STORE.updated) || "off",
          };
        }
        function cycle(v) {
          return v === "off" ? "asc" : v === "asc" ? "desc" : "off";
        }

        function setSort(mode) {
          const st = getMultiSortState();
          st[mode] = cycle(st[mode]);
          localStorage.setItem(STORE[mode], st[mode]);
          updateSortIconsUI(st);
          applyDashboardSortAndFilter();
        }
        window.__dashboardCycleSort = setSort;

        function updateSortIconsUI(st = getMultiSortState()) {
          const setBtn = (id, state, title) => {
            const btn = document.getElementById(id);
            if (!btn) return;
            btn.classList.toggle("active", state !== "off");
            const dirEl = btn.querySelector(".dir");
            if (dirEl)
              dirEl.textContent =
                state === "asc" ? "‚Üë" : state === "desc" ? "‚Üì" : "¬∑";
            if (title) btn.title = title;
          };
          setBtn("sort-name", st.name, "Sort by name (A‚ÜíZ / Z‚ÜíA / Off)");
          setBtn(
            "sort-progress",
            st.progress,
            "Sort by progress (low‚Üíhigh / high‚Üílow / Off)"
          );
          setBtn(
            "sort-time",
            st.updated,
            "Sort by last updated (oldest‚Üínewest / newest‚Üíoldest / Off)"
          );
        }

        function applyDashboardSortAndFilter() {
          const grid = document.getElementById("dashboardGrid");
          if (!grid) return;

          const st = getMultiSortState();
          const focusedEl = grid.querySelector(".dash-card:focus");
          const activeEl = grid.querySelector(".dash-card.active");
          const keepName = (focusedEl || activeEl)?.dataset?.name || null;
          const cardStates = Array.from(
            grid.querySelectorAll(".dash-card")
          ).map((card) => ({
            card,
            display: card.style.display,
          }));

          const pri = ["updated", "progress", "name"];
          const mult = (k) => (st[k] === "asc" ? 1 : st[k] === "desc" ? -1 : 0);

          const cmp = (a, b) => {
            const cardA = a.card;
            const cardB = b.card;
            for (const k of pri) {
              const m = mult(k);
              if (!m) continue;

              if (k === "updated") {
                const da = Number(cardA.dataset.updated || 0),
                  db = Number(cardB.dataset.updated || 0);
                if (da !== db) return (da - db) * m;
              } else if (k === "progress") {
                const pa = Number(cardA.dataset.pct || 0),
                  pb = Number(cardB.dataset.pct || 0);
                if (pa !== pb) return (pa - pb) * m;
              } else if (k === "name") {
                const na =
                  cardA.getAttribute("data-display") ||
                  cardA.getAttribute("data-name") ||
                  "";
                const nb =
                  cardB.getAttribute("data-display") ||
                  cardB.getAttribute("data-name") ||
                  "";
                const res = na.localeCompare(nb, undefined, {
                  sensitivity: "base",
                });
                if (res !== 0) return res * m;
              }
            }
            const na =
              cardA.getAttribute("data-display") ||
              cardA.getAttribute("data-name") ||
              "";
            const nb =
              cardB.getAttribute("data-display") ||
              cardB.getAttribute("data-name") ||
              "";
            return na.localeCompare(nb, undefined, { sensitivity: "base" });
          };

          cardStates.sort(cmp);
          const frag = document.createDocumentFragment();
          cardStates.forEach(({ card, display }) => {
            card.style.display = display;
            frag.appendChild(card);
          });
          grid.appendChild(frag);

          const newlyFocused = window.focusFirstVisibleDashCard?.();
          if (!newlyFocused && keepName) {
            const keepCard = grid.querySelector(
              `.dash-card[data-name="${CSS.escape(keepName)}"]`
            );
            if (keepCard) {
              setActiveCard(keepName);
              keepCard.focus({ preventScroll: true });
              try {
                __dashNav.index = Math.max(
                  0,
                  getDashCards(false).indexOf(keepCard)
                );
              } catch {}
            }
          }
        }

        window.applyDashboardSortAndFilter = applyDashboardSortAndFilter;

        (function () {
          document
            .getElementById("sort-name")
            ?.addEventListener("click", () => setSort("name"));
          document
            .getElementById("sort-progress")
            ?.addEventListener("click", () => setSort("progress"));
          document
            .getElementById("sort-time")
            ?.addEventListener("click", () => setSort("updated"));

          window.addEventListener("DOMContentLoaded", updateSortIconsUI);
        })();

        document.addEventListener("keydown", (e) => {
          if (window.__unifiedNavActive) return;
          if (e.key !== "Escape") return;
          const settingsOpen = !document
            .getElementById("settingsMenu")
            ?.classList.contains("hidden");
          if (settingsOpen) return;
          closeDashboard();
        });

        window.api?.on?.("auto-select-config", (safeName) =>
          setActiveCard(safeName)
        );
        window.api?.on?.("refresh-achievements-table", () => {});
        window.api?.on?.("dashboard:poll-pause", (state) => {
          if (state) {
            pauseDashboardPoll();
          } else {
            __dashboardPollInterval = DASH_POLL_SLOW_MS;
            resumeDashboardPoll();
          }
        });
        window.api?.on?.("show-notification", (_data) => {
          window.__notificationBusy = true;
          setTimeout(() => {
            window.__notificationBusy = false;
            if (__dashboardPollSkipped && window.__dashboardOpen) {
              __dashboardPollSkipped = false;
              stopDashboardPoll();
              startDashboardPoll();
            }
          }, 1200);
        });
        window.api?.on?.("achievements:file-updated", (_evt, payload) => {
          const cfg = payload?.configName;
          if (cfg) {
            dashboardSavedCache.delete(cfg);
          }
        });
        window.api?.on?.("configs:changed", () => {
          dashboardSchemaCache.clear();
          dashboardSavedCache.clear();
        });
      })();

      let __zoomFactor = 1;
      let __isMaximized = false;
      let __displayWorkArea = null;

      const refreshDisplayWorkArea = async () => {
        if (!window.api?.getDisplayWorkArea) return;
        try {
          const metrics = await window.api.getDisplayWorkArea();
          if (
            metrics &&
            typeof metrics.width === "number" &&
            typeof metrics.height === "number"
          ) {
            __displayWorkArea = metrics;
          }
        } catch {}
      };

      const getViewportDimensions = () => {
        const viewport = {
          width:
            document.documentElement?.clientWidth || window.innerWidth || 0,
          height:
            document.documentElement?.clientHeight || window.innerHeight || 0,
        };

        const dpr = window.devicePixelRatio || 1;
        if (
          __displayWorkArea &&
          typeof __displayWorkArea.width === "number" &&
          typeof __displayWorkArea.height === "number"
        ) {
          viewport.width = Math.min(
            viewport.width,
            __displayWorkArea.width / dpr
          );
          viewport.height = Math.min(
            viewport.height,
            __displayWorkArea.height / dpr
          );
        } else if (window.visualViewport) {
          viewport.width = Math.min(
            viewport.width,
            window.visualViewport.width
          );
          viewport.height = Math.min(
            viewport.height,
            window.visualViewport.height
          );
        }

        return viewport;
      };
      function throttle(fn, wait = 100) {
        let timeout = null;
        let last = 0;
        const invoke = (...args) => {
          last = performance.now();
          timeout = null;
          fn(...args);
        };
        return (...args) => {
          const elapsed = performance.now() - last;
          if (elapsed >= wait) {
            if (timeout) clearTimeout(timeout);
            invoke(...args);
            return;
          }
          if (timeout) clearTimeout(timeout);
          timeout = setTimeout(() => invoke(...args), wait - elapsed);
        };
      }
      function computeDashSize() {
        const { width: vw, height: vh } = getViewportDimensions();
        const baseW = Math.min(
          __isMaximized ? 1600 : 1400,
          Math.max(860, (__isMaximized ? 0.995 : 0.98) * vw)
        );
        const baseH = Math.min(
          __isMaximized ? 1180 : 1080,
          Math.max(560, (__isMaximized ? 0.97 : 0.92) * vh)
        );

        let factor = 1;
        if (!__isMaximized) {
          const zoom = Math.max(__zoomFactor || 1, 0.01);
          factor = 1 / zoom;
          if (zoom <= 0.75) {
            factor *= 0.9;
          } else if (zoom == 1.25) {
            factor *= 1.3;
          } else if (zoom >= 1.25) {
            factor *= 1.5;
          }
        }

        return {
          width: Math.round(baseW * factor),
          height: Math.round(baseH * factor),
        };
      }

      function applyDashSize() {
        const panel = document.getElementById("dashboardPanel");
        if (!panel) return;

        const applyDashSizeThrottled = throttle(applyDashSize, 120);
        const { width: vw, height: vh } = getViewportDimensions();

        const baseW = __isMaximized
          ? vw
          : Math.min(1200, Math.max(820, 0.94 * vw));
        const baseH = __isMaximized
          ? vh
          : Math.min(980, Math.max(520, 0.86 * vh));
        let factor = 1;
        if (!__isMaximized) {
          const zoom = Math.max(__zoomFactor || 1, 0.01);
          factor = 1 / zoom;
          if (zoom <= 0.75) {
            factor *= 0.9;
          } else if (zoom == 1.25) {
            factor *= 1.3;
          } else if (zoom >= 1.25) {
            factor *= 1.5;
          }
        }

        const padX = __isMaximized
          ? Math.max(3, vw * 0.02)
          : Math.max(12, vw * 0.02);
        const padY = __isMaximized
          ? Math.max(85, vh * 0.04)
          : Math.max(12, vh * 0.02);

        const availableW = Math.max(0, vw - padX);
        const availableH = Math.max(0, vh - padY);

        let width = Math.min(Math.round(baseW * factor), availableW);
        let height = Math.min(Math.round(baseH * factor), availableH);

        if ((__zoomFactor || 1) >= 1.99) {
          const maxNormalWidth = __isMaximized
            ? availableW
            : Math.max(660, Math.min(880, availableW - 60));
          const maxNormalHeight = __isMaximized
            ? availableH
            : Math.max(740, Math.min(900, availableH - 80));
          width = Math.min(width, maxNormalWidth);
          height = Math.min(height, maxNormalHeight);
        }

        panel.style.width = `${width}px`;
        panel.style.height = `${height}px`;
      }
      const applyDashSizeThrottled = throttle(applyDashSize, 120);
      (window.electron?.ipcRenderer?.on || window.api?.on)?.(
        "configs:changed",
        async () => {
          try {
            const cfgs = await window.api.loadConfigs();
            const normalizedCfgs = normalizeConfigList(cfgs);
            rememberCoverNamesFromList(normalizedCfgs);
            if (typeof renderConfigs === "function")
              renderConfigs(normalizedCfgs);
            if (typeof reloadConfigsDropdown === "function")
              await reloadConfigsDropdown(true);
            if (window.__dashboardOpen) {
              await buildDashboard();
            }
          } catch (e) {
            console.warn("Failed to refresh configs on configs:changed:", e);
          }
        }
      );

      window.api?.on?.("zoom-factor-changed", (z) => {
        __zoomFactor = Number(z) || 1;
        document.body.dataset.zoom = String(
          Math.round((__zoomFactor || 1) * 100)
        );
        refreshDisplayWorkArea();
        applyDashSize();
        applyDashSizeThrottled();
        try {
          __updateAchStatsResponsive?.();
        } catch {}
      });

      window.electron?.ipcRenderer?.on?.("window-state-change", (isMax) => {
        __isMaximized = !!isMax;
        document.body.classList.toggle("window-maximized", __isMaximized);
        refreshDisplayWorkArea();
        applyDashSize();
        applyDashSizeThrottled();
      });

      const zoomDd = document.getElementById("app-zoom-dropdown");
      if (zoomDd) {
        zoomDd.addEventListener("change", (e) => {
          const z = parseFloat(e.target.value) || 1;
          __zoomFactor = z;
          document.body.dataset.zoom = String(
            Math.round((__zoomFactor || 1) * 100)
          );
          applyDashSize();
          applyDashSizeThrottled();
          window.api.setZoom(z);
        });
      }

      window.addEventListener("resize", () => {
        refreshDisplayWorkArea();
        applyDashSizeThrottled();
        try {
          __updateAchStatsResponsive?.();
        } catch {}
      });
      refreshDisplayWorkArea().then(applyDashSize);
      const dashboard = document.getElementById("dashboardOverlay");
      const dashboardBody = document.getElementById("dashboardBody");
      let dashboardScrollTop = 0;

      (function hookDashOpen() {
        const dashboard = document.getElementById("dashboardOverlay");
        const gridEl = document.getElementById("dashboardGrid");
        const btnToggle = document.getElementById("toggleDashboardBtn");
        const btnClose = document.getElementById("closeDashboard");
        if (!btnToggle || !dashboard) return;

        if (window.__dashHandlersBound) return;
        window.__dashHandlersBound = true;

        const onOpen = (e) => {
          e.preventDefault();
          window.openDashboard?.();
        };
        const onClose = (e) => {
          e.preventDefault();
          window.closeDashboard?.();
        };

        btnToggle.addEventListener("click", onOpen);
        btnClose?.addEventListener("click", onClose);
        dashboard.addEventListener("click", (e) => {
          if (e.target === dashboard) onClose(e);
        });

        window.addEventListener("DOMContentLoaded", async () => {
          try {
            await loadPreferencesCached();
            const prefs = getCachedPreferences();
            __zoomFactor = Number(prefs?.windowZoomFactor || 1) || 1;
          } catch {}
          applyDashSize();
          applyDashSizeThrottled();
          try {
            __updateAchStatsResponsive?.();
          } catch {}
        });
      })();
      // === achStats: responsive width guard (robust) ===
      (function makeAchStatsResponsive() {
        const stats = document.getElementById("achStats");
        if (!stats) return;
        const leftTop = document.getElementById("toggleDashboardBtn");
        const leftBot = document.getElementById("toggleBtn");
        const playBtn = document.getElementById("playBtn");

        function getFrame() {
          const vw =
            window.innerWidth || document.documentElement.clientWidth || 0;
          const frameW = Math.min(1100, Math.max(0, vw - 80));
          const frameLeft = (vw - frameW) / 2;
          return { left: frameLeft, right: frameLeft + frameW, width: frameW };
        }

        function update() {
          try {
            // Keep same behavior in both windowed + maximized; we only restrict to avoid overlap
            const frame = getFrame();
            const center = frame.left + frame.width / 2;
            const l1 = leftTop?.getBoundingClientRect?.();
            const l2 = leftBot?.getBoundingClientRect?.();
            const p = playBtn?.getBoundingClientRect?.();

            // Safe margins so we never touch buttons
            const safety = 60;
            const leftBound = Math.max(
              frame.left,
              Math.max(l1?.right || frame.left, l2?.right || frame.left) +
                safety
            );
            const rightBound = Math.min(
              frame.right,
              p?.left != null ? p.left - safety : frame.right
            );

            // Width symmetrical around center so a centered bar never intrudes into button zones
            const halfLeft = Math.max(0, center - leftBound);
            const halfRight = Math.max(0, rightBound - center);
            let maxWidthPx = Math.floor(2 * Math.min(halfLeft, halfRight));

            // Fallbacks to avoid collapsing at boot (layout not ready yet)
            if (!isFinite(maxWidthPx) || maxWidthPx <= 0) {
              maxWidthPx = Math.floor(frame.width * 0.5); // 50% of frame as safe default
            }
            // Clamp to frame width just in case
            maxWidthPx = Math.max(160, Math.min(maxWidthPx, frame.width));
            stats.style.maxWidth = `${maxWidthPx}px`;
          } catch {
            // In case of any transient failure, keep a safe default
            const frame = getFrame();
            stats.style.maxWidth = `${Math.floor(frame.width * 0.5)}px`;
          }
        }

        // Expose and schedule safely so first layout has happened
        window.__updateAchStatsResponsive = update;
        // Run after paint and again after load for fresh measurements
        requestAnimationFrame(() => {
          update();
          setTimeout(update, 60);
        });
        window.addEventListener("load", () => setTimeout(update, 0));
      })();

      function sanitizeConfigName(raw) {
        const s = String(raw || "")
          .replace(/[\\/\\:*?"<>|]/g, "")
          .replace(/\s+/g, " ")
          .trim()
          .replace(/[. ]+$/, "");
        const base = s || "config";
        return /^(con|prn|aux|nul|com[1-9]|lpt[1-9])$/i.test(base)
          ? `_${base}`
          : base;
      }

      window.api?.on?.("achievements:file-updated", async (payload) => {
        try {
          const { appid, configName } = payload || {};
          const cfg =
            configName || document.getElementById("configList")?.value;
          const selectedConfigRaw =
            document.getElementById("configList")?.value || "";
          const selectedConfig = sanitizeConfigName(selectedConfigRaw);
          const cfgSanitized = sanitizeConfigName(cfg);
          const sameAsActive =
            selectedConfig && cfgSanitized && selectedConfig === cfgSanitized;
          const autoSelectMatch =
            __watcherAutoSelect &&
            cfgSanitized &&
            __watcherAutoSelect === cfgSanitized;
          __watcherAutoSelect = null;
          if (!cfg) return;

          const [achData, saved] = await Promise.all([
            window.api.loadAchievementData(cfg),
            window.api.loadSavedAchievements(cfg),
          ]);

          const list = Array.isArray(achData?.achievements)
            ? achData.achievements
            : [];
          const savedMap = saved?.achievements || {};

          let unlocked = 0;
          for (const a of list) if (savedMap?.[a.name]?.earned) unlocked++;

          const K = `achPrevUnlocked:${cfg}`;
          const prev = Number(localStorage.getItem(K) || 0);

          const namesKey = `${K}:names`;
          const prevNames = JSON.parse(localStorage.getItem(namesKey) || "[]");
          if (unlocked > prev) {
            const shouldNotify = !sameAsActive || autoSelectMatch;
            await loadPreferencesCached();
            const prefs = getCachedPreferences() || {};
            const preset =
              prefs.preset ||
              document.getElementById("presetDropdown")?.value ||
              "default";
            const position =
              prefs.position ||
              document.getElementById("positionDropdown")?.value ||
              "center-bottom";
            const sound =
              prefs.sound ||
              document.getElementById("soundSelect")?.value ||
              "mute";
            const scale = parseFloat(
              prefs.notificationScale ||
                document.getElementById("scaleSlider")?.value ||
                1
            );
            const lang = prefs.language || window.currentLang || "english";
            const newlyEarned = list.filter((achievement) => {
              const state = savedMap?.[achievement.name];
              return state?.earned && !prevNames.includes(achievement.name);
            });
            for (const achievement of newlyEarned) {
              const displayName = getSafeLocalizedText(
                achievement.displayName,
                lang
              );
              const description = getSafeLocalizedText(
                achievement.description,
                lang
              );
              const icon =
                achievement.icon ||
                achievement.icon_gray ||
                achievement.icongray ||
                "";
              const iconGray =
                achievement.icon_gray || achievement.icongray || "";
              // notification sent by watcher (main process)
              // if (shouldNotify) {
              //   window.api.queueAchievementNotification({
              //     displayName,
              //     description,
              //     icon,
              //     icon_gray: iconGray,
              //     config_path: achData.config_path,
              //     preset,
              //     position,
              //     sound,
              //     scale,
              //   });
              // }
              if (shouldNotify && !prefs?.disableProgress) {
                const state = savedMap[achievement.name];
                if (
                  Number.isFinite(state?.progress) &&
                  Number.isFinite(state?.max_progress) &&
                  state.max_progress > 0
                ) {
                  window.api.queueProgressNotification({
                    displayName,
                    icon,
                    progress: state.progress,
                    max_progress: state.max_progress,
                    config_path: achData.config_path,
                  });
                }
              }
            }

            if (newlyEarned.length) {
              localStorage.setItem(
                namesKey,
                JSON.stringify([
                  ...new Set([...prevNames, ...newlyEarned.map((a) => a.name)]),
                ])
              );
              await window.loadLocalCover?.(String(appid));
            }
          }
          localStorage.setItem(K, String(unlocked));
        } catch (e) {
          console.warn("achievements:file-updated handler failed:", e);
        }
      });

      // GLOBAL NAV MANAGER (keyboard + gamepad)

      //Dashboard Navigation
      if (!window.dashboardArrow) {
        (function () {
          function visibleCards() {
            const grid = document.getElementById("dashboardGrid");
            if (!grid) return [];
            return Array.from(grid.querySelectorAll(".dash-card")).filter(
              (el) =>
                el.offsetParent !== null &&
                getComputedStyle(el).display !== "none"
            );
          }
          function gridCols() {
            const grid = document.getElementById("dashboardGrid");
            if (!grid) return 1;
            const tpl = getComputedStyle(grid).gridTemplateColumns || "";
            const cols = tpl.split(" ").filter(Boolean).length;
            return Math.max(cols || 1, 1);
          }
          window.dashboardArrow = function (evtOrKey) {
            const key = typeof evtOrKey === "string" ? evtOrKey : evtOrKey?.key;
            const cards = visibleCards();
            if (!cards.length) return;

            const active =
              document.querySelector("#dashboardGrid .dash-card.active") ||
              document.querySelector("#dashboardGrid .dash-card:focus") ||
              cards[0];
            let idx = Math.max(0, cards.indexOf(active));
            const cols = gridCols();

            switch (key) {
              case "ArrowLeft":
                idx -= 1;
                break;
              case "ArrowRight":
                idx += 1;
                break;
              case "ArrowUp":
                idx -= cols;
                break;
              case "ArrowDown":
                idx += cols;
                break;
              case "Home":
                idx = 0;
                break;
              case "End":
                idx = cards.length - 1;
                break;
              default:
                return;
            }
            window.dashboardFocusCardAt?.(idx);
          };
        })();
      }

      (function () {
        if (window.__unifiedNavActive) return;
        window.__unifiedNavActive = true;
        window.__unifiedGpActive = true;

        // ---- Options
        const DEADZONE = 0.4;
        const REPEAT_MS = 160;

        // ---- Utils
        const $ = (sel) => document.querySelector(sel);
        const byId = (id) => document.getElementById(id);
        const isHidden = (el) =>
          !el ||
          el.classList.contains("hidden") ||
          getComputedStyle(el).display === "none" ||
          getComputedStyle(el).visibility === "hidden";
        const isVisible = (el) => el && !isHidden(el);
        const isTypingTarget = (el) =>
          el &&
          (el.isContentEditable ||
            el.tagName === "INPUT" ||
            el.tagName === "TEXTAREA" ||
            el.tagName === "SELECT");

        // ---- RS scroll helpers ----

        window.__lastScrollSource = { src: null, t: 0 };
        function markScrollSource(src) {
          window.__lastScrollSource = { src, t: performance.now() };
        }
        function wasRSRecently(ms = 220) {
          const s = window.__lastScrollSource;
          return s && s.src === "rs" && performance.now() - s.t < ms;
        }
        const RS_DEADZONE = 0.5;
        const RS_BASE_SPEED = 1.5;
        const RS_ACCEL = 0.8;
        const RS_REPEAT_MS = 400;
        let __lastRS = 0;
        function canRepeatRS() {
          return performance.now() - __lastRS > RS_REPEAT_MS;
        }
        function tickRepeatRS() {
          __lastRS = performance.now();
        }

        function rsAxisToDelta(v) {
          const a = Math.abs(v);
          if (a < RS_DEADZONE) return 0;
          const t = (a - RS_DEADZONE) / (1 - RS_DEADZONE);
          const speed = RS_BASE_SPEED * (1 + t * t * RS_ACCEL);
          return Math.sign(v) * speed;
        }

        function canScroll(el, axis = "y") {
          if (!el) return false;
          if (
            el === document.scrollingElement ||
            el === document.documentElement ||
            el === document.body
          ) {
            return axis === "y"
              ? el.scrollHeight > el.clientHeight + 1
              : el.scrollWidth > el.clientWidth + 1;
          }
          const cs = getComputedStyle(el);
          const overflow = axis === "y" ? cs.overflowY : cs.overflowX;
          const canOverflow =
            overflow === "auto" ||
            overflow === "scroll" ||
            overflow === "overlay";
          return (
            canOverflow &&
            (axis === "y"
              ? el.scrollHeight > el.clientHeight + 1
              : el.scrollWidth > el.clientWidth + 1)
          );
        }

        function resolveScrollTarget({ axis = "y", overlay, focused }) {
          const candidates = [];

          const focusContainer = focused?.closest(
            ".tab-content, .settings-tabs-content, [data-scroll-container='1'], #dashboardBody, .modal-content"
          );
          if (focusContainer) candidates.push(focusContainer);

          if (overlay === "settings") {
            candidates.push(
              document.querySelector(".settings-tabs-content") ||
                document.querySelector(".settings-content")
            );
          } else if (overlay === "dashboard") {
            candidates.push(document.getElementById("dashboardBody"));
          } else if (overlay === "config") {
            const modal = document
              .getElementById("configModal")
              ?.querySelector(".modal-content");
            if (modal) candidates.push(modal);
          } else {
            const main = document.getElementById("mainScroll");
            if (main) candidates.push(main);
            candidates.push(
              document.querySelector(
                "[data-scroll-container='1'], .scroll-container"
              )
            );
            candidates.push(document.scrollingElement);
            candidates.push(document.documentElement);
            candidates.push(document.body);
          }

          return (
            candidates.filter(Boolean).find((el) => canScroll(el, axis)) || null
          );
        }

        function scrollByPage(direction) {
          const overlay =
            (typeof getActiveOverlaySafe === "function" &&
              getActiveOverlaySafe()) ||
            "main";
          const target = resolveScrollTarget({
            axis: "y",
            overlay,
            focused: document.activeElement,
          });
          if (!target) return;

          const step =
            target === document.body ||
            target === document.documentElement ||
            target === document.scrollingElement
              ? window.innerHeight
              : target.clientHeight;
          const delta = direction === "down" ? step : -step;

          if (
            target === document.body ||
            target === document.documentElement ||
            target === document.scrollingElement
          ) {
            window.scrollBy({ top: delta, behavior: "auto" });
          } else {
            target.scrollTop += delta;
          }
          markScrollSource("kb");
          if (overlay === "dashboard") {
            window.focusFirstVisibleDashCard?.();
          }
        }

        function findScrollableFrom(start, axis = "y") {
          let el = start;
          if (
            el &&
            el.tagName === "SELECT" &&
            el.getAttribute("data-sel-open") === "1"
          ) {
            return el;
          }
          while (el && el !== document.documentElement) {
            if (canScroll(el, axis)) return el;
            el = el.parentElement || el.parentNode;
          }
          return null;
        }

        function wheelOn(el, dx, dy) {
          if (!el) return;
          const evt = new WheelEvent("wheel", {
            deltaX: dx,
            deltaY: dy,
            bubbles: true,
            cancelable: true,
          });
          const notPrevented =
            el.dispatchEvent(evt) !== false && !evt.defaultPrevented;
          if (notPrevented) {
            if (Math.abs(dy) > 0 && canScroll(el, "y")) el.scrollTop += dy;
            if (Math.abs(dx) > 0 && canScroll(el, "x")) el.scrollLeft += dx;
          }
        }

        function rightStickScroll(dy, dx) {
          markScrollSource("rs");

          const overlay =
            (typeof getActiveOverlaySafe === "function" &&
              getActiveOverlaySafe()) ||
            "main";
          const focused = document.activeElement;
          if (
            focused &&
            focused.tagName === "SELECT" &&
            isSelectOpen?.(focused)
          ) {
            const mag = Math.abs(dy);
            if (mag < RS_DEADZONE) return;
            const step = mag > 0.75 ? 5 : 1;
            const sign = dy > 0 ? +1 : -1;
            moveSelectBy(focused, sign * step);
            return;
          }

          const axis = Math.abs(dy) >= Math.abs(dx) ? "y" : "x";

          const target = resolveScrollTarget({ axis, overlay, focused });
          if (!target) return;

          const amount = (axis === "y" ? dy : dx) * 20;
          if (axis === "y") target.scrollTop += amount;
          else target.scrollLeft += amount;

          if (
            axis === "y" &&
            window.__dashboardOpen &&
            target.id === "dashboardBody"
          ) {
            cancelAnimationFrame(window.__dashFocusRAF || 0);
            window.__dashFocusRAF = requestAnimationFrame(() => {
              if (!wasRSRecently()) return;

              const hoverCard = document.querySelector(
                "#dashboardGrid .dash-card:hover"
              );
              if (hoverCard) return;

              const active = document.activeElement?.closest?.(".dash-card");
              if (active) {
                const bodyRect = target.getBoundingClientRect();
                const r = active.getBoundingClientRect();
                const stillVisible =
                  r.bottom > bodyRect.top + 1 && r.top < bodyRect.bottom - 1;
                if (stillVisible) return;
              }

              window.focusFirstVisibleDashCard?.();
            });
          }
        }

        //Keyboard Scroll
        document.getElementById("dashboardBody")?.addEventListener(
          "scroll",
          () => {
            if (!wasRSRecently()) return;
            if (!window.__dashboardOpen) return;
            cancelAnimationFrame(window.__dashFocusRAF || 0);
            window.__dashFocusRAF = requestAnimationFrame(() => {
              window.focusFirstVisibleDashCard?.();
            });
          },
          { passive: true }
        );

        (function installScrollSourceMarkers() {
          const db = document.getElementById("dashboardBody");
          if (!db || db.__sourceMarkersInstalled) return;
          db.__sourceMarkersInstalled = true;

          db.addEventListener("wheel", () => markScrollSource("mouse"), {
            passive: true,
            capture: true,
          });
          db.addEventListener("touchmove", () => markScrollSource("touch"), {
            passive: true,
            capture: true,
          });
        })();

        // === Select dropdown behavior (Main Window) ===
        const SELECT_OPEN_ATTR = "data-sel-open";

        function isSelectEl(el) {
          return el && el.tagName === "SELECT";
        }
        function isSelectOpen(el) {
          return el && el.getAttribute(SELECT_OPEN_ATTR) === "1";
        }

        function placeholderIndex(select) {
          const opts = Array.from(select.options || []);
          let idx = opts.findIndex(
            (o) =>
              o.disabled ||
              o.value === "" ||
              /^select$/i.test((o.text || "").trim())
          );
          if (idx < 0) idx = 0;
          return idx;
        }
        function isSkippableOption(opt) {
          if (!opt) return true;
          const txt = (opt.text || "").trim();
          return opt.disabled || opt.value === "" || /^select$/i.test(txt);
        }

        function nextSelectableIndex(select, fromIndex, dir) {
          const { options } = select;
          let i = fromIndex;

          if (isSkippableOption(options[i])) {
            i = dir > 0 ? -1 : options.length;
          }
          for (let step = 0; step < options.length; step++) {
            i += dir;
            if (i < 0 || i >= options.length) break;
            if (!isSkippableOption(options[i])) return i;
          }
          return fromIndex;
        }

        function moveSelectBy(select, steps) {
          if (!select || select.tagName !== "SELECT" || !Number.isFinite(steps))
            return;
          const dir = Math.sign(steps);
          let todo = Math.abs(steps);
          let idx = select.selectedIndex;

          while (todo-- > 0) {
            const ni = nextSelectableIndex(select, idx, dir);
            if (ni === idx) break;
            idx = ni;
          }
          if (idx !== select.selectedIndex) {
            select.selectedIndex = idx;
            const opt = select.options[idx];
            if (opt) opt.scrollIntoView({ block: "nearest" });
          }
        }

        function openSelectList(select) {
          if (!isSelectEl(select) || isSelectOpen(select)) return;
          select.setAttribute(SELECT_OPEN_ATTR, "1");
          select.dataset.prevIndex = String(select.selectedIndex);
          const size = Math.max(2, Math.min(8, select.options.length || 2));
          select.classList.add("sel-open");
          select.setAttribute("size", String(size));
          select.focus({ preventScroll: true });
          const i = Math.max(0, select.selectedIndex);
          if (select.options[i])
            select.options[i].scrollIntoView({ block: "nearest" });
        }
        function closeSelectList(select, confirm) {
          if (!isSelectEl(select) || !isSelectOpen(select)) return;

          const prevIdxRaw = select.dataset.prevIndex;
          const prevIdx = Number.isFinite(+prevIdxRaw) ? +prevIdxRaw : -1;

          if (!confirm) {
            const fallback = placeholderIndex(select);
            const target = prevIdx >= 0 ? prevIdx : fallback;
            select.selectedIndex = Math.max(
              0,
              Math.min(select.options.length - 1, target)
            );
          }

          select.classList.remove("sel-open");
          select.removeAttribute("size");
          select.removeAttribute(SELECT_OPEN_ATTR);

          const changed =
            prevIdx >= 0 ? select.selectedIndex !== prevIdx : true;
          if (changed) {
            select.dispatchEvent(new Event("change", { bubbles: true }));
          }

          delete select.dataset.prevIndex;
          select.focus({ preventScroll: true });
        }

        window.__openMainSelectList = openSelectList;
        window.__closeMainSelectList = closeSelectList;

        function handleOpenSelectKey(e, select) {
          const key = e.key;
          if (key === "ArrowDown" || key === "ArrowUp") {
            e.preventDefault();
            e.stopPropagation();
            const dir = key === "ArrowDown" ? +1 : -1;
            let i = select.selectedIndex;
            i = Math.max(0, Math.min(select.options.length - 1, i + dir));
            select.selectedIndex = i;
            const opt = select.options[i];
            if (opt) opt.scrollIntoView({ block: "nearest" });
            return;
          }
          if (key === "Enter") {
            e.preventDefault();
            e.stopPropagation();
            closeSelectList(select, /*confirm*/ true);
            return;
          }
          if (key === "Escape" || key === "Backspace") {
            e.preventDefault();
            e.stopPropagation();
            closeSelectList(select, /*confirm*/ false);
            return;
          }

          if (key === "ArrowLeft" || key === "ArrowRight") {
            e.preventDefault();
            e.stopPropagation();
          }
        }

        function getActiveOverlaySafe() {
          if (typeof window.getActiveOverlay === "function") {
            try {
              return window.getActiveOverlay();
            } catch {
              /* fallback */
            }
          }
          const settings = byId("settingsMenu");
          const dashboard = byId("dashboardOverlay");
          const config = byId("configModal");
          if (settings && !settings.classList.contains("hidden"))
            return "settings";
          if (dashboard && dashboard.classList.contains("open"))
            return "dashboard";
          if (config && !config.classList.contains("hidden")) return "config";
          return "main";
        }

        window.focusablesIn = function focusablesIn(root) {
          if (!root) return [];
          const nodes = root.querySelectorAll(
            'button,[href],input,select,textarea,[tabindex]:not([tabindex="-1"])'
          );
          return Array.from(nodes).filter((el) => {
            if (el.disabled) return false;
            if (el.closest("[hidden]")) return false;
            const st = getComputedStyle(el);
            if (st.visibility === "hidden" || st.display === "none")
              return false;
            if (
              el.offsetWidth + el.offsetHeight + el.getClientRects().length ===
              0
            )
              return false;
            return true;
          });
        };

        function moveFocus(root, delta) {
          if (!root) return;
          const list = window.focusablesIn(root);
          if (!list.length) return;
          let idx = list.indexOf(document.activeElement);
          if (idx === -1) idx = delta > 0 ? -1 : 0;
          const next = list[(idx + delta + list.length) % list.length];
          next?.focus({ preventScroll: true });
          next?.scrollIntoView?.({ block: "nearest", inline: "nearest" });
        }

        // ---------- Settings navigation  ----------
        const __swallowScrollWhenSettings = (e) => {
          const open = !document
            .getElementById("settingsMenu")
            ?.classList.contains("hidden");
          if (!open) return;
          if (!e.target.closest(".settings-content")) {
            e.preventDefault();
            e.stopPropagation();
          }
        };

        document.addEventListener("wheel", __swallowScrollWhenSettings, {
          passive: false,
          capture: true,
        });
        document.addEventListener("touchmove", __swallowScrollWhenSettings, {
          passive: false,
          capture: true,
        });
        let __settingsMode = null; // 'tabs' | 'section'

        function activeSettingsTabBtn() {
          return $(".settings-tab.active") || $(".settings-tab");
        }
        function activeSettingsPanel() {
          const btn = activeSettingsTabBtn();
          const id = btn?.getAttribute("data-tab");
          if (id === "shortcuts") ensureShortcutsTabContent();
          return id ? byId(id + "Tab") : null;
        }
        function ensureShortcutsTabContent() {
          const tab = document.getElementById("shortcutsTab");
          if (!tab || tab.dataset.ready === "1") return;
          const tpl = document.getElementById("shortcutsTabTemplate");
          if (!tpl) return;
          tab.appendChild(tpl.content.cloneNode(true));
          tab.dataset.ready = "1";
        }
        window.ensureShortcutsTabContent = ensureShortcutsTabContent;
        function focusFirstInActiveSection() {
          const content = activeSettingsPanel() || $(".settings-content");
          const list = window
            .focusablesIn(content)
            .filter((el) => !el.closest(".settings-tabs"))
            .filter((el) => !el.classList.contains("settings-close-button"));
          (list[0] || content)?.focus({ preventScroll: true });
        }

        window.settingsEnterTabsMode = function () {
          __settingsMode = "tabs";
          window.__settingsMode = "tabs";
          const activeTab = document.querySelector(".settings-tab.active");
          if (activeTab) {
            activeTab.focus({ preventScroll: true });
          }
        };
        window.settingsEnterSectionMode = function () {
          __settingsMode = "section";
          window.__settingsMode = "section";
          const activePanel = activeSettingsPanel();
          if (activePanel) {
            const firstFocusable = window
              .focusablesIn(activePanel)
              .filter((el) => !el.closest(".settings-tabs"))
              .filter(
                (el) => !el.classList.contains("settings-close-button")
              )[0];
            (firstFocusable || activePanel)?.focus({ preventScroll: true });
          }
        };
        window.settingsTabsSelect = function () {
          const t = document.activeElement;
          if (t?.classList?.contains("settings-tab")) {
            t.click();
            setTimeout(() => window.settingsEnterSectionMode(), 0);
          }
        };
        window.settingsSectionFocusMove = function (delta) {
          const content = activeSettingsPanel() || $(".settings-content");
          const list = window
            .focusablesIn(content)
            .filter((el) => !el.closest(".settings-tabs"))
            .filter((el) => !el.classList.contains("settings-close-button"));
          if (!list.length) return;
          const cur = document.activeElement;
          let idx = list.findIndex(
            (el) => el === cur || (cur && el.contains(cur))
          );
          if (idx === -1) idx = delta > 0 ? -1 : 0;
          const next = list[(idx + delta + list.length) % list.length];
          next?.focus({ preventScroll: true });
          next?.scrollIntoView?.({ block: "nearest", inline: "nearest" });
        };

        function settingsAdjust(dir) {
          const el = document.activeElement;
          if (!el) return;
          if (el.tagName === "INPUT" && el.type === "checkbox") {
            el.checked = dir > 0;
            el.dispatchEvent(new Event("change", { bubbles: true }));
          } else if (el.tagName === "INPUT" && el.type === "range") {
            const step = parseFloat(el.step || "1") || 1;
            const min = parseFloat(el.min || "0") || 0;
            const max = parseFloat(el.max || "100") || 100;
            const next = Math.max(
              min,
              Math.min(max, Number(el.value) + step * dir)
            );
            el.value = String(next);
            el.dispatchEvent(new Event("input", { bubbles: true }));
          } else if (el.tagName === "SELECT") {
            const i = Math.min(
              el.options.length - 1,
              Math.max(0, el.selectedIndex + dir)
            );
            if (i !== el.selectedIndex) {
              el.selectedIndex = i;
              el.dispatchEvent(new Event("change", { bubbles: true }));
            }
          }
        }

        function settingsTabsFocusMove(delta) {
          const tabs = Array.from(document.querySelectorAll(".settings-tab"));
          if (!tabs.length) return;
          const focused = document.activeElement;
          let idx = tabs.indexOf(focused);
          if (idx < 0) idx = tabs.indexOf($(".settings-tab.active"));
          idx = (idx + delta + tabs.length) % tabs.length;
          tabs[idx]?.focus({ preventScroll: true });
        }
        function settingsTabsCycle(delta) {
          const tabs = Array.from(document.querySelectorAll(".settings-tab"));
          const active = $(".settings-tab.active");
          if (!tabs.length || !active) return;
          let i = tabs.indexOf(active);
          i = (i + delta + tabs.length) % tabs.length;
          tabs[i]?.click();
        }
        function settingsSectionActivate() {
          const el = document.activeElement;
          if (!el) return;
          if (el.tagName === "BUTTON") el.click();
          else if (el.tagName === "INPUT" && el.type === "checkbox") {
            el.checked = !el.checked;
            el.dispatchEvent(new Event("change", { bubbles: true }));
          } else if (el.tagName === "SELECT") el.click();
        }

        // ---- Actions
        const A = {
          UP: "UP",
          DOWN: "DOWN",
          LEFT: "LEFT",
          RIGHT: "RIGHT",
          HOME: "HOME",
          END: "END",
          CONFIRM: "CONFIRM",
          BACK: "BACK",
          SETTINGS: "SETTINGS",
          DASHBOARD: "DASHBOARD",
          OPTIONS: "OPTIONS",
          CONFIG: "CONFIG",
          PLAY: "PLAY",
          SEARCH: "SEARCH",
        };

        // ---- Command helpers
        function toggleSettings() {
          const settingsMenu = byId("settingsMenu");
          if (!settingsMenu) return;
          const open = settingsMenu.classList.contains("hidden") === false;
          if (open) {
            window.closeSettingsModal?.() || byId("closeSettingsBtn")?.click();
          } else {
            window.openSettingsModal?.() || byId("settingsBtn")?.click();
          }
        }
        function toggleDashboard() {
          if (window.__dashboardOpen) window.closeDashboard?.();
          else window.openDashboard?.();
        }
        function backOrClose() {
          const overlay = getActiveOverlaySafe();
          if (overlay === "settings") {
            const mode = (window.__settingsMode ?? __settingsMode) || "tabs";
            if (mode === "section") {
              window.settingsEnterTabsMode?.();
              return;
            }
            window.closeSettingsModal?.();
            return;
          }
          if (overlay === "dashboard") {
            window.closeDashboard?.();
            return;
          }
          if (overlay === "config") {
            byId("closeConfigModal")?.click();
            return;
          }
          const backBtn = byId("backButton");
          if (isVisible(backBtn)) {
            backBtn.click();
            return;
          }
          const configList = byId("configList");
          if (configList && configList.value) {
            configList.value = "";
            configList.dispatchEvent(new Event("change", { bubbles: true }));
          }
        }
        function openConfig() {
          byId("createNewConfigBtn")?.click();
        }
        function toggleOptions() {
          byId("toggleBtn")?.click();
        }
        function tryPlay() {
          if (window.__dashboardOpen) {
            const active =
              document.querySelector(".dash-card.active") ||
              document.querySelector(".dash-card");
            const btn = active?.querySelector?.(".dash-play:not(.is-disabled)");
            if (btn) {
              btn.click();
              return;
            }
            active?.click();
            return;
          }
          const btn = byId("playBtn");
          if (isVisible(btn)) btn.click();
        }
        function dashboardEnter() {
          const active =
            document.querySelector(".dash-card.active") ||
            document.querySelector(".dash-card");
          if (active) openCardFromDashboard(active); // A/Cross open CONFIG
        }
        function dashArrow(key) {
          if (typeof window.dashboardArrow === "function") {
            window.dashboardArrow({
              key,
              preventDefault() {},
              stopPropagation() {},
            });
          }
        }
        function settingsStep(delta) {
          const content = document.querySelector(".settings-content");
          if (content) moveFocus(content, delta);
        }
        function settingsTabCycle(dir) {
          const tabs = Array.from(document.querySelectorAll(".settings-tab"));
          const active = document.querySelector(".settings-tab.active");
          if (!tabs.length || !active) return;
          let i = tabs.indexOf(active);
          i = (i + dir + tabs.length) % tabs.length;
          tabs[i]?.click();
        }
        function adjustSelectOrRangeHoriz(dir) {
          const t = document.activeElement;
          if (!t) return;
          if (t.tagName === "SELECT") {
            t.selectedIndex = Math.min(
              t.options.length - 1,
              Math.max(0, t.selectedIndex + dir)
            );
            t.dispatchEvent(new Event("change"));
          } else if (t.type === "range") {
            const step = parseFloat(t.step || "1") || 1;
            const min = parseFloat(t.min || "0") || 0;
            const max = parseFloat(t.max || "100") || 100;
            const next = Math.max(
              min,
              Math.min(max, Number(t.value) + step * dir)
            );
            t.value = String(next);
            t.dispatchEvent(new Event("input"));
          }
        }

        // ---- Action router
        function route(action) {
          const overlay = getActiveOverlaySafe();
          //Main Window

          function isSkippableOption(opt) {
            if (!opt) return true;
            const txt = (opt.text || "").trim();
            return opt.disabled || opt.value === "" || /^select$/i.test(txt);
          }

          function nextSelectableIndex(select, fromIndex, dir) {
            const { options } = select;
            let i = fromIndex;

            if (isSkippableOption(options[i])) {
              i = dir > 0 ? -1 : options.length;
            }

            for (let step = 0; step < options.length; step++) {
              i += dir;
              if (i < 0 || i >= options.length) break;
              if (!isSkippableOption(options[i])) return i;
            }
            return fromIndex;
          }

          const focused = document.activeElement;
          if (
            focused &&
            focused.tagName === "SELECT" &&
            (action === A.LEFT || action === A.RIGHT)
          ) {
            const dir = action === A.LEFT ? -1 : +1;
            const nextIndex = nextSelectableIndex(
              focused,
              focused.selectedIndex,
              dir
            );
            if (nextIndex !== focused.selectedIndex) {
              focused.selectedIndex = nextIndex;
              focused.dispatchEvent(new Event("change", { bubbles: true }));
            }
            return;
          }

          // --- Controller-friendly SELECT handling (works in Main + Settings) ---
          if (focused && focused.tagName === "SELECT") {
            if (isSelectOpen && isSelectOpen(focused)) {
              if (action === A.UP || action === A.DOWN) {
                const dir = action === A.DOWN ? +1 : -1;
                let i = focused.selectedIndex;
                i = Math.max(0, Math.min(focused.options.length - 1, i + dir));
                if (i !== focused.selectedIndex) {
                  focused.selectedIndex = i;
                  const opt = focused.options[i];
                  if (opt) opt.scrollIntoView({ block: "nearest" });
                }
                return;
              }
              if (action === A.CONFIRM) {
                closeSelectList(focused, /*confirm*/ true);
                return;
              }
              if (action === A.BACK) {
                closeSelectList(focused, /*confirm*/ false);
                return;
              }
              if (action === A.LEFT || action === A.RIGHT) {
                return;
              }
            } else {
              if (action === A.CONFIRM) {
                openSelectList(focused, { preferNative: false });
                return;
              }
            }
          }

          // --- Global
          if (action === A.BACK) return backOrClose();
          if (action === A.SETTINGS) return toggleSettings();
          if (action === A.DASHBOARD) return toggleDashboard();
          if (action === A.OPTIONS) return toggleOptions();
          if (action === A.CONFIG) return openConfig();
          if (action === A.PLAY) return tryPlay();

          if (overlay === "settings") {
            const mode = (window.__settingsMode ?? __settingsMode) || "tabs";

            if (mode === "tabs") {
              if (action === A.DOWN) {
                settingsTabsFocusMove(+1);
                return;
              }
              if (action === A.UP) {
                settingsTabsFocusMove(-1);
                return;
              }
              if (action === A.CONFIRM) {
                settingsTabsSelect();
                return;
              }
              if (action === A.BACK) {
                window.closeSettingsModal?.();
                return;
              }
              return;
            }

            if (mode === "section") {
              if (action === A.DOWN) {
                settingsSectionFocusMove(+1);
                return;
              }
              if (action === A.UP) {
                settingsSectionFocusMove(-1);
                return;
              }
              if (action === A.LEFT) {
                settingsAdjust(-1);
                return;
              }
              if (action === A.RIGHT) {
                settingsAdjust(+1);
                return;
              }
              if (action === A.BACK) {
                settingsEnterTabsMode();
                return;
              }
              if (action === A.CONFIRM) {
                settingsSectionActivate();
                return;
              }
              return;
            }
          }

          if (overlay === "dashboard") {
            const markKb = () => markScrollSource("kb");
            if (action === A.UP) {
              markKb();
              return dashArrow("ArrowUp");
            }
            if (action === A.DOWN) {
              markKb();
              return dashArrow("ArrowDown");
            }
            if (action === A.LEFT) {
              markKb();
              return dashArrow("ArrowLeft");
            }
            if (action === A.RIGHT) {
              markKb();
              return dashArrow("ArrowRight");
            }
            if (action === A.HOME) {
              markKb();
              return dashArrow("Home");
            }
            if (action === A.END) {
              markKb();
              return dashArrow("End");
            }
            if (action === A.CONFIRM) return dashboardEnter();
            if (action === A.SEARCH) {
              if (window.__dashboardOpen) window.focusDashboardSearch?.(true);
              else {
                window.openDashboard?.();
                setTimeout(() => window.focusDashboardSearch?.(true), 0);
              }
              return;
            }
            return;
          }

          // main / config
          if (action === A.CONFIRM) {
            const f = document.activeElement;
            if (f && typeof f.click === "function") f.click();
            return;
          }
          if (action === A.UP || action === A.DOWN) {
            const container = byId("buttonContainer");
            if (container && isVisible(container))
              moveFocus(container, action === A.UP ? -1 : +1);
          }
          // LEFT/RIGHT
        }

        // ---- Keyboard
        function onKeyDown(e) {
          if (isTypingTarget(e.target) && e.key === "Backspace") {
            return;
          }
          const special =
            ["F1", "F2", "F3", "Escape", "Backspace"].includes(e.key) ||
            (e.ctrlKey &&
              ["o", "O", "d", "D", "n", "N", "Enter"].includes(e.key)) ||
            (e.key === "Enter" && (e.ctrlKey || e.shiftKey)) ||
            e.key.toLowerCase() === "p";
          const recording = byId("overlay-shortcut-btn")?.classList?.contains(
            "listening"
          );
          const overlayNow = getActiveOverlaySafe();
          const allowSettingsNavKey =
            overlayNow === "settings" &&
            [
              "ArrowUp",
              "ArrowDown",
              "ArrowLeft",
              "ArrowRight",
              "Home",
              "End",
              "Enter",
              " ",
              "PageUp",
              "PageDown",
            ].includes(e.key);
          const allowArrowsOnClosedSelectInMain =
            overlayNow === "main" &&
            e.target?.tagName === "SELECT" &&
            !isSelectOpen(e.target) &&
            (e.key === "ArrowUp" || e.key === "ArrowDown");

          if (
            isTypingTarget(e.target) &&
            !special &&
            !allowSettingsNavKey &&
            !allowArrowsOnClosedSelectInMain
          ) {
            return;
          }
          if (recording && !special) return;

          // --- Select dropdown open/close (Main) ---
          try {
            const overlayCtx = getActiveOverlaySafe && getActiveOverlaySafe();
            //const mode = (window.__settingsMode ?? __settingsMode) || null;
            const t = e.target;
            const inMain = overlayCtx === "main";
            const inSettings = overlayCtx === "settings";
            //const inSettingsSection = overlayCtx === "settings" && mode === "section";
            if ((inMain || inSettings) && isSelectEl && isSelectEl(t)) {
              if (isSelectOpen && isSelectOpen(t)) {
                handleOpenSelectKey(e, t);
                return;
              }
              if (e.key === "Enter") {
                e.preventDefault();
                e.stopPropagation();
                openSelectList(t);
                return;
              }
            }
          } catch {}

          // Global first
          if (e.key === "Escape") {
            e.preventDefault();
            return route(A.BACK);
          }
          if (e.key === "Backspace") {
            if (isTypingTarget(e.target)) return;
            e.preventDefault();
            return route(A.BACK);
          }
          if (e.key === "F1" || (e.ctrlKey && ["o", "O"].includes(e.key))) {
            e.preventDefault();
            return route(A.SETTINGS);
          }
          if (e.key === "F2" || (e.ctrlKey && ["d", "D"].includes(e.key))) {
            e.preventDefault();
            return route(A.DASHBOARD);
          }
          if (e.key === "F3") {
            e.preventDefault();
            return route(A.OPTIONS);
          }
          if (
            !isTypingTarget(e.target) &&
            (e.key.toLowerCase() === "p" ||
              (e.key === "Enter" && (e.ctrlKey || e.shiftKey)))
          ) {
            e.preventDefault();
            return route(A.PLAY);
          }
          if (e.ctrlKey && (e.key === "f" || e.key === "F")) {
            e.preventDefault();
            return route(A.SEARCH);
          }
          if (e.key === "PageUp" || e.key === "PageDown") {
            e.preventDefault();
            scrollByPage(e.key === "PageDown" ? "down" : "up");
            return;
          }

          if (
            overlayNow === "dashboard" &&
            e.altKey &&
            !e.ctrlKey &&
            !e.metaKey &&
            !e.shiftKey
          ) {
            if (e.key === "1") {
              e.preventDefault();
              window.__dashboardCycleSort?.("name");
              return;
            }
            if (e.key === "2") {
              e.preventDefault();
              window.__dashboardCycleSort?.("progress");
              return;
            }
            if (e.key === "3") {
              e.preventDefault();
              window.__dashboardCycleSort?.("updated");
              return;
            }
          }
          // Navigation
          const navKeys = {
            ArrowUp: A.UP,
            ArrowDown: A.DOWN,
            ArrowLeft: A.LEFT,
            ArrowRight: A.RIGHT,
            Home: A.HOME,
            End: A.END,
            Enter: A.CONFIRM,
            " ": A.CONFIRM,
          };
          if (e.key in navKeys) {
            e.preventDefault();
            route(navKeys[e.key]);
          }
          const overlay = getActiveOverlaySafe();
          if (
            overlay === "settings" &&
            [
              "ArrowUp",
              "ArrowDown",
              "ArrowLeft",
              "ArrowRight",
              "Home",
              "End",
            ].includes(e.key)
          ) {
            e.preventDefault();
            return;
          }
        }

        // ---- Gamepad
        let last = { ts: 0, buttons: {} };
        function edge(name, pressed) {
          const prev = !!last.buttons[name];
          last.buttons[name] = !!pressed;
          return !!pressed && !prev;
        }
        function canRepeat() {
          return performance.now() - last.ts > REPEAT_MS;
        }
        function tickRepeat() {
          last.ts = performance.now();
        }

        function gpLoop() {
          const pads = navigator.getGamepads
            ? Array.from(navigator.getGamepads()).filter(Boolean)
            : [];
          const pad = pads[0];
          const recording = byId("overlay-shortcut-btn")?.classList?.contains(
            "listening"
          );
          const windowActive =
            typeof document.hasFocus === "function"
              ? document.hasFocus()
              : document.visibilityState !== "hidden";
          const isVisible = document.visibilityState !== "hidden";

          if (!windowActive || !isVisible) {
            requestAnimationFrame(gpLoop);
            return;
          }

          if (pad && !recording) {
            const Abtn = !!pad.buttons?.[0]?.pressed; // A / Cross
            const Bbtn = !!pad.buttons?.[1]?.pressed; // B / Circle
            const Xbtn = !!pad.buttons?.[2]?.pressed; // X / Square
            const Ybtn = !!pad.buttons?.[3]?.pressed; // Y / Triangle
            const LB = !!pad.buttons?.[4]?.pressed; // L1 / LB
            const RB = !!pad.buttons?.[5]?.pressed; // R1 / RB
            const SEL = !!pad.buttons?.[8]?.pressed; // Select / Back
            const START = !!pad.buttons?.[9]?.pressed; // Start / Options
            const U = !!pad.buttons?.[12]?.pressed; // D-pad
            const D = !!pad.buttons?.[13]?.pressed;
            const L = !!pad.buttons?.[14]?.pressed;
            const R = !!pad.buttons?.[15]?.pressed;
            const lx = pad.axes?.[0] || 0;
            const ly = pad.axes?.[1] || 0;
            const rx = pad.axes?.[2] || 0; // Right Stick X
            const ry = pad.axes?.[3] || 0; // Right Stick Y

            const rsDy = rsAxisToDelta(ry);
            const rsDx = rsAxisToDelta(rx);
            if (rsDy !== 0 || rsDx !== 0) {
              rightStickScroll(rsDy, rsDx);
            }
            // Right Stick -> scroll/select
            if (
              (Math.abs(rx) > RS_DEADZONE || Math.abs(ry) > RS_DEADZONE) &&
              canRepeatRS()
            ) {
              rightStickScroll(ry, rx);
              tickRepeatRS();
            }
            // Global shortcuts
            const overlay = getActiveOverlaySafe?.() || "main";
            if (edge("SEL", SEL)) route(A.SETTINGS);
            if (edge("Y", Ybtn)) route(A.DASHBOARD);
            if (edge("B", Bbtn)) route(A.BACK);
            if (edge("X", Xbtn)) {
              if (overlay === "main") {
                route(A.OPTIONS);
              } else if (overlay === "dashboard") {
                route(A.SEARCH);
              }
            }
            if (edge("START", START)) route(A.PLAY);
            if (overlay === "dashboard") {
              if (edge("LB", LB)) window.__dashboardCycleSort?.("updated");
              if (edge("RB", RB)) window.__dashboardCycleSort?.("progress");
              if (edge("LS", pad.buttons?.[10]?.pressed)) {
                window.__dashboardCycleSort?.("name");
              }
            } else {
              if (edge("LB", LB)) settingsTabCycle(-1); // LB = tab
              if (edge("RB", RB)) settingsTabCycle(+1);
            }

            // D-pad + stick repeat
            if (canRepeat()) {
              if (U || ly < -DEADZONE) {
                route(A.UP);
                tickRepeat();
              } else if (D || ly > DEADZONE) {
                route(A.DOWN);
                tickRepeat();
              } else if (L || lx < -DEADZONE) {
                route(A.LEFT);
                tickRepeat();
              } else if (R || lx > DEADZONE) {
                route(A.RIGHT);
                tickRepeat();
              }
            }
            if (edge("A", Abtn)) route(A.CONFIRM);
          }

          requestAnimationFrame(gpLoop);
        }

        // ---- Init / Destroy
        function init() {
          if (window.__globalKeyHandler) {
            document.removeEventListener(
              "keydown",
              window.__globalKeyHandler,
              true
            );
          }
          document.addEventListener("keydown", onKeyDown, {
            capture: false,
            passive: false,
          });
          window.__globalKeyHandler = onKeyDown;
          requestAnimationFrame(gpLoop);
        }

        function destroy() {
          document.removeEventListener("keydown", onKeyDown, {
            capture: false,
          });
          window.__unifiedNavActive = false;
        }
        window.UnifiedNav = { destroy };
        init();
      })();
    </script>
  </body>
</html>
