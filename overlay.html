<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Achievements Overlay</title>
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css"
    />
    <style>
      /* Dracula Theme Color Variables */
      :root {
        --dracula-background: #282a36;
        --dracula-current-line: #44475a;
        --dracula-foreground: #f8f8f2;
        --dracula-comment: #6272a4;
        --dracula-cyan: #8be9fd;
        --dracula-green: #50fa7b;
        --dracula-orange: #ffb86c;
        --dracula-pink: #ff79c6;
        --dracula-purple: #bd93f9;
        --dracula-red: #ff5555;
        --dracula-yellow: #f1fa8c;
        --scrollbar-size: 8px;
      }

      html,
      body {
        background: transparent;
        margin: 0;
        padding: 0;
        overflow: hidden;
        user-select: none;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        color: var(--dracula-foreground);
        height: 100vh;
      }

      body.overlay-hidden .overlay-shell {
        opacity: 0;
        pointer-events: none;
      }

      /* Custom scrollbar (global) */
      *::-webkit-scrollbar {
        width: var(--scrollbar-size) !important;
        height: var(--scrollbar-size) !important;
      }

      *::-webkit-scrollbar-track {
        background: transparent !important;
      }

      *::-webkit-scrollbar-thumb {
        background: var(--dracula-purple) !important;
        border-radius: 4px;
      }

      *::-webkit-scrollbar-thumb:hover {
        background: var(--dracula-pink) !important;
      }

      .overlay-shell {
        display: flex;
        flex-direction: column;
        height: 100vh;
      }

      body.overlay-compact .overlay-shell {
        height: calc(var(--overlay-top-height, 0px) + 240px);
      }

      .overlay-container {
        flex: 1 1 auto;
        overflow-y: auto;
        scrollbar-width: thin;
        -ms-overflow-style: none;
        scrollbar-color: var(--dracula-purple) var(--dracula-background);
        background-color: rgba(40, 42, 54, 0.85);
        border-radius: 0 0 12px 12px;
        /* box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(8px); */
        border: 1px solid var(--dracula-purple);
        border-top: 0;
        position: relative;
        z-index: 1;
      }

      body.overlay-compact .overlay-container {
        max-height: 240px;
        overflow-y: hidden;
      }

      .overlay-container::-webkit-scrollbar {
        width: 6px;
      }

      .overlay-container::-webkit-scrollbar-thumb {
        background-color: var(--dracula-purple);
        border-radius: 3px;
      }

      .overlay-container::-webkit-scrollbar-track {
        background-color: transparent;
      }

      .overlay-top {
        flex: 0 0 auto;
        z-index: 10;
        background: rgba(40, 42, 54, 0.88);
        /* backdrop-filter: blur(8px); */
        pointer-events: auto;
        border-radius: 12px 12px 0 0;
        border: 1px solid var(--dracula-purple);
        border-bottom: 0;
        cursor: default;
        touch-action: none;
      }

      .overlay-header {
        background-color: rgba(68, 71, 90, 0.8);
        padding: 12px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--dracula-purple);
        border-top-left-radius: 12px;
        border-top-right-radius: 12px;
        z-index: 3;
        cursor: move;
      }

      .overlay-header h2 {
        margin: 0;
        color: var(--dracula-purple);
        font-size: 18px;
        font-weight: 500;
      }

      .overlay-stats {
        background-color: rgba(68, 71, 90, 0.6);
        padding: 10px 16px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        border-bottom: 1px solid var(--dracula-comment);
        z-index: 3;
      }

      .stats-item {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .stats-item i {
        color: var(--dracula-cyan);
      }

      .stats-item .value {
        font-weight: bold;
        color: var(--dracula-green);
      }

      .progress-bar {
        height: 6px;
        background-color: var(--dracula-current-line);
        border-radius: 3px;
        overflow: hidden;
        margin-top: 4px;
        width: 100%;
      }

      .progress-fill {
        height: 100%;
        background-color: var(--dracula-green);
        border-radius: 3px;
        transition: width 0.12s ease-out;
      }

      .progress-fill.no-transition {
        transition: none !important;
      }

      .achievements-list {
        padding: 0;
        margin: 0;
        list-style-type: none;
      }

      .achievement-item {
        padding: 12px 16px;
        border-bottom: 1px solid var(--dracula-current-line);
        display: flex;
        align-items: center;
        gap: 12px;
        transition: background-color 0.2s ease;
      }

      .achievement-item:hover {
        background-color: rgba(68, 71, 90, 0.4);
      }

      .achievement-icon {
        width: 48px;
        height: 48px;
        border-radius: 6px;
        object-fit: cover;
        border: 1px solid var(--dracula-comment);
      }

      .achievement-info {
        flex: 1;
      }

      .achievement-name {
        font-weight: bold;
        margin-bottom: 4px;
        color: var(--dracula-cyan);
      }

      .achievement-description {
        font-size: 0.9em;
        color: var(--dracula-foreground);
        opacity: 0.9;
        margin-bottom: 4px;
      }

      .achievement-progress {
        font-size: 0.8em;
        color: var(--dracula-comment);
      }

      .achievement-status {
        display: flex;
        flex-direction: column;
        align-items: flex-end;
        gap: 4px;
        min-width: 90px;
      }

      .status-locked {
        color: var(--dracula-red);
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .status-unlocked {
        color: var(--dracula-green);
        font-weight: bold;
        display: flex;
        align-items: center;
        gap: 4px;
      }

      .achievement-time {
        font-size: 0.8em;
        color: var(--dracula-comment);
      }

      .empty-state {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 40px 20px;
        text-align: center;
        color: var(--dracula-comment);
      }

      .empty-state i {
        font-size: 48px;
        margin-bottom: 16px;
        color: var(--dracula-purple);
      }

      .empty-state-message {
        font-size: 16px;
      }
    </style>
  </head>

  <body class="overlay-hidden">
    <div class="overlay-shell">
      <div class="overlay-top">
        <div class="overlay-header">
          <h2 id="overlayTitle">Achievements</h2>
          <div id="achievement-count" class="stats-item">
            <i class="fas fa-trophy"></i>
            <span class="value">0/0</span>
          </div>
        </div>

        <div class="overlay-stats">
          <div class="stats-item">
            <i class="fas fa-chart-simple"></i>
            <span id="overlayCompletionLabel">Completion:</span>
            <span id="completion-percentage" class="value">0%</span>
          </div>
          <div class="progress-bar">
            <div
              id="progress-fill"
              class="progress-fill"
              style="width: 0%"
            ></div>
          </div>
        </div>
      </div>
      <div class="overlay-container">
        <div id="empty-state" class="empty-state">
          <i class="fas fa-gamepad"></i>
          <div id="overlayEmptyMessage" class="empty-state-message">
            Select a game configuration to view achievements
          </div>
        </div>

        <ul id="achievements-list" class="achievements-list"></ul>
      </div>
    </div>

    <script src="utils/i18n-ui.js"></script>
    <script>
      let overlayLang = "english";
      let overlayUiLang = "english";
      let overlayPrefs = null;
      let overlayPrefsLoaded = false;
      const tUi = (key, fallback) =>
        window.i18nUi && typeof window.i18nUi.getString === "function"
          ? window.i18nUi.getString(key, fallback)
          : fallback;

      async function loadOverlayPrefs() {
        if (overlayPrefsLoaded && overlayPrefs) return overlayPrefs;
        try {
          overlayPrefs = await window.api.loadPreferences?.();
          overlayPrefsLoaded = true;
        } catch (e) {
          overlayPrefs = null;
          overlayPrefsLoaded = false;
        }
        return overlayPrefs || {};
      }
      let currentConfigName = null;
      let currentDataHash = null;
      let isLoading = false;
      let pendingConfigName = null;
      function getAppIconUrl() {
        const q = new URLSearchParams(location.search).get("icon");
        return q ? decodeURIComponent(q) : "";
      }
      function resolveAchievementIcon(imgEl, cfgPath, rel) {
        const FALLBACK = getAppIconUrl();
        const r = String(rel || "");
        const base = r.split(/[\\/]/).pop();

        const candidates = []
          .concat(r ? [`${cfgPath}\\${r}`] : [])
          .concat([
            `${cfgPath}\\achievement_images\\${base}`,
            `${cfgPath}\\steam_settings\\achievement_images\\${base}`,
            `${cfgPath}\\img\\${base}`,
            `${cfgPath}\\images\\${base}`,
          ])
          .filter((v, i, a) => v && a.indexOf(v) === i)
          .map((p) => `file:///${p.replace(/\\/g, "/")}`);

        let i = 0;
        const tryNext = () => {
          if (i >= candidates.length) {
            imgEl.src = FALLBACK;
            return;
          }
          imgEl.onerror = () => {
            i++;
            tryNext();
          };
          imgEl.src = candidates[i];
        };
        tryNext();
      }

      async function applyOverlayLanguage() {
        const prefs = await loadOverlayPrefs();
        const lang = prefs?.uiLanguage || prefs?.language || "english";
        overlayUiLang = String(lang || "english");
        if (
          window.i18nUi &&
          typeof window.i18nUi.setUiLanguage === "function"
        ) {
          await window.i18nUi.setUiLanguage(overlayUiLang);
        }
      }

      function getSafeLocalizedText(input, lang = "english") {
        const hiddenFallback = tUi("overlay.hiddenFallback", "Hidden");
        if (!input) return hiddenFallback;
        if (typeof input === "string") return input.trim() || hiddenFallback;
        if (typeof input === "object") {
          return (
            input[lang] ||
            input.english ||
            Object.values(input).find(
              (v) => typeof v === "string" && v.trim() !== "",
            ) ||
            hiddenFallback
          );
        }
        return hiddenFallback;
      }

      function normalizeEarnedTime(raw) {
        const t = Number(raw);
        if (!Number.isFinite(t) || t <= 0) return 0;
        const ms = String(Math.trunc(t)).length === 10 ? t * 1000 : t;
        return ms >= 946684800000 ? ms : 0;
      }

      function formatTimestamp(timestamp) {
        const ms = normalizeEarnedTime(timestamp);
        if (!ms) return tUi("overlay.notAvailable", "N/A");
        const d = new Date(ms);
        return isNaN(d)
          ? tUi("overlay.notAvailable", "N/A")
          : d.toLocaleString();
      }

      function computeAchievementsHash(achievements, saved, lang) {
        return achievements
          .map((ach) => {
            const name = ach.name;
            const display = getSafeLocalizedText(ach.displayName, lang);
            const savedData = saved?.achievements?.[name] || {};
            const earned = savedData.earned ? "1" : "0";
            const progress = savedData.progress ?? "";
            const max = savedData.max_progress ?? "";
            return `${name}-${display}-${earned}-${progress}-${max}`;
          })
          .join("|");
      }

      function updateStats(achievements, savedData) {
        const total = achievements.length;
        const unlocked = achievements.reduce((count, ach) => {
          const saved = savedData?.achievements?.[ach.name];
          return count + (saved?.earned ? 1 : 0);
        }, 0);

        const percentage = total > 0 ? Math.round((unlocked / total) * 100) : 0;
        const fillEl = document.getElementById("progress-fill");
        if (!fillEl) return;

        if (percentage === 0) {
          const prevTransition = fillEl.style.transition;
          fillEl.style.transition = "none";
          fillEl.style.width = "0%";
          void fillEl.offsetWidth;
          requestAnimationFrame(() => {
            fillEl.style.transition = prevTransition;
          });
        } else {
          fillEl.style.width = `${percentage}%`;
        }

        document
          .getElementById("achievement-count")
          .querySelector(".value").textContent = `${unlocked}/${total}`;
        document.getElementById("completion-percentage").textContent =
          `${percentage}%`;
      }

      async function loadAchievements(configName) {
        const achievementsList = document.getElementById("achievements-list");
        const emptyState = document.getElementById("empty-state");

        if (!configName) return;

        if (isLoading) {
          pendingConfigName = configName;
          return;
        }
        isLoading = true;
        pendingConfigName = null;

        try {
          await applyOverlayLanguage();
          const achievementsDataObj =
            await window.api.loadAchievementData(configName);
          const savedAchievementsObj =
            await window.api.loadSavedAchievements(configName);
          const lang = overlayLang;
          const prefs = await loadOverlayPrefs();

          if (!Array.isArray(achievementsDataObj.achievements)) {
            emptyState.style.display = "flex";
            achievementsList.style.display = "none";
            updateStats([], null);
            document.body.classList.add("overlay-compact");
            currentConfigName = configName;
            currentDataHash = null;
            return;
          }

          const newHash = computeAchievementsHash(
            achievementsDataObj.achievements,
            savedAchievementsObj,
            lang,
          );
          if (pendingConfigName && pendingConfigName !== configName) return;

          const isSameConfig = currentConfigName === configName;
          const isSameHash = currentDataHash === newHash;
          if (isSameConfig && isSameHash) return;

          emptyState.style.display = "none";
          achievementsList.style.display = "block";
          achievementsList.innerHTML = "";
          document.body.classList.remove("overlay-compact");

          const uniqueAchievements = new Set();
          const achievements = [];

          achievementsDataObj.achievements.forEach((achievement) => {
            if (!achievement.name || uniqueAchievements.has(achievement.name))
              return;
            uniqueAchievements.add(achievement.name);
            achievements.push(achievement);
          });

          // Update stats
          updateStats(achievements, savedAchievementsObj);

          // Sort achievements: unlocked first, then locked
          achievements.sort((a, b) => {
            const aUnlocked = savedAchievementsObj?.achievements?.[a.name]
              ?.earned
              ? 1
              : 0;
            const bUnlocked = savedAchievementsObj?.achievements?.[b.name]
              ?.earned
              ? 1
              : 0;
            return bUnlocked - aUnlocked;
          });

          achievements.forEach((achievement) => {
            const displayName = getSafeLocalizedText(
              achievement.displayName,
              lang,
            );
            const description = getSafeLocalizedText(
              achievement.description,
              lang,
            );
            const iconGray = achievement.icon_gray || achievement.icongray;
            const icon = achievement.icon || iconGray;
            const isHidden = Number(achievement.hidden) === 1;

            let statusHTML = `<div class="status-locked"><i class="fas fa-lock"></i> ${tUi(
              "overlay.statusLocked",
              "Locked",
            )}</div>`;
            let earnedTimeHTML = "";
            let progressHTML = "";
            const saved =
              savedAchievementsObj?.achievements?.[achievement.name];
            const isUnlocked = !!saved?.earned;
            const rel = isUnlocked ? icon : iconGray;
            const showHidden = prefs?.showHiddenDescription === true;
            const descText =
              isHidden && !isUnlocked && !showHidden
                ? tUi("overlay.hiddenFallback", "Hidden")
                : description;

            if (saved?.earned) {
              statusHTML = `<div class="status-unlocked"><i class="fas fa-unlock"></i> ${tUi(
                "overlay.statusUnlocked",
                "Unlocked",
              )}</div>`;
              earnedTimeHTML = `<div class="achievement-time">${formatTimestamp(
                saved.earned_time,
              )}</div>`;
            }

            if (
              Number.isFinite(saved?.progress) &&
              Number.isFinite(saved?.max_progress) &&
              saved.max_progress > 0
            ) {
              const progressPercentage = Math.min(
                100,
                Math.round((saved.progress / saved.max_progress) * 100),
              );
              progressHTML = `
                    <div class="achievement-progress">
                    ${tUi("overlay.progressLabel", "Progress")}: ${saved.progress} / ${saved.max_progress}
                    <div class="progress-bar" style="margin-top: 4px; height: 4px;">
                        <div class="progress-fill" style="width: ${progressPercentage}%;"></div>
                    </div>
                    </div>`;
            }

            const listItem = document.createElement("li");
            listItem.className = "achievement-item";
            listItem.innerHTML = `
          <img class="achievement-icon" alt="Icon">
            <div class="achievement-info">
              <div class="achievement-name">${displayName}</div>
            <div class="achievement-description">${descText}</div>
            ${progressHTML}
          </div>
          <div class="achievement-status">
            ${statusHTML}
            ${earnedTimeHTML}
          </div>
        `;
            achievementsList.appendChild(listItem);

            const imgEl = listItem.querySelector("img.achievement-icon");
            resolveAchievementIcon(imgEl, achievementsDataObj.config_path, rel);
          });

          currentConfigName = configName;
          currentDataHash = newHash;
        } finally {
          isLoading = false;
          const next = pendingConfigName;
          pendingConfigName = null;
          if (next) loadAchievements(next);
        }
      }

      window.api.onSetLanguage((payload) => {
        let uiLanguageChanged = false;
        if (payload && typeof payload === "object") {
          if (payload.language) {
            overlayLang = payload.language;
          }
          if (payload.uiLanguage) {
            overlayUiLang = String(payload.uiLanguage || "english");
            uiLanguageChanged = true;
            overlayPrefs = {
              ...(overlayPrefs || {}),
              uiLanguage: overlayUiLang,
            };
            if (
              window.i18nUi &&
              typeof window.i18nUi.setUiLanguage === "function"
            ) {
              window.i18nUi.setUiLanguage(overlayUiLang);
            }
          }
        } else {
          overlayLang = payload;
        }
        if (uiLanguageChanged) {
          currentDataHash = null;
        }
        if (currentConfigName) {
          loadAchievements(currentConfigName);
        }
      });

      window.api.onLoadOverlayData((configName) => {
        const achievementsList = document.getElementById("achievements-list");
        const emptyState = document.getElementById("empty-state");

        if (!configName) {
          achievementsList.innerHTML = "";
          emptyState.style.display = "flex";
          achievementsList.style.display = "none";
          updateStats([], null);
          document.body.classList.add("overlay-compact");
          currentConfigName = null;
          currentDataHash = null;
          pendingConfigName = null;
          isLoading = false;
          return;
        }

        if (configName !== currentConfigName) {
          currentDataHash = null;
        }
        currentConfigName = configName;
        pendingConfigName = null;

        loadAchievements(configName);
      });

      window.api.onRefreshAchievementsTable(() => {
        if (currentConfigName) {
          loadAchievements(currentConfigName);
        }
      });

      window.api.on("overlay-preferences-updated", (payload) => {
        if (!payload || typeof payload !== "object") return;
        if (
          Object.prototype.hasOwnProperty.call(payload, "showHiddenDescription")
        ) {
          overlayPrefs = {
            ...(overlayPrefs || {}),
            showHiddenDescription: payload.showHiddenDescription === true,
          };
          overlayPrefsLoaded = true;
          currentDataHash = null;
          if (currentConfigName) {
            loadAchievements(currentConfigName);
          }
        }
      });

      function setOverlayVisible(visible) {
        document.body.classList.toggle("overlay-hidden", !visible);
      }

      window.api.on("overlay:set-visible", (payload) => {
        const visible =
          payload && typeof payload === "object" ? payload.visible : payload;
        setOverlayVisible(!!visible);
      });

      function setupOverlayDrag() {
        const dragHandle = document.querySelector(".overlay-header");
        if (!dragHandle) return;
        if (
          !window.api ||
          typeof window.api.getWindowPosition !== "function" ||
          typeof window.api.setWindowPosition !== "function" ||
          typeof window.api.startOverlayDrag !== "function" ||
          typeof window.api.endOverlayDrag !== "function"
        ) {
          return;
        }

        let dragActive = false;

        const endDrag = () => {
          if (!dragActive) return;
          dragActive = false;
          window.api.endOverlayDrag();
          try {
            window.removeEventListener("mouseup", endDrag, true);
            document.removeEventListener("mouseup", endDrag, true);
          } catch {}
        };

        const startDrag = async (event) => {
          if (event.button !== 0) return;
          event.preventDefault();
          if (dragActive) return;

          let winX = Number(window.screenX);
          let winY = Number(window.screenY);
          try {
            const pos = await window.api.getWindowPosition();
            if (Array.isArray(pos) && pos.length >= 2) {
              const px = Number(pos[0]);
              const py = Number(pos[1]);
              if (Number.isFinite(px) && Number.isFinite(py)) {
                winX = px;
                winY = py;
              }
            }
          } catch {}

          if (!Number.isFinite(winX) || !Number.isFinite(winY)) return;

          const sx = Number(event.screenX);
          const sy = Number(event.screenY);
          const cx = Number(event.clientX);
          const cy = Number(event.clientY);
          const screenX = Number.isFinite(sx) ? sx : winX + cx;
          const screenY = Number.isFinite(sy) ? sy : winY + cy;

          if (!Number.isFinite(screenX) || !Number.isFinite(screenY)) return;

          const offsetX = screenX - winX;
          const offsetY = screenY - winY;
          if (!Number.isFinite(offsetX) || !Number.isFinite(offsetY)) return;

          dragActive = true;
          window.api.startOverlayDrag({ offsetX, offsetY });
          window.addEventListener("mouseup", endDrag, true);
          document.addEventListener("mouseup", endDrag, true);
        };

        dragHandle.addEventListener("mousedown", startDrag, true);
        document.addEventListener("visibilitychange", () => {
          if (document.hidden) endDrag();
        });
      }

      function setupOverlayKeyboardScroll() {
        if (!window.api || typeof window.api.on !== "function") return;
        const container = document.querySelector(".overlay-container");
        if (!container) return;

        window.api.on("overlay:scroll-page", (payload) => {
          const dir =
            payload && typeof payload === "object"
              ? payload.direction
              : payload;
          const direction = String(dir || "").toLowerCase();
          const page = Math.max(120, Math.round(container.clientHeight * 0.85));
          if (direction === "up") {
            container.scrollBy({ top: -page, behavior: "smooth" });
            return;
          }
          if (direction === "down") {
            container.scrollBy({ top: page, behavior: "smooth" });
          }
        });
      }

      function setupOverlayDragRegion() {
        if (
          !window.api ||
          typeof window.api.setOverlayDragRegionHeight !== "function"
        ) {
          return;
        }
        const top = document.querySelector(".overlay-top");
        if (!top) return;

        const sendHeight = () => {
          const rect = top.getBoundingClientRect();
          if (rect && rect.height) {
            window.api.setOverlayDragRegionHeight(Math.round(rect.height));
          }
        };

        try {
          const ro = new ResizeObserver(() => sendHeight());
          ro.observe(top);
        } catch {
          window.addEventListener("resize", sendHeight);
        }

        sendHeight();
      }

      window.onload = () => {
        window.api.requestCurrentConfig?.();
        setupOverlayKeyboardScroll();
        setupOverlayDragRegion();
      };
    </script>
  </body>
</html>
