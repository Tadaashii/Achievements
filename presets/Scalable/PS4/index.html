<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="style.css" />
    <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>
    <title>Popup Animation</title>
    <meta name="duration" content="5000" />
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background: transparent;

        display: flex;
        align-items: center;
        justify-content: center;
      }

      body {
        transform-origin: center center;
      }
    </style>
  </head>
  <body>
    <meta width="400" height="125" />
    <div>
      <div class="ach">
        <div class="icon">
          <img src="" alt="Icon" />
        </div>
        <div class="text_wrap">
          <p class="title"></p>
          <span class="detail"></span>
        </div>
        <div class="ring-container">
          <div class="ringring"></div>
          <div class="circle">
            <img src="./psicon.png" height="9" />
          </div>
        </div>
      </div>
    </div>
    <script>
      window.addEventListener("DOMContentLoaded", () => {
        // Helpers similar to Scalable/Steam for direction + restart
        const metaDur = document.querySelector('meta[name="duration"]');
        const baseTotal = Math.max(1, Number(metaDur?.content || 5000));
        function computeFromTopFallback() {
          try {
            const yMid = (window.screenY || 0) + (window.outerHeight || 0) / 2;
            const h = screen.availHeight || screen.height || 1080;
            return yMid < h / 2;
          } catch {
            return false;
          }
        }
        function setDirectionByPosition(ach, posString) {
          const pos = String(posString || "").toLowerCase();
          const fromTop =
            pos.includes("top") || (!pos && computeFromTopFallback());
          const atLeft = pos.includes("left");
          const atRight = pos.includes("right");
          ach.classList.remove(
            "from-top",
            "from-bottom",
            "at-left",
            "at-center",
            "at-right"
          );
          ach.classList.add(fromTop ? "from-top" : "from-bottom");
          ach.classList.add(
            atLeft ? "at-left" : atRight ? "at-right" : "at-center"
          );
        }
        function restartAnimation(ach, totalMs) {
          ach.classList.remove("active");
          void ach.offsetWidth;
          ach.classList.add("active");
          setTimeout(() => {
            ach.classList.remove("active");
            window.api?.closeNotificationWindow?.();
          }, totalMs);
        }
        window.api.onNotification((notificationData) => {
          // Element refs
          const ach = document.querySelector(".ach");
          const titleEl = document.querySelector(".title");
          const detailEl = document.querySelector(".detail");
          let scaleValue = 1;

          if (
            notificationData &&
            notificationData.displayName &&
            notificationData.description &&
            notificationData.iconPath
          ) {
            titleEl.textContent = notificationData.displayName;
            detailEl.textContent = notificationData.description;
            document.querySelector(
              ".icon img"
            ).src = `file:///${notificationData.iconPath}`;
            scaleValue = parseFloat(notificationData.scale || 1) || 1;
            ach.style.setProperty("--scale", scaleValue);
          }
          // Direction + restart like Steam
          setDirectionByPosition(ach, notificationData?.position);
          const total = Math.max(0, Number(metaDur?.content || baseTotal));
          const timelineScale = Math.max(0.1, total / baseTotal);
          const inDur = Math.max(120, Math.round(500 * timelineScale));
          const outDur = Math.max(120, Math.round(500 * timelineScale));
          const outDelay = Math.max(0, total - outDur);
          ach?.style?.setProperty("--inDur", `${inDur}ms`);
          ach?.style?.setProperty("--outDur", `${outDur}ms`);
          ach?.style?.setProperty("--outDelay", `${outDelay}ms`);
          ach?.style?.setProperty("--timeline-scale", String(timelineScale));
          restartAnimation(ach, total);

          // Apply marquee to title/detail if overflowing
          requestAnimationFrame(() => {
            // TITLE marquee via Web Animations API
            try {
              titleEl.getAnimations().forEach((a) => a.cancel());
            } catch {}
            titleEl.classList.remove("marquee");
            void titleEl.offsetWidth; // reflow
            const tOverflow = titleEl.scrollWidth - titleEl.clientWidth;
            if (tOverflow > 0) {
              const px = Math.ceil(tOverflow + 24);
              titleEl.classList.add("marquee"); // makes it inline-block under clipping parent
              titleEl.animate(
                [
                  { transform: "translateX(0)" },
                  { transform: `translateX(-${px}px)` },
                ],
                {
                  duration: Math.max(3000, Math.round(px / 50) * 1000),
                  delay: 1200,
                  easing: "linear",
                  fill: "both",
                }
              );
            }

            // DETAIL marquee if overflow exceeds 2 lines
            try {
              detailEl.getAnimations().forEach((a) => a.cancel());
            } catch {}
            detailEl.classList.remove("marquee");
            void detailEl.offsetWidth;
            const dOverflowY = detailEl.scrollHeight - detailEl.clientHeight;
            if (dOverflowY > 1) {
              const dpx = Math.ceil(
                detailEl.scrollWidth - detailEl.clientWidth + 24
              );
              detailEl.classList.add("marquee");
              detailEl.animate(
                [
                  { transform: "translateX(0)" },
                  { transform: `translateX(-${dpx}px)` },
                ],
                {
                  duration: Math.max(3000, Math.round(dpx / 45) * 1000),
                  delay: 1200,
                  easing: "linear",
                  fill: "both",
                }
              );
            }
          });

        });
      });
    </script>
  </body>
</html>
